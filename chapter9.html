<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
	<TITLE>Modularité -- JavaScript Éloquent</TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 3.2  (Linux)">
	<META NAME="CREATED" CONTENT="0;0">
	<META NAME="CHANGEDBY" CONTENT="famille ">
	<META NAME="CHANGED" CONTENT="20110804;6274300">
	<SCRIPT SRC="js/before.js"></SCRIPT>
	<SCRIPT>
var chapterTag = 'modularity';
</SCRIPT>
	<STYLE TYPE="text/css">
	<!--
		PRE.cjk { font-family: "DejaVu Sans", monospace }
		CODE.cjk { font-family: "DejaVu Sans", monospace }
	-->
	</STYLE>
</HEAD>
<BODY LANG="fr-FR" DIR="LTR">
<P><A HREF="chapter8.html">&lt;&lt; Chapitre précédent</A> | <A HREF="contents.html">Table
des matières</A> | <A HREF="index.html">Couverture</A> | <A HREF="chapter10.html">Chapitre
suivant &gt;&gt;</A></P>
<H1>Chapitre 9&nbsp;: Modularité</H1>
<P>Ce chapitre traite de la procédure d'organisation des programmes.
Pour les programmes de taille modeste, la question de l'organisation
est rarement un problème. Mais quand un programme se développe, il
peut atteindre une taille conséquente qui rend difficile à
contrôler sa structure et son interprétation. Un tel programme
commence assez facilement à ressembler à un plat de spaghetti, une
masse informe dans laquelle tout semble relié à tout le reste.</P>
<P><A NAME="key1"></A>Quand nous structurons un programme, nous
faisons deux choses. Nous le divisons en parties plus petites,
appelées modules, chacun d'eux ayant un rôle spécifique, et nous
précisons les relations entre ces parties.</P>
<P>Dans le <A HREF="chapter8.html">chapitre 8</A>, en développant un
terrarium, nous avons utilisé un grand nombre de fonctions décrites
dans le <A HREF="chapter6.html">chapitre 6</A>. Ce dernier
définissait également quelques nouveaux concepts qui n'avaient rien
de spécifique aux terrariums, comme les types <CODE CLASS="western">clone</CODE>
et <CODE CLASS="western">Dictionary</CODE>. Tous ces éléments ont
été introduits de façon peu méthodique dans l'environnement du
programme. Une façon de découper ce programme en modules pourrait
être&nbsp;:</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm">un module <CODE CLASS="western">FunctionalTools</CODE>,
	qui inclut les fonctions du <A HREF="chapter6.html">chapitre 6</A>,
	et ne dépend de rien d'autre.</P>
	<LI><P STYLE="margin-bottom: 0cm">un autre module <CODE CLASS="western">ObjectTools</CODE>,
	qui contient des choses comme <CODE CLASS="western">clone</CODE> et
	<CODE CLASS="western">create</CODE>, et dépend de <CODE CLASS="western">FunctionalTools</CODE>.</P>
	<LI><P STYLE="margin-bottom: 0cm"><CODE CLASS="western">Dictionary</CODE>,
	contenant le type Dictionnaire, et dépendant de <CODE CLASS="western">FunctionalTools</CODE>.</P>
	<LI><P>et finalement le module <CODE CLASS="western">Terrarium</CODE>,
	dépendant de <CODE CLASS="western">ObjectTools</CODE> et
	<CODE CLASS="western">Dictionary</CODE>.</P>
</UL>
<P>Quand un module dépend d'un autre, il utilise des fonctions et
des variables de ce module, et ne fonctionnera que si le module est
chargé.</P>
<P>It is a good idea to make sure dependencies never form a circle.
Not only do circular dependencies create a practical problem (if
module <CODE CLASS="western">A</CODE> and <CODE CLASS="western">B</CODE>
depend on each other, which one should be loaded first?), it also
makes the relation between the modules less straightforward, and can
result in a modularised version of the spaghetti I mentioned earlier.</P>
<P>Most modern programming languages have some kind of module system
built in. Not JavaScript. Once again, we have to invent something
ourselves. The most obvious way to start is to put every module in a
different file. This makes it clear which code belongs to which
module.</P>
<P><A NAME="key3"></A>Browsers load JavaScript files when they find a
<CODE CLASS="western">&lt;script&gt;</CODE> tag with an <CODE CLASS="western">src</CODE>
attribute in the HTML of the web-page. The extension <CODE CLASS="western">.js</CODE>
is usually used for files containing JavaScript code. On the console,
a shortcut for loading files is provided by the <CODE CLASS="western">load</CODE>
function.</P>
<PRE CLASS="western" STYLE="margin-bottom: 0.5cm">load(&quot;FunctionalTools.js&quot;);</PRE><P>
In some cases, giving load commands in the wrong order will result in
errors. If a module tries to create a <CODE CLASS="western">Dictionary</CODE>
object, but the <CODE CLASS="western">Dictionary</CODE> module has
not been loaded yet, it will be unable to find the constructor, and
will fail.</P>
<P>One would imagine this to be easy to solve. Just put some calls to
<CODE CLASS="western">load</CODE> at the top of the file for a
module, to load all the modules it depends on. Unfortunately, because
of the way browsers work, calling <CODE CLASS="western">load</CODE>
does not immediately cause the given file to be loaded. The file will
be loaded <EM>after</EM> the current file has finished executing.
Which is too late, usually.</P>
<P>In most cases, the practical solution is to just manage
dependencies by hand: Put the <CODE CLASS="western">script</CODE>
tags in your HTML documents in the right order.</P>
<P>There are two ways to (partially) automate dependency management.
The first is to keep a separate file with information about the
dependencies between modules. This can be loaded first, and used to
determine the order in which to load the files. The second way is to
not use a <CODE CLASS="western">script</CODE> tag (<CODE CLASS="western">load</CODE>
internally creates and adds such a tag), but to fetch the content of
the file directly (see <A HREF="chapter14.html">chapitre 14</A>), and
then use the <CODE CLASS="western">eval</CODE> function to execute
it. This makes script loading instantaneous, and thus easier to deal
with.</P>
<P><A NAME="key4"></A><CODE CLASS="western">eval</CODE>, short for
'evaluate', is an interesting function. You give it a string value,
and it will execute the content of the string as JavaScript code.</P>
<PRE CLASS="western" STYLE="margin-bottom: 0.5cm">eval(&quot;print(\&quot;I am a string inside a string!\&quot;);&quot;);</PRE><P>
You can imagine that <CODE CLASS="western">eval</CODE> can be used to
do some interesting things. Code can build new code, and run it. In
most cases, however, problems that can be solved with creative uses
of <CODE CLASS="western">eval</CODE> can also be solved with creative
uses of anonymous functions, and the latter is less likely to cause
strange problems.</P>
<P>When <CODE CLASS="western">eval</CODE> is called inside a
function, all new variables will become local to that function. Thus,
when a variation of the <CODE CLASS="western">load</CODE> would use
<CODE CLASS="western">eval</CODE> internally, loading the <CODE CLASS="western">Dictionary</CODE>
module would create a <CODE CLASS="western">Dictionary</CODE>
constructor inside of the <CODE CLASS="western">load</CODE> function,
which would be lost as soon as the function returned. There are ways
to work around this, but they are rather clumsy.</P>
<P>Let us quickly go over the first variant of dependency management.
It requires a special file for dependency information, which could
look something like this:</P>
<PRE CLASS="western">var dependencies =
  {&quot;ObjectTools.js&quot;: [&quot;FunctionalTools.js&quot;],
   &quot;Dictionary.js&quot;:  [&quot;ObjectTools.js&quot;],
   &quot;TestModule.js&quot;:  [&quot;FunctionalTools.js&quot;, &quot;Dictionary.js&quot;]};</PRE><P>
The <CODE CLASS="western">dependencies</CODE> object contains a
property for each file that depends on other files. The values of the
properties are arrays of file names. Note that we could not use a
<CODE CLASS="western">Dictionary</CODE> object here, because we can
not be sure that the <CODE CLASS="western">Dictionary</CODE> module
has been loaded yet. Because all the properties in this object will
end in <CODE CLASS="western">&quot;.js&quot;</CODE>, they are
unlikely to interfere with hidden properties like <CODE CLASS="western">__proto__</CODE>
or <CODE CLASS="western">hasOwnProperty</CODE>, and a regular object
will work fine.</P>
<P>The dependency manager must do two things. Firstly it must make
sure that files are loaded in the correct order, by loading a file's
dependencies before the file itself. And secondly, it must make sure
that no file is loaded twice. Loading the same file twice might cause
problems, and is definitely a waste of time.</P>
<PRE CLASS="western">var loadedFiles = {};

function require(file) {
  if (dependencies[file]) {
    var files = dependencies[file];
    for (var i = 0; i &lt; files.length; i++)
      require(files[i]);
  }
  if (!loadedFiles[file]) {
    loadedFiles[file] = true;
    load(file);
  }
}</PRE><P>
<A NAME="key5"></A>The <CODE CLASS="western">require</CODE> function
can now be used to load a file and all its dependencies. Note how it
recursively calls itself to take care of dependencies (and possible
dependencies of that dependency).</P>
<PRE CLASS="western" STYLE="margin-bottom: 0.5cm">require(&quot;TestModule.js&quot;);
test();</PRE><P>
Building a program as a set of nice, small modules often means the
program will use a lot of different files. When programming for the
web, having lots of small JavaScript files on a page tends to make
the page slower to load. This does not have to be a problem though.
You can write and test your program as a number of small files, and
put them all into a single big file when 'publishing' the program to
the web.</P>
<P>Just like an object type, a module has an interface. In simple
collection-of-functions modules such as <CODE CLASS="western">FunctionalTools</CODE>,
the interface usually consists of all the functions that are defined
in the module. In other cases, the interface of the module is only a
small part of the functions defined inside it. For example, our
manuscript-to-HTML system from <A HREF="chapter6.html">chapitre 6</A>
only needs an interface of a single function, <CODE CLASS="western">renderFile</CODE>.
(The sub-system for building HTML would be a separate module.)</P>
<P>For modules which only define a single type of object, such as
<CODE CLASS="western">Dictionary</CODE>, the object's interface is
the same as the module's interface.</P>
<P>In JavaScript, 'top-level' variables all live together in a single
place. In browsers, this place is an object that can be found under
the name <CODE CLASS="western">window</CODE>. The name is somewhat
odd, <CODE CLASS="western">environment</CODE> or <CODE CLASS="western">top</CODE>
would have made more sense, but since browsers associate a JavaScript
environment with a window (or 'frame'), someone decided that <CODE CLASS="western">window</CODE>
was a logical name.</P>
<PRE CLASS="western">show(window);
show(window.print == print);
show(window.window.window.window.window);</PRE><P>
As the third line shows, the name <CODE CLASS="western">window</CODE>
is merely a property of this environment object, pointing at itself.</P>
<P><A NAME="key6"></A>When much code is loaded into an environment,
it will use many top-level variable names. Once there is more code
than you can really keep track of, it becomes very easy to
accidentally use a name that was already used for something else.
This will break the code that used the original value. The
proliferation of top-level variables is called name-space pollution,
and it can be a rather severe problem in JavaScript ― the language
will not warn you when you redefine an existing variable.</P>
<P>There is no way to get rid of this problem entirely, but it can be
greatly reduced by taking care to cause as little pollution as
possible. For one thing, modules should not use top-level variables
for values that are not part of their external interface.</P>
<P>Not being able to define any internal functions and variables at
all in your modules is, of course, not very practical. Fortunately,
there is a trick to get around this. We write all the code for the
module inside a function, and then finally add the variables that are
part of the module's interface to the <CODE CLASS="western">window</CODE>
object. Because they were created in the same parent function, all
the functions of the module can see each other, but code outside of
the module can not.</P>
<PRE CLASS="western">function buildMonthNameModule() {
  var names = [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;,
               &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;,
               &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];
  function getMonthName(number) {
    return names[number];
  }
  function getMonthNumber(name) {
    for (var number = 0; number &lt; names.length; number++) {
      if (names[number] == name)
        return number;
    }
  }

  window.getMonthName = getMonthName;
  window.getMonthNumber = getMonthNumber;
}
buildMonthNameModule();

show(getMonthName(11));</PRE><P>
This builds a very simple module for translating between month names
and their number (as used by <CODE CLASS="western">Date</CODE>, where
January is <CODE CLASS="western">0</CODE>). But note that
<CODE CLASS="western">buildMonthNameModule</CODE> is still a
top-level variable that is not part of the module's interface. Also,
we have to repeat the names of the interface functions three times.
Ugh.</P>
<P>The first problem can be solved by making the module function
anonymous, and calling it directly. To do this, we have to add a pair
of parentheses around the function value, or JavaScript will think it
is a normal function definition, which can not be called directly.</P>
<P>The second problem can be solved with a helper function, <CODE CLASS="western">provide</CODE>,
which can be given an object containing the values that must be
exported into the <CODE CLASS="western">window</CODE> object.</P>
<PRE CLASS="western">function provide(values) {
  forEachIn(values, function(name, value) {
    window[name] = value;
  });
}</PRE><P>
Using this, we can write a module like this:</P>
<PRE CLASS="western">(function() {
  var names = [&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;,
               &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;];
  provide({
    getDayName: function(number) {
      return names[number];
    },
    getDayNumber: function(name) {
      for (var number = 0; number &lt; names.length; number++) {
        if (names[number] == name)
          return number;
      }
    }
  });
})();

show(getDayNumber(&quot;Wednesday&quot;));</PRE><P>
I do not recommend writing modules like this right from the start.
While you are still working on a piece of code, it is easier to just
use the simple approach we have used so far, and put everything at
top level. That way, you can inspect the module's internal values in
your browser, and test them out. Once a module is more or less
finished, it is not difficult to wrap it in a function.</P>
<P>There are cases where a module will export so many variables that
it is a bad idea to put them all into the top-level environment. In
cases like this, you can do what the standard <CODE CLASS="western">Math</CODE>
object does, and represent the module as a single object whose
properties are the functions and values it exports. For example...</P>
<PRE CLASS="western">var HTML = {
  tag: function(name, content, properties) {
    return {name: name, properties: properties, content: content};
  },
  link: function(target, text) {
    return HTML.tag(&quot;a&quot;, [text], {href: target});
  }
  /* ... many more HTML-producing functions ... */
};</PRE><P>
When you need the content of such a module so often that it becomes
cumbersome to constantly type <CODE CLASS="western">HTML</CODE>, you
can always move it into the top-level environment using <CODE CLASS="western">provide</CODE>.</P>
<PRE CLASS="western">provide(HTML);
show(link(&quot;http://docs.sun.com/source/816-6408-10/object.htm&quot;,
          &quot;This is how objects work.&quot;));</PRE><P>
You can even combine the function and object approaches, by putting
the internal variables of the module inside a function, and having
this function return an object containing its external interface.</P>
<P>When adding methods to standard prototypes, such as those of <CODE CLASS="western">Array</CODE>
and <CODE CLASS="western">Object</CODE> a similar problem to
name-space pollution occurs. If two modules decide to add a <CODE CLASS="western">map</CODE>
method to <CODE CLASS="western">Array.prototype</CODE>, you might
have a problem. If these two versions of <CODE CLASS="western">map</CODE>
have the precise same effect, things will continue to work, but only
by sheer luck.</P>
<P>Designing an interface for a module or an object type is one of
the subtler aspects of programming. On the one hand, you do not want
to expose too many details. They will only get in the way when using
the module. On the other hand, you do not want to be <EM>too</EM>
simple and general, because that might make it impossible to use the
module in complex or specialised situations.</P>
<P>Sometimes the solution is to provide two interfaces, a detailed
'low-level' one for complicated things, and a simple 'high-level' one
for straightforward situations. The second one can usually be built
very easily using the tools provided by the first one.</P>
<P>In other cases, you just have to find the right idea around which
to base your interface. Compare this to the various approaches to
inheritance we saw in <A HREF="chapter8.html">chapitre 8</A>. By
making prototypes the central concept, rather than constructors, we
managed to make some things considerably more straightforward.</P>
<P>The best way to learn to the value of good interface design is,
unfortunately, to use bad interfaces. Once you get fed up with them,
you'll figure out a way to improve them, and learn a lot in the
process. Try not to assume that a lousy interface is 'just the way it
is'. Fix it, or wrap it in a new interface that is better (we will
see an example of this in <A HREF="chapter12.html">chapitre 12</A>).</P>
<P>There are functions which require a lot of arguments. Sometimes
this means they are just badly designed, and can easily be remedied
by splitting them into a few more modest functions. But in other
cases, there is no way around it. Typically, some of these arguments
have a sensible 'default' value. We could, for example, write yet
another extended version of <CODE CLASS="western">range</CODE>.</P>
<PRE CLASS="western">function range(start, end, stepSize, length) {
  if (stepSize == undefined)
    stepSize = 1;
  if (end == undefined)
    end = start + stepSize * (length - 1);

  var result = [];
  for (; start &lt;= end; start += stepSize)
    result.push(start);
  return result;
}

show(range(0, undefined, 4, 5));</PRE><P>
It can get hard to remember which argument goes where, not to mention
the annoyance of having to pass <CODE CLASS="western">undefined</CODE>
as a second argument when a <CODE CLASS="western">length</CODE>
argument is used. We can make passing arguments to this function more
comprehensive by wrapping them in an object.</P>
<PRE CLASS="western">function defaultTo(object, values) {
  forEachIn(values, function(name, value) {
    if (!object.hasOwnProperty(name))
      object[name] = value;
  });
}

function range(args) {
  defaultTo(args, {start: 0, stepSize: 1});
  if (args.end == undefined)
    args.end = args.start + args.stepSize * (args.length - 1);

  var result = [];
  for (; args.start &lt;= args.end; args.start += args.stepSize)
    result.push(args.start);
  return result;
}

show(range({stepSize: 4, length: 5}));</PRE><P>
The <CODE CLASS="western">defaultTo</CODE> function is useful for
adding default values to an object. It copies the properties of its
second argument into its first argument, skipping those that already
have a value.</P>
<P><A NAME="key7"></A>A module or group of modules that can be useful
in more than one program is usually called a library. For many
programming languages, there is a huge set of quality libraries
available. This means programmers do not have to start from scratch
all the time, which can make them a lot more productive. For
JavaScript, unfortunately, the amount of available libraries is not
very large.</P>
<P>But recently this seems to be improving. There are a number of
good libraries with 'basic' tools, things like <CODE CLASS="western">map</CODE>
and <CODE CLASS="western">clone</CODE>. Other languages tend to
provide such obviously useful things as built-in standard features,
but with JavaScript you'll have to either build a collection of them
for yourself or use a library. Using a library is recommended: It is
less work, and the code in a library has usually been tested more
thoroughly than the things you wrote yourself.</P>
<P>Covering these basics, there are (among others) the 'lightweight'
libraries <A HREF="http://www.prototypejs.org/">prototype</A>,
<A HREF="http://mootools.net/">mootools</A>, <A HREF="http://jquery.com/">jQuery</A>,
and <A HREF="http://mochikit.com/">MochiKit</A>. There are also some
larger 'frameworks' available, which do a lot more than just provide
a set of basic tools. <A HREF="http://developer.yahoo.com/yui/">YUI</A>
(by Yahoo), and <A HREF="http://dojotoolkit.org/">Dojo</A> seem to be
the most popular ones in that genre. All of these can be downloaded
and used free of charge. My personal favourite is MochiKit, but this
is mostly a matter of taste. When you get serious about JavaScript
programming, it is a good idea to quickly glance through the
documentation of each of these, to get a general idea about the way
they work and the things they provide.</P>
<P>The fact that a basic toolkit is almost indispensable for any
non-trivial JavaScript programs, combined with the fact that there
are so many different toolkits, causes a bit of a dilemma for library
writers. You either have to make your library depend on one of the
toolkits, or write the basic tools yourself and include them with the
library. The first option makes the library hard to use for people
who are using a different toolkit, and the second option adds a lot
of non-essential code to the library. This dilemma might be one of
the reasons why there are relatively few good, widely used JavaScript
libraries. It is possible that, in the future, new versions of
ECMAScript and changes in browsers will make toolkits less necessary,
and thus (partially) solve this problem.</P>
<P STYLE="margin-bottom: 0cm"><A HREF="chapter8.html">&lt;&lt;
Chapitre précédent</A> | <A HREF="contents.html">Table des matières</A>
| <A HREF="index.html">Couverture</A> | <A HREF="chapter10.html">Chapitre
suivant &gt;&gt;</A></P>
<P STYLE="margin-bottom: 0cm">© <A HREF="mailto:marijnh@gmail.com">Marijn
Haverbeke</A> (<A HREF="http://creativecommons.org/licenses/by/3.0/deed.fr">licence</A>),
écrit entre mars et juillet 2007, dernière modification le 11
juillet 2011.</P>
<P STYLE="margin-bottom: 0cm"><SCRIPT SRC="js/ejs.js"></SCRIPT><BR>
</P>
</BODY>
</HTML>