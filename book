====================
Introduction / intro
====================

Lorsque les premiers ordinateurs personnels sont apparus, la plupart d'entre
eux étaient fournis avec un langage de programmation simple, généralement
une variante de _BASIC_. Les interactions avec l'ordinateur étaient fortement
liées à ce langage, et tout utilisateur d'un ordinateur devait dès lors y
goûter, qu'il le veuille ou non. À présent que les ordinateurs sont devenus
nombreux et bon marché, l'utilisateur moyen se contente la plupart du temps
de ce qu'il peut faire en cliquant avec la souris. Pour nombre d'entre eux,
cela fonctionne très bien. Mais pour ceux d'entre nous qui ont une inclination
naturelle au bricolage technique, la disparition de la programmation dans
l'usage quotidien d'un ordinateur représente une forme de barrière.

Heureusement, avec l'évolution du World Wide Web, il se trouve que chaque
ordinateur équipé d'un navigateur web moderne a également un environnement
pour programmer en JavaScript. Il est gardé bien caché car il est dans
l'air du temps de ne pas ennuyer l'utilisateur avec des détails techniques,
mais une page web peut le rendre accessible et l'utiliser comme une plateforme
pour apprendre à programmer.

C'est ce que ce livre (ou hyper-livre) essaie de faire.

---

| Je n'ai pas pour but d'éclairer ceux qui ne sont pas désireux
| d'apprendre, ni éveiller ceux qui ne sont pas soucieux de donner une
| explication eux-mêmes. Si je leur ai montré un angle du carré et
| qu'ils ne peuvent pas revenir à moi avec les trois autres, je ne
| devrais pas revenir sur le premier angle.
|
| — Confucius

Au-delà des explications qu'il donne sur le JavaScript, ce livre s'efforce
d'initier aux principes fondamentaux de la programmation. Programmer
s'avère être un exercice difficile. Les règles de base sont la plupart
du temps simples et claires. Cependant, même des programmes construits
suivant ces règles de base, tendent à devenir suffisamment élaborés pour
générer leurs propres règles et leur propre complexité. Voilà pourquoi la
programmation est rarement simple et prévisible. Comme le dit Donald Knuth,
que l'on peut considérer comme un des pères fondateurs dans ce domaine,
c'est un *art*.

Pour tirer quelque chose de ce livre, il est indispensable de faire plus que
de le lire passivement. Essayez de garder l'esprit affûté, efforcez-vous
de résoudre les exercices, et n'allez plus loin que lorsque vous êtes
certain d'avoir bien assimilé les étapes précédentes.

---

| Le programmeur en informatique est un créateur d'univers dont il
| est seul responsable. Des univers d'une complexité potentiellement
| illimitée peuvent être créés sous forme de programmes informatiques.
|
| ― Joseph Weizenbaum, *La puissance de l'ordinateur et la raison humaine*

Un programme, c'est beaucoup de choses. C'est un bout de texte tapé par un
programmeur, c'est la force directrice qui indique à l'ordinateur ce qu'il
doit faire, c'est un ensemble de données dans la mémoire de l'ordinateur,
et pourtant il contrôle les actions accomplies dans cette même mémoire. Les
analogies qui comparent les programmes à des objets qui nous sont familiers
ont tendance à tourner court alors que celle d'une machine est, de manière
superficielle, mieux adaptée. Les roues et les engrenages d'une montre
mécanique sont ingénieusement agencés et coordonnés, et si l'horloger
connaît son affaire, la montre donnera l'heure pendant des années. Les
parties d'un programme sont de même étroitement solidaires et si le
programmeur sait ce qu'il fait, son programme fonctionnera sans plantage.

Un ordinateur est une machine conçue pour héberger ce genre de machines
immatérielles. Les ordinateurs eux-mêmes ne peuvent qu'exécuter stupidement
des choses simples. S'ils sont très utiles, c'est parce qu'ils peuvent
faire ces choses à une vitesse incroyable. Un programme peut, en combinant
un grand nombre de ces actions simples, accomplir des tâches très complexes.

Pour beaucoup d'entre nous, écrire des programmes informatiques est un
jeu fascinant. Un programme est une construction de l'esprit. Il ne coûte
rien à élaborer, il ne pèse rien et se développe facilement sous nos
mains. Si nous nous laissons aller, sa taille et sa complexité vont prendre
des proportions démesurées, au point d'échapper au contrôle même de celui
qui l'a créé. C'est le principal problème de la programmation. C'est la
raison pour laquelle beaucoup de logiciels aujourd'hui finissent par planter,
échouer et tout saloper.

Quand un programme fonctionne, c'est beau. L'art de la programmation est
l'art de contrôler la complexité. Un programme de grande qualité est
discret et apparaît simple malgré sa complexité.

---

Aujourd'hui, beaucoup de programmeurs croient que cette complexité est
plus facile à gérer en utilisant seulement un petit jeu de techniques
bien comprises dans leurs programmes. Ils ont élaboré des règles strictes
concernant la forme que devraient adopter les programmes, et les plus zélés
d'entre eux dénonceront ceux qui enfreignent ces règles comme de *mauvais*
programmeurs.

Quelle hostilité envers la richesse de la programmation ! Essayer de
la réduire à quelque chose de direct et de prévisible, jeter l'opprobre
sur tous les programmes bizarres et magnifiques. Le champ des techniques de
programmation est gigantesque, fascinant par sa diversité et encore largement
inexploré. Il est certainement bourré de chausse-trappes et de pièges à
loups, menaçant de faire commettre au programmeur inexpérimenté toute sorte
d'affreuses erreurs. Cela signifie seulement que vous devez procéder avec
prudence et garder votre sang-froid. En apprenant, vous rencontrerez toujours
de nouveaux défis, de nouveaux territoires à explorer. Le programmeur qui
refuse l'exploration va sûrement végéter, ne plus trouver ça drôle,
perdre le désir de programmer (et devenir chef de projet).

En ce qui me concerne, le critère décisif pour évaluer un programme est :
« Est-il correct ? ». L'efficacité, la clarté et la taille sont
également importantes, mais pouvoir peser avec exactitude le poids de l'un
et le poids de l'autre est toujours une question d'opinion, une opinion
que doit se faire chaque programmeur. Les règles générales sont utiles,
mais on ne devrait jamais avoir peur de les transgresser.

---

Au début de l'informatique, lorsqu'elle venait de naître, il n'existait
pas de langage de programmation. Les programmes ressemblaient à ceci :

] 00110001 00000000 00000000
] 00110001 00000001 00000001
] 00110011 00000001 00000010
] 01010001 00001011 00000010
] 00100010 00000010 00001000
] 01000011 00000001 00000000
] 01000001 00000001 00000001
] 00010000 00000010 00000000
] 01100010 00000000 00000000

Il s'agit d'un programme qui fait la somme des nombres de 1 à 10 et donne
le résultat (1 + 2 + … + 10 = 55). Il pourrait tourner sur l'ordinateur le
plus simple. Pour programmer les premiers ordinateurs, il était nécessaire
de disposer de grandes séries d'interrupteurs dans la bonne position, ou de
perforer des trous dans des cartes et les faire avaler à la machine. Vous
imaginez facilement à quel point la procédure était fastidieuse et sujette
à erreurs. Écrire ne serait-ce qu'un programme simple exigeait beaucoup
d'intelligence et de discipline, les programmes complexes étaient carrément
hors d'atteinte.

Bien entendu, saisir à la main des masques de bits (c'est ainsi qu'on
appelle en général les suites de 1 et de 0 ci-dessus) donnait au programmeur
l'impression d'être un puissant sorcier. Cela ne peut pas compter pour du
beurre en ce qui concerne la satisfaction professionnelle.

Chaque ligne de programme contient une instruction unique. On pourrait
l'exprimer en français sous cette forme :

 1. Stocker le nombre 0 à l'adresse mémoire 0
 2. Stocker le nombre 1 à l'adresse mémoire 1
 3. Stocker la valeur de l'adresse mémoire 1 dans l'adresse mémoire 2
 4. Soustraire 11 de la valeur stockée à l'adresse mémoire 2
 5. Si la valeur à l'adresse mémoire 2 est le nombre 0, continuer à l'instruction 9
 6. Ajouter la valeur de l'adresse mémoire 1 à l'adresse mémoire 0
 7. Ajouter le nombre 1 à la valeur de l'adresse mémoire 1
 8. Continuer avec l'instruction 3
 9. Donner la valeur de l'adresse mémoire 0

Alors que c'est déjà plus lisible que la soupe binaire, cela reste assez
désagréable. Il pourrait être utile d'utiliser des noms au lieu de nombres
pour les instructions et les adresses mémoire :

]  Mettre 0 à 'total'
]  Mettre 1 à 'compteur'
] [boucle]
]  Mettre compteur' à 'comparaison'
]  Soustraire 11 à 'comparaison'
]  Si 'comparaison' est zero, continuer à [fin]
]  Ajouter 'compteur' à 'total'
]  Ajouter 1 à 'compteur'
]  Continuer à [boucle]
] [fin]
]  Afficher 'total'

À partir de là il n'est pas trop difficile de deviner comment fonctionne
le programme. Qu'en dites-vous ? Les deux premières lignes donnent leur
valeur initiale aux adresses mémoire : |total| sera utilisé pour calculer
le résultat du programme et |compteur| conserve le nombre courant. Les
lignes qui utilisent |comparaison| sont probablement les plus bizarres. Ce
que le programme cherche à savoir c'est si |compteur| est égal à 11,
de manière à savoir s'il doit interrompre le calcul. Comme la machine est
très rudimentaire, il peut seulement tester si un nombre est zéro, et prend
une décision (sauter) basée sur ce critère. il utilise donc l'adresse
mémoire nommée |comparaison| pour calculer la valeur de |compteur - 11|,
et décide suivant la valeur obtenue. Les deux lignes suivantes ajoutent la
valeur de |compteur| au résultat, et l'incrémentent |compteur| d'une unité
à chaque fois que le programme a décidé qu'il n'avait pas encore atteint 11.

Voici maintenant le même programme en JavaScript :

> var total = 0, compteur = 1;
> while (compteur <= 10) {
>   total += compteur;
>   compteur += 1;
> }
> print(total);

C'est encore un peu mieux pour nous. Le plus important est qu'il n'y a plus
besoin de préciser la façon dont nous voulons que le programme fasse un bond
par-ci par-là. Le mot magique |while| s'en occupe. Le programme continue à
exécuter les lignes ci-dessous tant que la condition qu'on lui a donnée est
satisfaite : |compteur <= 10|, ce qui veut dire tant que « |compteur|
est inférieur ou égal à |10| ». Apparemment, il n'y a plus besoin de
créer une valeur temporaire et de la comparer à zéro. C'était un petit
détail stupide, et le pouvoir des langages de programmation est justement
qu'ils règlent pour nous ce genre de choses accessoires.

Finalement, voici à quoi pourrait ressembler le programme si nous nous étions
arrangés pour que les opérations |serie| et |somme| soient disponibles,
la première créant une collection de nombres dans une série tandis que
la seconde calcule la somme d'une série de nombres :

> print(somme(serie(1, 10)));

La morale de cette histoire est donc que le même programme peut être
exprimé de façon brève ou longue, lisible ou illisible. La première
version du programme était extrêmement obscure, tandis que la dernière
est quasiment du français : |print| (afficher) la |somme| de la |serie|
des nombres de |1| à |10|. Nous verrons par la suite dans d'autres chapitres
comment construire des choses telles que |somme| et |serie|.

Un bon langage de programmation aide le programmeur en lui fournissant une
manière plus abstraite de s'exprimer. Il masque les détails inintéressants,
procure des composants de base pratiques (comme la |while|) et, la plupart
du temps, permet au programmeur d'ajouter lui-même de telles briques (comme
les opérations |somme| et |serie|).

---

JavaScript est le langage qui est, actuellement, le plus
utilisé pour faire toutes sortes de choses géniales et
horribles avec des pages sur le World Wide Web. [Certains |
http://steve-yegge.blogspot.com/2007/02/next-big-language.html] prétendent
que la prochaine version de JavaScript en fera un langage de référence
pour d'autres tâches également. J'ignore si cela va se produire, mais si
vous êtes intéressé par la programmation, JavaScript est sans aucun doute
un langage utile à apprendre. Même si en fin de compte vous ne faites pas
tellement de programmation web, les programmes hallucinants que je vais vous
montrer dans cet ouvrage resteront toujours en vous, à vous hanter et à
influencer les programmes que vous écrirez dans d'autres langages.

Certains vous diront des choses *terribles* à propos de JavaScript. Beaucoup
de ces reproches sont fondés. La première fois que j'ai dû écrire quelque
chose en JavaScript, j'ai rapidement méprisé ce langage. Il acceptait
à peu près tout ce que je tapais, mais l'interprétait d'une façon
complètement différente de celle que je voulais. Cela venait surtout du
fait que je n'avais aucune idée de ce que je faisais, mais il y a aussi un
véritable problème ici : JavaScript est absurdement laxiste dans ce qu'il
permet. L'idée derrière cette conception était de rendre la programmation
en JavaScript plus facile pour les débutants. En réalité, il rend surtout
plus difficile la recherche des problèmes dans vos programmes, parce que
le système ne vous les montrera pas.

Toutefois, la souplesse de ce langage est aussi un avantage. Elle laisse la
place à de nombreuses techniques que les langages de programmation plus
rigides ne permettent pas, et on peut l'utiliser pour compenser certains
défauts de JavaScript. Après l'avoir étudié correctement et avoir
travaillé avec un certain temps, j'ai vraiment appris à *aimer* ce langage.

---

Contrairement à ce que son nom suggère, JavaScript a très peu à voir avec
le langage de programmation nommé Java. Le nom similaire a été inspiré
par des considérations commerciales plutôt que rationnelles. En 1995,
quand le JavaScript a été lancé par Netscape, le langage Java était promu
partout et gagnait en popularité. Apparemment, quelqu'un a dû penser que
c'était une bonne idée d'essayer de surfer sur la mode du moment. Nous
voilà aujourd'hui coincé avec ce nom.

Il existe un langage associé au JavaScript et qui s'appelle ECMAScript. Quand
les navigateurs autres que Netscape ont commencé à prendre en charge le
JavaScript, ou quelque chose du même genre, on a écrit une documentation pour
décrire avec précision comment le langage en question devait fonctionner. On
l'a appelé ECMAScript, d'après le nom de l'organisation qui l'a standardisé.

ECMAScript décrit un langage de programmation à usage général, mais ne
dit rien sur l'intégration de ce langage dans un navigateur internet. Le
JavaScript c'est ECMAScript plus des outils supplémentaires pour gérer
les pages web et les fenêtres de navigation.

Quelques autres logiciels utilisent le langage décrit dans le document
ECMAScript. Plus important, le langage ActionScript utilisé par Flash est
basé sur ECMAScript (bien qu'il ne suive pas précisément le standard). Flash
est un système utilisé pour ajouter des trucs qui bougent et font du bruit
sur les pages web. Ça ne vous fera pas de mal de connaître JavaScript si
vous devez un jour apprendre à faire des animations en Flash.

JavaScript continue d'évoluer. Depuis la sortie de cet ouvrage, ECMAScript
5 est sorti, il est compatible avec la version décrite ici, mais y ajoute,
en tant que méthodes natives, quelques fonctionnalités que nous écrirons
nous-même. La dernière génération de navigateurs fournit cette version
augmentée de JavaScript. En 2011, « ECMAScript harmony », une extension
plus radicale du langage, est en cours de standardisation. Vous ne devriez
pas trop craindre que ces nouvelles versions rendent obsolètes ce que vous
apprenez dans ce livre. Il ne s'agira que d'une extension du langage dont
nous disposons actuellement, donc pratiquement tout ce qui est écrit dans
ce livre restera valide.

---

La plupart des chapitres de ce livre contiennent une quantité non négligeable
de code##. D'après mon expérience, lire et écrire du code est une part
importante de l'apprentissage de la programmation. Essayez de ne pas seulement
jeter un œil sur ces exemples mais lisez-les vraiment attentivement et
comprenez-les. Cela peut être long et déroutant au début, mais vous prendrez
rapidement le coup. Il en va de même concernant les exercices. N'estimez pas
les comprendre avant d'avoir effectivement écrit une solution qui fonctionne.

## Le « Code » est la substance dont sont composés les
programmes. Chaque morceau de programme, que ce soit une ligne unique ou
tout un ensemble, peut être appelé « code ».

Le fonctionnement même du Web fait qu'il est toujours possible d'examiner
les programmes JavaScript que les gens utilisent dans leurs pages
web. Cela peut être un bon moyen d'apprendre comment certaines choses sont
réalisées. Étant donné que la plupart des programmeurs web ne sont pas
des programmeurs « professionnels », ou qu'ils ne considèrent pas
la programmation JavaScript comme suffisamment intéressante pour en faire
convenablement l'apprentissage, beaucoup du code que vous pourrez trouver
ainsi sera de *très* mauvaise qualité. Quand vous apprenez à partir de
code laid et incorrect, la laideur et la confusion se propagent dans votre
propre code ; faites donc très attention de qui vous prenez vos leçons.

---

Pour vous permettre d'essayer les programmes, aussi bien les exemples que le
code que vous écrirez vous-même, ce livre utilise ce que l'on appelle une
_console_. Si vous utilisez un navigateur graphique moderne (Internet Explorer
version 6 ou supérieur, Firefox 1.5 ou supérieur, Opera 9 ou supérieur,
Safari 3 ou supérieur), les pages de ce livre vont afficher une barre en
bas de votre écran. Vous pouvez ouvrir la console en cliquant sur la petite
flèche à l'extrémité droite de cette barre.

La console contient trois éléments importants. Il y a une fenêtre de
sortie, qui est utilisée pour montrer les messages d'erreurs et les choses
qu'affichent les programmes. Sous celle-ci se trouve une ligne où vous pouvez
saisir un bout de JavaScript. Essayez de saisir un nombre et appuyez sur la
touche Entrée pour lancer ce que vous avez tapé. Si le texte que vous avez
saisi a produit quelque chose de sensé, cela sera affiché dans la fenêtre
de sortie. Maintenant, essayez de taper |mauvais!|, et appuyez à nouveau
sur Entrée. La fenêtre de sortie va afficher un message d'erreur. Vous
pouvez utiliser les touches flèche vers le haut et flèche vers le bas pour
revenir aux commandes que vous avez saisies précédemment.

Pour les bouts de code plus importants, ceux qui s'étendent sur plusieurs
lignes et que vous voulez conserver un peu, le champ de droite peut être
utilisé. Le bouton « Lancer » est utilisé pour exécuter les programmes
écrits dans ce champ. Il est possible d'avoir plusieurs programmes ouverts en
même temps. Utilisez les boutons « Nouveau » et « Charger » pour
ajouter un nouveau programme (vide ou depuis un fichier sur le web). Quand il
y a plus d'un programme ouvert, le menu après le bouton « Lancer » peut
être utilisé pour choisir lequel est affiché. Le bouton « Fermer »,
comme vous pouvez vous en douter, ferme un programme.

Il y a toujours un petit bouton avec une flèche dans le coin supérieur
droit des programmes d'exemple de ce livre, qui peut être utilisé pour
les lancer. L'exemple que nous avons vu auparavant ressemblait à ceci :

> var total = 0, compteur = 1;
> while (compteur <= 10) {
>   total += compteur;
>   compteur += 1;
> }
> print(total);

Lancez-le en cliquant sur la flèche. Il y a aussi un autre bouton qui sert
à charger le programme dans la console. N'hésitez pas à le modifier et
à essayer le résultat. Le pire qu'il puisse arriver est que vous créiez
une boucle sans fin. Une boucle infinie est ce que vous obtenez lorsque
la condition d'un |while| ne devient jamais fausse, par exemple si vous
choisissez d'ajouter |0| au lieu de |1| à la variable compteur. Alors le
programme va tourner pour toujours.

Heureusement, les navigateurs gardent un œil sur les programmes qu'ils font
tourner. Lorsque l'un d'eux prend un délai démesuré pour se terminer,
ils vous demandent si vous voulez l'interrompre.

---

Dans certains chapitres à venir, nous créerons des programmes d'exemple
qui seront constitués de multiples blocs de code. Souvent, vous devrez
lancer chacun d'eux pour faire fonctionner le programme. Comme vous l'avez
peut-être remarqué, la flèche d'un bloc de code devient violette lorsque
le bloc a été exécuté. Lorsque vous lisez un chapitre, essayez de
lancer chaque bloc de code que vous rencontrez, particulièrement ceux qui
« définissent » quelque chose de nouveau (vous verrez ce que cela
signifie dans le prochain chapitre).

Il est évidemment possible que vous ne puissiez pas lire un chapitre
d'une seule traite. Ça veut dire que vous devrez commencer à mi-chemin
quand vous reprendrez votre lecture, mais si vous ne lancez pas tout le
code en commençant du haut du chapitre, certaines choses peuvent ne pas
fonctionner. En maintenant la touche majuscule pendant que vous appuyez sur
la flèche « Lancer » d'un bloc de code, tous les blocs précédents
celui-ci seront également exécutés, ainsi lorsque vous commencez au
milieu d'un chapitre, maintenez la touche majuscule enfoncée la première
fois que vous faites tourner un morceau de code, et tout devrait fonctionner
comme prévu.

---

Enfin, le petit visage dans le coin supérieur gauche de votre écran peut
être utilisé pour m'envoyer, à moi l'auteur, un message##. Si vous avez
un commentaire, ou que vous trouvez un passage incroyablement confus,
ou simplement que vous repérez une faute d'orthographe, faites-le moi
savoir. Il est possible d'envoyer un message sans quitter la page, ainsi
vous ne serez pas interrompu dans votre lecture.

## NdT: N'oubliez pas que l'auteur est anglophone.

===============================================================================
Les bases du JavaScript : valeurs, variables et structures de contrôle / basics
===============================================================================

Dans le monde des ordinateurs, seules les données existent. Ce qui n'est pas
une donnée n'existe pas. Bien que toute donnée soit en essence seulement une
séquence de bits##, et en cela fondamentalement similaires, chaque morceau
de donnée joue un rôle qui lui est propre. Dans le système JavaScript,
la plupart de ces données est soigneusement répartie entre des choses
appelées _valeur_s. Chaque valeur a un type qui détermine le rôle qu'elle
peut jouer. Il y a six types de valeurs de base : les nombres, les chaîne
de caractères, les booléens, les objets, les fonctions et |undefined|
pour représenter les valeurs indéfinies.

## Les bits sont toutes les choses à deux valeurs possibles, habituellement
décrits comme des |0| et des |1|. Dans l'ordinateur, ils se concrétisent
par une charge électrique élevée ou basse, un signal fort ou faible,
ou encore un point brillant ou terne sur la surface d'un CD.

Pour créer une valeur, on doit seulement invoquer son nom. C'est très
pratique. Vous n'avez pas à rassembler du matériel de construction pour vos
valeurs, ou payer pour elles, il vous suffit d'en appeler une et *hop*, vous
l'avez. Elles ne sont pas créées à partir de rien, évidemment. Chaque
valeur doit être stockée quelque part, et si vous voulez en utiliser un
grand nombre en même temps la mémoire de l'ordinateur pourrait venir à
manquer. Heureusement, ce problème ne se présente que si vous devez les
utiliser simultanément. Dès que vous n'utiliserez plus une valeur, elle
se dissipera en ne laissant que quelques bits derrière elle. Ces bits sont
recyclés pour fabriquer la génération suivante de valeurs.

---

Les valeurs de type nombre, nommées _number_ en JavaScript sont, comme vous
l'avez peut-être déduit, des valeurs numériques. Elles sont écrites de
la manière dont sont habituellement écrits les nombres :

>> 144

Saisissez cela dans la console et la même chose est affichée dans la
fenêtre de sortie. Le texte que vous avez saisi a donné naissance à une
valeur numérique; la console a pris ce nombre et l'a affiché de nouveau à
l'écran. Dans ce cas, c'était assez inutile, mais nous produirons bientôt
des valeurs de manières moins directes et il pourra être utile de « les
essayer » dans la console pour voir ce qu'elles produisent.

Voilà à quoi ressemble |144| écrit sous forme de bits##:

## Si vous attendiez quelque chose comme |10010000| c'est bien vu, mais
continuez à lire. Les nombres JavaScript ne sont pas stockés comme des
entiers.

] 0100000001100010000000000000000000000000000000000000000000000000

Le nombre précédent a 64 bits. C'est le cas de tous les nombres en
JavaScript. Cela a une répercussion importante : il y a une quantité
limitée de nombres pouvant être exprimés. Avec une décimale à trois
chiffres, seuls les nombres de 0 à 999 peuvent être écrits, soit 10^3 =
1000 nombres différents. Avec 64 chiffres binaires, on peut écrire 2^64
nombres différents. Cela en fait beaucoup, plus de 10^19 (un 1 suivi de
dix-neuf zéros).

Tous les nombres inférieurs à 10^19 ne tiennent cependant pas dans un
nombre JavaScript. D'une part, il y a aussi les nombres négatifs, ce
qui oblige à utiliser un des bits pour stocker le signe du nombre. Mais
ensuite, la représentation des nombres décimaux est un problème encore
plus important. Pour permettre celle-ci, 11 bits sont utilisés pour stocker
la position de la virgule au sein du nombre.

Il nous reste donc 52 bits##. Tout nombre entier inférieur à 2^52, ce
qui correspond à plus de 10^15, sera contenu sans risque dans un nombre
JavaScript. Dans la plupart des cas, les nombres que nous utilisons restent
bien en-deçà, nous n'avons donc absolument pas besoin de nous préoccuper
des bits, ce qui nous arrange. Je n'ai rien de particulier contre les bits,
mais *vous* avez besoin de beaucoup d'entre eux pour pouvoir faire quoi
que ce soit. Si possible, il est donc plus agréable de travailler avec des
entités plus grosses.

## En fait 53, à cause d'une astuce utilisable pour obtenir un bit
librement. Consultez le format « IEEE 754 » si vous êtes intéressé
par les détails.

Les nombres décimaux s'écrivent en utilisant un point.

>> 9.81

Pour les nombres très grands ou très petits, il est possible d'utiliser
la notation « scientifique », en ajoutant un |e| suivi de l'exposant
du nombre :

>> 2.998e8

Ce qui donne 2.998 * 10^8 = 299800000.

Les opérations avec des nombres sans virgule (aussi appelés nombres entiers)
tenant en 52 bits sont garanties d'être toujours précis. Malheureusement,
les opérations avec des nombres fractionnels ne le sont généralement
pas. Tout comme π (pi) qui ne peut être exprimé de manière précise
par un nombre fini de chiffres à décimales, beaucoup de nombres perdent en
précision lorsqu'on ne dispose que de 64 bits pour les stocker. C'est dommage,
mais cela ne crée de problèmes pratiques que dans des situations très
spécifiques. Le plus important est d'en être conscient et de considérer
les nombres fractionnels décimaux comme des approximations et non des
valeurs précises.

---

On utilise les nombres principalement en arithmétique. Les opérations
arithmétiques, comme l'addition ou la multiplication prennent deux valeurs
de type |number| pour créer un nouveau nombre. Voici ce que cela donne
en JavaScript :

>> 100 + 4 * 11

Les symboles _|+|_ et _|*|_ sont appelés des opérateurs. Le premier
correspond à l'addition et le second à la multiplication. Placer un
opérateur entre deux valeurs le fera s'appliquer @_applying_ à ces deux
valeurs et produire une nouvelle valeur.

L'exemple veut-il dire « ajouter 4 et 100 puis multiplier le résultat par
11 », ou la multiplication est-elle effectuée avant l'addition ? Comme
vous l'avez probablement deviné, la multiplication a lieu en premier. Mais
comme en mathématiques, cela peut être modifié en entourant l'addition
de parenthèses@_|()|_ :

>> (100 + 4) * 11

Pour la soustraction, il y a l'opérateur _|-|_, et la division peut être
effectuée avec _|/|_. Lorsque des opérateurs apparaissent ensemble sans
parenthèses, l'ordre dans lequel ils sont appliqués est déterminé par la
_priorité_ des opérateurs. Le premier exemple montre que la multiplication
a une priorité plus forte que l'addition. La division et la multiplication
viennent toujours avant la soustraction et l'addition. Lorsque plusieurs
opérateurs ayant la même priorité se suivent (|1 - 1 + 1|) ils sont
appliqués de gauche à droite.

Essayez de trouver la valeur que produit cette opération, puis exécutez-la
en console pour voir si vous aviez raison…

>> 115 * 4 - 4 + 88 / 2

Vous ne devriez pas avoir à vous inquiéter de ces règles de priorité. En
cas de doute, ajoutez simplement des parenthèses.

Il y a encore un opérateur arithmétique qui vous est sûrement moins
familier. Le symbole _|%|_ est utilisé pour représenter l'opération
_modulo_. |X| modulo |Y| est le reste de la division de |X| par |Y|. Par
exemple |314 % 100| vaut |14|, |10 % 3| vaut |1| et |144 % 12| vaut |0|. Modulo
a le même ordre de priorité que la multiplication et la division.

---

Le type de données suivant est la chaîne de caractères. Elle est nommée
« _string_ » en anglais et donc en JavaScript. Son utilisation n'est pas
aussi évidente à deviner d'après son nom que pour « number », mais
elle remplit également un rôle très basique. Les chaînes de caractères
sont utilisées pour représenter du texte, le nom est censé venir du fait
qu'il enchaîne un groupe de caractères ensemble. Les chaînes de caractères
sont écrites en insérant leur contenu entre des guillemets :

>> "Colmater mon bateau avec du chewing-gum."

On peut mettre pratiquement tout ce qu'on veut entre des guillemets et
le JavaScript fera la conversion en une valeur de type |string|. Mais pour
certains caractères c'est un peu tordu. Vous pouvez imaginer à quel point il
est délicat de mettre des guillemets entre guillemets. Les sauts de lignes
@_newline_, comme vous en faites en appuyant sur Entrée, ne peuvent pas
non plus être mis entre guillemets, la chaîne doit tenir sur une seule ligne.

Pour mettre de tels caractères dans une chaîne, on emploie l'astuce
suivante : à chaque fois qu'on trouve un antislash (« |\| ») dans
un texte entre guillemets, cela signifie que le caractère qui le suit
a une signification particulière. Un guillemet qui est précédé d'un
antislash n'achèvera pas la chaîne mais en fera partie. Quand le caractère
« |n| » se trouve derrière l'antislash, il est interprété comme un
saut de ligne. De même, un « |t| » derrière un antislash signifie
un caractère de tabulation##.

## Lorsque vous entrez des chaînes de caractères dans la console, vous
pouvez remarquer qu'elles reviennent avec des guillemets et des antislashs
de la même manière que vous les aviez saisies. Pour obtenir un affichage
convenable des caractères spéciaux, vous pouvez faire |print("a\nb")|
— nous verrons pourquoi cela fonctionne dans quelques instants.

>> "Voici une première ligne\nEt maintenant la seconde"

Il existe bien entendu des cas où vous voudrez que l'antislash dans une
chaîne soit juste un antislash et pas un caractère d'échappement. Si
deux antislashs se succèdent, ils vont se combiner et seul l'un d'eux sera
conservé dans la chaîne résultante :

>> "Un caractère de saut de ligne est écrit ainsi \"\\n\"."

---

Les chaînes ne peuvent être divisées, multipliées ou
soustraites. L'opérateur _|+|_ *peut* être utilisé avec des chaînes. Il
n'ajoute rien au sens mathématique mais concatène les chaînes, il les
colle ensemble.

>> "con" + "cat" + "é" + "ner"

Il existe bien d'autres outils pour manipuler des chaînes de caractères,
nous les exposerons par la suite.

---

Tous les opérateurs ne sont pas des symboles. Certains sont écrits sous
forme de mots. Par exemple l'opérateur _|typeof|_ qui renvoie une chaîne
de caractères spécifiant le type d'une valeur.

>> typeof 4.5

Les autres opérateurs que nous avons vus opèrent toujours sur deux valeurs,
|typeof| sur une seul. Les opérateurs qui utilisent deux valeurs sont appelés
des _opérateurs binaires_ alors que ceux qui n'en n'utilisent qu'une sont
des _opérateurs unaires_. Le @_|-|_signe moins peut être utilisé aussi
bien comme un opérateur binaire que comme un unaire :

>> - (10 - 2)

---

Il existe enfin des valeurs de type _booléen_. Il n'en existe que deux :
_|true|_ pour vrai et _|false|_ pour faux. Voici un moyen de produire une
valeur |true| :

>> 3 > 2

Et on peut produire |false| comme ceci :

>> 3 < 2

J'espère que vous connaissiez déjà les signes _|>|_ et _|<|_. Ils
signifient, respectivement, « plus grand que » et « plus petit
que ». Ce sont des opérateurs binaires et le résultat de leur application
est une valeur booléenne qui indique dans ce cas si l'expression est
vérifiée ou non.

On peut comparer des chaînes de la même façon :

>> "Aardvark" < "Zoroaster"

Le classement des chaînes suit plus ou moins l'ordre alphabétique. Plus
ou moins parce que… les lettres majuscules sont toujours « plus petites
que » les minuscules, donc |"Z" < "a"| (« Z » en majuscule, « a » en
minuscule) vaut |true| et les caractères non alphabétiques (« |!| »,
« |@| », etc.) sont également inclus dans ce classement. Le véritable
principe sur lequel repose la comparaison est le standard _Unicode_. Ce
dernier assigne un nombre à potentiellement tout caractère dont on peut
avoir besoin, y compris les caractères spéciaux de langues comme le grec,
l'arabe, le japonais, le tamoul, etc. Disposer de tels nombres est bien
pratique pour stocker des chaînes de caractères dans un ordinateur --
vous pouvez les représenter comme une série de nombres. En comparant les
chaînes, le JavaScript se contente de comparer les nombres associés aux
caractères dans la chaîne, de gauche à droite.

Voici d'autres opérateurs du même genre : _|>=|_ (« supérieur ou
égal à »), |<=|_ (« inférieur ou égal à »), _|==|_ (« égal
à »), et _|!=|_ (« n'est pas égal à »).

>> "Itchy" != "Scratchy"

>> 5e2 == 500

---

Il existe également des opérations très utiles qui peuvent être appliquées
aux valeurs booléennes elles-mêmes. JavaScript prend en charge trois
opérateurs logiques : *et*, *ou* et *non*, que l'on peut utiliser pour
des opérations logiques sur les booléens.

L'opérateur _|&&|_ représente le *et* logique. C'est un opérateur binaire
dont le résultat est |true| seulement si les deux valeurs qu'on lui donne
sont |true|.

>> true && false

_||||_ est le *ou* logique, qui vaut |true| si l'une ou l'autre des valeurs
qu'on lui attribue est |true| :

>> true || false

*Non* s'écrit avec un point d'exclamation : _|!|_, c'est un opérateur
unaire qui inverse la valeur qu'on lui attribue, |!true| devient |false|
et |!false| signifie |true|.

***

>> ((4 >= 6) || ("herbe" != "verte")) &&
>>   !(((12 * 2) == 144) && true)

Est-ce vrai (|true|) ? Pour une meilleure lisibilité, on peut se séparer
d'un grand nombre de parenthèses inutiles ici. Cette version, plus simple,
signifie la même chose :

>> (4 >= 6 || "herbe" != "verte") &&
>>   !(12 * 2 == 144 && true)

///

Oui, l'expression vaut bien |true|. Vous pouvez la décomposer étape par
étape comme ceci :

>> (false || true) && !(false && true)

>> true && !false

>> true

J'espère que vous avez remarqué que |"herbe" != "verte"| est |true|. L'herbe
est peut-être verte, mais elle n'est pas égale à "verte".

---

Il n'est pas toujours évident de savoir si des parenthères sont
nécessaires. En pratique, on peut généralement s'en sortir en sachant que
parmi tous les opérateurs rencontrés, |||| a la priorité la plus basse,
viennent ensuite, dans l'ordre, |&&| puis les opérateurs de comparaisons
(|>|, |==|, etc.) et enfin tout le reste. Ceci a été déterminé de telle
sorte que, dans les cas simples, on ne doive utiliser les parenthèses que
si elles sont strictement nécessaires.

---

Les exemples rencontrés jusqu'à présent utilisent le langage JavaScript
de la même façon que l'on se sert d'une calculatrice de poche. Utiliser des
valeurs et leur appliquer des opérateurs pour obtenir d'autres valeurs. Créer
de telles valeurs est une partie essentielle de chaque programme JavaScript,
mais ce n'en est qu'une partie. Un bout de code qui produit une valeur
s'appelle une _expression_. Chaque valeur écrite directement (telle que |22|
ou |"psychanalyse"|) est une expression. Une expression entre parenthèses
est également une expression. Un opérateur binaire appliqué à deux
expressions, ou un opérateur unaire appliqué à une seule expression est
également une expression.

Il existe quelques autres moyens de construire des expressions, qui seront
dévoilés lorsque le moment sera venu.

Il existe une unité plus grande que l'expression. On l'appelle
_instruction_. Un programme est une suite d'instructions. La plupart des
instructions se terminent par un _point-virgule_ (|;|). La forme la plus
simple d'une instruction est une expression avec un point-virgule après. Voici
un programme :

> 1;
> !false;

Ce programme est inutile. Une expression peut se contenter de produire une
valeur, mais une instruction ne vaudra quelque chose que si elle change un
peu le monde. Elle peut imprimer quelque chose à l'écran -- ce qui compte
comme un changement du monde -- ou elle peut modifier l'état interne du
programme de telle sorte que cela affecte les instructions qui suivent. Ces
modifications sont appelées « _effets de bord_ ». Les instructions de
l'exemple ci-dessus ne renvoient que les valeurs |1| et |true| puis les
jettent au récupérateur de bits##. Ceci ne laisse aucune trace dans ce
monde et ça n'a aucun effet de bord.

## Le récupérateur de bits est l'endroit où sont supposés être stockés
les vieux bits. Sur certains systèmes, les programmeurs doivent le vider
manuellement de temps en temps. Heureusement, JavaScript est fourni avec un
système automatique de recyclage des bits.

---

Comment un programme conserve-t-il un état interne ? Comment se rappelle-t-il
les choses ? Nous avons vu de quelle façon créer de nouvelles valeurs
à partir de vieilles valeurs, mais cela ne modifie pas les valeurs de
celles-ci, et la nouvelle valeur doit être utilisée immédiatement ou
elle disparaîtra. Pour « attraper » et conserver des valeurs, JavaScript
fournit un mécanisme appelé la _variable_.

> var caught = 5 * 5;

Une variable possède toujours un nom et elle peut pointer vers une valeur et
la conserver. L'instruction ci-dessus crée une variable appelée |caught|
et l'utilise pour conserver le nombre produit par la multiplication de |5|
par |5|.

Après avoir exécuté le programme ci-dessus, vous pouvez entrer le mot
|caught| dans la console et cela ressortira la valeur |25| à votre place. Le
nom d'une variable est utilisé pour récupérer sa valeur. |caught + 1|
fonctionne également. Un nom de variable peut être utilisé comme expression
et ainsi faire partie de plus grandes expressions.

Le mot-clé _|var|_ est utilisé pour créer des variables. Le nom de la
variable suit |var|. Les noms de variable peuvent être à peu près n'importe
quel mot, mais ils ne peuvent pas contenir d'espaces. Les chiffres peuvent
faire partie du nom de variable, |catch22| est un nom valide, mais le nom
ne doit pas commencer par un chiffre. Les caractères « |$| » et « |_|
» peuvent être utilisés dans les noms comme s'ils étaient des lettres,
ainsi |$_$| est un nom de variable correct.

Si vous souhaitez que la nouvelle variable contienne tout de suite une
valeur, comme c'est souvent le cas, vous pouvez utiliser l'opérateur _|=|_
pour lui affecter la valeur d'une expression.

Si une variable pointe vers une valeur, cela ne veut pas dire qu'elles sont
liées pour toujours. Vous pouvez utiliser l'opérateur |=| à tout moment
sur une variable existante pour lui enlever sa valeur actuelle et la faire
pointer sur une nouvelle valeur.

> caught = 4 * 4;

---

Il est préférable d'imaginer les variables comme des tentacules plutôt
que comme des boîtes. Elles ne *contiennent* pas de valeurs, elles
s'en *saisissent* (et deux variables peuvent se référer à la même
valeur). Seules les valeurs qui sont encore retenues par le programme lui
sont accessibles. Quand vous avez besoin de vous souvenir de quelque chose,
vous dressez un tentacule pour l'accrocher fermement ou enserrez une nouvelle
valeur dans un tentacule existant : pour vous souvenir de la somme en
dollars que Luigi vous doit encore, vous pouvez faire :

> var detteLuigi = 140;

Puis, à chaque fois que Luigi vous rembourse quelque chose, ce montant peut
être décrémenté en allouant un nouveau nombre à la variable :

> detteLuigi = detteLuigi - 35;

L'ensemble des variables et de leurs valeurs à un moment donné s'appelle
l'_environnement_. Quand le programme se lance, cet environnement n'est pas
vide. Il contient toujours un certain nombre de variables standards. Quand
votre navigateur charge une nouvelle page, il crée un nouvel environnement
et lui affecte les valeurs standards. Les variables créées et modifiées
par les programmes d'une page sont conservées jusqu'à ce que le navigateur
aille sur une nouvelle page.

---

Beaucoup de valeurs fournies par l'environnement standard sont de type
« _function_ ». Une fonction est une partie de programme contenue dans
une valeur.
Généralement, cette portion de programme fait quelque chose d'utile qui
peut être invoqué en utilisant le nom défini pour la fonction. Dans un
navigateur, la variable _|alert|_ est reliée à une fonction qui ouvre une
petite fenêtre avec un message. Elle s'utilise comme ceci :

> alert("De plus, vos cheveux sont en feu.");

@_|()|_Quand on exécute le code d'une fonction, on dit qu'on l'_invoque_ ou
qu'on l'_appelle_. La notation pour faire ça utilise des parenthèses. Chaque
expression qui produit une valeur peut être invoquée en utilisant des
parenthèses après son nom. La chaîne de caractères entre parenthèses est
donnée à la fonction qui l'utilise en tant que texte pour l'afficher dans la
fenêtre. Les valeurs données aux fonctions sont appelées _paramètre_s ou
_argument_s. |alert| en a juste besoin d'un, mais d'autres fonctions peuvent
en vouloir plus.

---

Afficher une fenêtre de dialogue est un effet de bord. Beaucoup de fonctions
sont utiles par leurs effets de bord. Une fonction peut aussi produire une
valeur et dans ce cas elle n'a pas besoin de produire un effet de bord pour
être utile. Par exemple, il existe une fonction _|Math.max|_, qui prend
deux arguments et retourne le plus grand des deux :

> alert(Math.max(2, 4));

@_|Math.min|_Quand une fonction produit une valeur, on dit qu'elle
la _retourne_. Parce qu'il n'y a que les expressions qui produisent des
valeurs, les appels de fonctions peuvent être utilisés comme une partie
d'une expression plus longue :

> alert(Math.min(2, 4) + 100);

Nous examinerons dans le \\cfunctions la façon de créer vos propres fonctions.

---

Comme l'a montré l'exemple précédent, |alert| peut être utile pour
montrer le résultat de certaines expressions. Mais cliquer pour fermer
toutes ces petites fenêtres peut devenir très vite énervant, donc à partir
de maintenant nous allons plutôt utiliser une fonction similaire appellée
_|print|_ qui ne fait pas apparaître de fenêtre, mais écrit juste une valeur
dans la zone de sortie de la console. |print| n'est pas une fonction standard
du JavaScript, les navigateurs ne la fournissent pas, mais il est possible
de l'utiliser dans ce livre, donc vous pouvez l'utiliser sur ces pages.

> print("N");

Une fonction similaire également disponible sur ces pages est |show|. Alors
que |print| affichera son argument en texte brut, _|show|_ essayera de
l'afficher de la même manière qu'un programme le ferait. Ce qui signifie
qu'il donnera plus d'information sur le type de la valeur. Par exemple,
les chaînes de caractères garderont leurs guillemets, en utilisant |show|:

> show("N");

L'environnement standard fourni par les navigateurs contient quelques fonctions
supplémentaires pour faire apparaître des fenêtres. Vous pouvez poser une
question à l'utilisateur en lui demandant de répondre par « Oui »
ou « Non », en utilisant la fonction prédéfinie _|confirm|_. Elle
retourne un booléen, |true| si l'utilisateur choisit « Oui » et |false|
si l'utilisateur choisit « Non ».

> show(confirm("Continuons-nous ?"));

_|prompt|_ peut être utilisé pour poser une question « ouverte ». Le
premier argument est la question, le deuxième est le texte par défaut,
proposé comme la réponse de l'utilisateur.
Une ligne de texte peut alors être tapée dans la case de texte de la
fenêtre et la fonction la retournera comme une chaîne de caractères.

> show(prompt("Dîtes-nous tout ce que vous savez.", "..."));

---

Dans l'environnement, il est possible de donner une nouvelle valeur à
presque toutes les variables. Ça peut être utile mais aussi dangereux. Si
vous donnez la valeur |8| à |print|, vous ne pourrez plus jamais rien
afficher. Heureusement, il y a un bouton « Réinitialiser » sur la
console, qui réinitialise totalement l'environnement.

---

Des programmes d'une ligne ne sont pas très intéressant. Quand vous mettez
plus d'une instruction dans un programme ces dernières sont, comme on peut
s'en douter, exécutées une à la fois de haut en bas.

> var leNombre = Number(prompt("Choissisez un nombre", ""));
> print("Votre nombre est la racine carrée de " +
>       (leNombre * leNombre));

La fonction _|Number|_ converti une valeur en un nombre, ce qui est
nécessaire dans notre cas parce que le résultat de |prompt| est une chaîne
de caractères. Il existe des fonctions similaires appelées _|String|_
et _|Boolean|_ qui convertissent des valeurs dans ces types.

---

Considérons un programme qui affiche tous les nombres pairs de 0 à 12. Une
façon de le faire est d'écrire :

> print(0);
> print(2);
> print(4);
> print(6);
> print(8);
> print(10);
> print(12);

Ça marche mais lorsqu'on écrit un programme l'idée est de nous faire faire
*moins* de travail et non pas plus. Si nous avions besoin des nombres pairs
jusqu'à 100 cette méthode deviendrait tout simplement inexploitable. Nous
avons besoin d'une manière de répéter une portion de code automatiquement.

> var nombreCourant = 0;
> while (nombreCourant <= 12) {
>   print(nombreCourant);
>   nombreCourant = nombreCourant + 2;
> }

Vous avez sûrement vu dans l'introduction le mot _|while|_. Une instruction
démarrant par |while| crée une _boucle_. Une boucle est une perturbation
dans la séquence des instructions, il fera répéter plusieurs fois
au programme une séquence de code. Dans notre cas le mot |while| est
suivi par une expression entre parenthèse (les parenthèses étant
obligatoires) qui détermine si la boucle continue à s'exécuter ou si
elle doit s'arrêter. Aussi longtemps que la valeur booléenne produite
par cette exression est |true|, le code à l'intérieur de la boucle est
répété. Dès qu'elle devient |false| le programme se place à la fin de
la boucle et reprend à la normale.

La variable |nombreCourant| montre la façon dont une variable peut suivre
la progression d'un programme. À chaque fois que la boucle est répétée
la variable est incrémentée de |2| et à chaque début elle est comparée
au nombre |12| pour décider si la boucle continue ou non.

La troisième partie d'une instruction |while| est une autre instruction. C'est
le _corps_ de la boucle qui contient les actions qui doivent se reproduire
plusieurs fois. Si nous ne devions pas afficher les nombres le programme
aurait pu être :

> var nombreCourant = 0;
> while (nombreCourant <= 12)
>   nombreCourant = nombreCourant + 2;

Ici |nombreCourant = nombreCourant + 2;| est l'instruction qui forme le corps
de la boucle. Mais nous devons aussi afficher le nombre, donc la boucle sera
consituée d'une instruction supplémentaire.
Les@_|{}|_accolades (|{| et |}|) sont utilisées pour grouper des instructions
dans des _bloc_s. Pour le reste du code un bloc compte comme une seule et
même instruction. Dans l'exemple précédant ceci est utilisé pour inclure
dans la boucle à la fois l'appel à la fonction |print| et l'instruction
qui actualise la variable |nombreCourant|.

*** power2

Utilisez cette technique pour écrire un programme qui calcule et affiche la
valeur de 2^10 (2 à la puissance 10). Vous n'êtes bien sûr pas autorisé
à tricher en écrivant juste |2 * 2 * ...|.

Si vous avez des problèmes avec ça, essayez de comparer avec l'exemple
des nombres pairs. Le programme doit exécuter une action un certain nombre
de fois. Pour cela, on peut utiliser une variable compteur avec une boucle
|while|. À la place d'afficher le compteur, le programme doit multiplier
quelque chose par deux. Ce quelque chose doit être une variable dans laquelle
le résultat sera construit.

Ne vous inquiétez pas si vous ne voyez pas tout de suite comment cela peut
fonctionner. Même si vous comprenez parfaitement tous les concepts de ce
chapitre, il peut être dur de les appliquer à des problèmes concrets. Lire
et écrire du code vous aidera à développer votre sensibilité pour
ça. Donc, étudiez la solution, et essayez le prochain exercice.

///

> var resultat = 1;
> var compteur = 0;
> while (compteur < 10) {
>   resultat = resultat * 2;
>   compteur = compteur + 1;
> }
> show(resultat);

Le compteur peut aussi commencer à |1| et être vérifié pour |<= 10|,
mais pour des raisons que nous vous exposeront après il est préférable
de commencer à compter depuis 0.

Évidemment vos solutions n'ont pas à être exactement identiques aux
miennes. Elles doivent fonctionner. Et dans le cas où elles seraient très
différentes, assurez-vous d'avoir compris la mienne.

***

Avec quelques petites modifications, la solution à l'exercice précédent
peut être utilisée pour tracer un triangle. Et quand je dis « tracer
un triangle », je veux dire « afficher du texte qui ressemble presque
à un triangle quand on louche ».

Affichez dix lignes. Sur la première, mettez un « # ». Sur la deuxième
en mettez-en deux, et ainsi de suite.

Comment avoir une chaîne composée de X « # » ? Une solution est de
la construire avec une « boucle imbriquée », c'est à dire une boucle
dans une bloucle. Une méthode plus simple est de réutiliser la chaîne de
la précédente itération, et d'y ajouter un caractère.

///

> var ligne = "";
> var compteur = 0;
> while (compteur < 10) {
>   ligne = ligne + "#";
>   print(ligne);
>   compteur = compteur + 1;
> }

---

Vous remarquerez les espaces que j'ai mis devant certaines instructions. Ils
ne sont pas nécessaires : l'ordinateur accepte très bien un programme
sans ces espaces. En fait, même les retours à la ligne sont facultatifs.

Vous pouvez les écrire sur une seule longue ligne si cela vous fait
plaisir. Le rôle de l'_indentation_ dans les blocs est de construire la
structure du code de manière plus claire et lisible pour les humains. Parce
qu'on peut créer un nouveau bloc dans un autre et il peut alors devenir
difficile de voir où un bloc finit et où un autre commence dans des parties
complexes de code. Quand les lignes sont indentées, la forme visuelle du
code correspond à la forme des blocs. Je préfère utiliser deux espaces
pour chaque nouveau bloc, mais les goûts varient.

Le champ dans la console où vous pouvez taper des programmes ajoutera
automatiquement ces espaces. Ça peut sembler pénible au début, mais
quand vous écrirez beaucoup de code, vous verrez que c'est un gain de
temps important. Appuyer sur la touche « tab » réindentra la ligne
sur laquelle est le curseur.

Dans quelques cas, le JavaScript vous autorise à omettre le point-virgule en
fin d'instruction. Dans d'autres cas, il faut le mettre sans quoi des choses
étranges se produiront. Les règles définissant quand on peut les oublier
sont complexes et particulières. Dans ce livre, je ne les enlèverai jamais
et je vous conseille vivement de faire pareil pour vos propres programmes.

---

L'utilisation de |while| que nous avons vu plus haut suit toujours le même
modèle. Premièrement une variable « compteur » est créée. Elle
tracera la progression dans la boucle. L'instruction |while| contient
une vérification, généralement pour voir si le compteur a atteint sa
limite. Ensuite, à la fin du corps de la boucle, le compteur est mis à jour.

Beaucoup de boucles obéissent à ce schéma. C'est pour cette raison que
le JavaScript, comme d'autres langages, fournit une forme plus courte et
plus compréhensive :

> for (var nombre = 0; nombre <= 12; nombre = nombre + 2)
>   show(nombre);

Ce code est strictement équivalent à l'exemple précédent qui affichait les
nombres pairs. La seule différence est que toutes les instructions liées
à l'état de la boucle sont maintenant sur une seule ligne. La parenthèse
après le _|for|_ doit contenir deux points-virgules. La première partie
*initialise* la boucle, généralement en définissant une variable. La
deuxième est l'instruction qui *vérifie* l'état de la boucle. Et la
dernière partie *modifie* l'état de la boucle. Dans beaucoup de cas,
cette forme est plus claire et concise qu'une construction avec |while|.

---

J'ai utilisé une _casse_ plutôt bizarre dans certains noms de
variables. Comme vous ne pouvez pas utiliser d'espace dans ces noms —
l'ordinateur les lirait comme deux variables distinctes — vos choix pour
un nom composé de plusieurs mots sont plus ou moins limités aux solutions
suivantes : |petitpandaroux|, |petit_panda_roux|, |PetitPandaRoux|
ou |petitPandaRoux|. Le premier est difficile à lire. Personnellement,
j'aime celui avec les tirets bas, bien que ce soit un peu pénible à
taper. Toutefois, les fonctions JavaScript standards, et la plupart des
programmeurs JavaScript, suivent la dernière syntaxe. Il n'est pas compliqué
de s'habituer à ce genre de petites choses, alors je vais simplement suivre
la majorité et mettre une majuscule à la première lettre de chaque mot
excepté le premier.

Dans quelques cas, comme dans la fonction |Number|, la première lettre d'une
variable est également en majuscule. Cela a été défini pour marquer cette
fonction comme étant un constructeur. Ce qu'est un constructeur deviendra
clair dans le \\coo. Pour l'instant, l'important est de ne pas se soucier
de cet apparent manque de cohérence.

Notez que les noms ayant une signification spéciale tels que |var|, |while|
et |for| ne peuvent pas être utilisés en tant que noms de variables. Ils
sont appelés _mots-clés_. Il y a également un certain nombre de @_mot
réservé_mots qui sont « réservés pour l'utilisation » dans de futures
versions de JavaScript. Ceux-ci ne sont également officiellement pas
autorisés à être utilisés comme noms de variables, bien que certains
navigateurs les autorisent. La liste complète est assez longue :

] abstract boolean break byte case catch char class const continue
] debugger default delete do double else enum export extends false
] final finally float for function goto if implements import in
] instanceof int interface long native new null package private
] protected public return short static super switch synchronized
] this throw throws transient true try typeof var void volatile
] while with

Ne vous souciez pas de les mémoriser pour le moment, mais souvenez-vous
qu'ils peuvent être la cause d'un problème lorsque quelque chose ne
fonctionne pas comme prévu. D'après mon expérience, |char| (pour stocker
une chaîne d'un seul caractère) et _|class|_ sont les noms d'utilisation
incorrecte les plus communs.

***

Réécrivez les solutions des deux exercices précédents en utilisant |for|
à la place de |while|.

///

> var resultat = 1;
> for (var compteur = 0; compteur < 10; compteur = compteur + 1)
>   resultat = resultat * 2;
> show(compteur);

Notez que même s'il n'y a pas de bloc ouvert avec une « |{| », l'instruction
dans la boucle est toujours indentée avec deux espaces pour bien spécifier
son « appartenance » à la ligne du dessus.

> var ligne = "";
> for (var compteur = 0; compteur < 10; compteur = compteur + 1) {
>   ligne = ligne + "#";
>   print(ligne);
> }

---

@_|+=|_@_|-=|_@_|/=|_@_|*=|_Un programme a souvent besoin « d'actualiser »
une variable avec une valeur basée sur sa valeur précédente. Par exemple
|compteur = compteur + 1|. JavaScript fournit un raccourci pour cela :
|compteur += 1|. Ça fonctionne également pour beaucoup d'autres opérateurs,
par exemple |resultat *= 2| pour doubler la valeur de |resultat|, ou |compteur
-= 1| pour compter à rebours.

@_|++|_@_|--|_Pour |compteur += 1| et |compteur -= 1|, il existe même des
versions abrégées : |compteur++| et |compteur--|.

---

On dit que les boucles affectent le _flux d'exécution_ d'un programme. Elles
changent l'ordre dans lequel les instructions sont exécutées. Dans de
nombreux cas, un autre type de flux est utile : les instructions de sauts.

Nous voulons afficher tous les nombres en dessous de 20 qui sont divisibles
à la fois par 3 et par 4.

> for (var compteur = 0; compteur < 20; compteur++) {
>   if (compteur % 3 == 0 && compteur % 4 == 0)
>     show(compteur);
> }

Le mot-clé _|if|_ n'est pas très différent du mot-clé |while| :
il vérifie la condition qu'on lui donne (entre parenthèses) et exécute
l'instruction suivante en fonction de cette condition. Mais il ne fait cela
qu'une seule fois, donc l'instruction est exécutée zéro ou une fois.

L'astuce avec l'opérateur modulo (_|%|_) est une manière simple de tester
si un nombre est divisible par un autre nombre. S'il l'est, le reste de leur
division, qui est ce que modulo produit, est zéro.

Si nous avions voulu afficher tous les nombres en dessous de 20, mais en
affichant entre parenthèses ceux n'étant pas divisibles par 4, nous aurions
pu le faire de cette façon :

> for (var compteur = 0; compteur < 20; compteur++) {
>   if (compteur % 4 == 0)
>     print(compteur);
>   if (compteur % 4 != 0)
>     print("(" + compteur + ")");
> }

Mais maintenant le programme doit déterminer si |compteur| est divisible par
|4| deux fois. Le même effet peut être obtenu en ajoutant une partie |else|
(« sinon ») après l'instruction |if|. L'instruction _|else|_ est exécutée
seulement lorsque la condition |if| est fausse.

> for (var compteur = 0; compteur < 20; compteur++) {
>   if (compteur % 4 == 0)
>     print(compteur);
>   else
>     print("(" + compteur + ")");
> }

Pour aller plus loin avec cet exemple trivial, nous voulons maintenant
afficher ces mêmes nombres tout en leur ajoutant deux étoiles lorsqu'ils
sont plus grands que 15, une étoile lorsqu'ils sont plus grands que 10
(mais pas plus grands que 15), et aucune étoile dans les autres cas.

> for (var compteur = 0; compteur < 20; compteur++) {
>   if (compteur > 15)
>     print(compteur + "**");
>   else if (compteur > 10)
>     print(compteur + "*");
>   else
>     print(compteur);
> }

Cela montre que vous pouvez enchaîner des instructions |if|. Dans ce cas,
le programme regarde d'abord si |compteur| est plus grand que |15|. Si
c'est le cas, les deux étoiles sont affichées et les autres tests sont
ignorés. Si ce n'est pas le cas, on continue à vérifier si la valeur
est supérieure à |10|. Et on n'arrive à la dernière instruction |print|
que si |compteur| n'est pas supérieur à |10|.

***

Écrivez un programme qui vous demandera, en utilisant |prompt|, quelle
est la valeur de 2 + 2. Si la réponse est « 4 », utilisez |alert| pour
afficher un message sympa. Si c'est « 3 » ou « 5 », affichez « Ça y
était presque ! ». Dans les autres cas, n'hésitez pas à dire quelque
chose de méchant.

///

> var reponse = prompt("Hé vous ! Quelle est la valeur de 2 + 2 ?", "");
> if (reponse == "4")
>   alert("Vous êtes un vrai génie !");
> else if (reponse == "3" || reponse == "5")
>   alert("Ça y était presque !");
> else
>   alert("Vous êtes nul !");

---

Lorsqu'une boucle n'a pas systématiquement besoin d'aller jusqu'au bout
de ses instructions, le mot-clé _|break|_ peut être utile. Il permet de
sortir de la boucle et d'exécuter les instructions suivantes. Ce programme
trouve le premier nombre supérieur à 20 et divisible par 7 :

> for (var courant = 20; ; courant++) {
>   if (courant % 7 == 0)
>     break;
> }
> print(courant);

La structure |for| n'a pas de mécanisme qui vérifie quand terminer la
boucle. Cela signifie qu'elle est dépendante de l'instruction |break| qui
est à l'intérieur pour pouvoir s'arrêter. Le même programme aurait pu
s'écrire aussi simplement…

> for (var current = 20; current % 7 != 0; current++)
>   ;
> print(current);

Dans ce cas, le corps de la boucle est vide. Un point-virgule isolé peut
être utilisé pour produire une instruction vide. Ici, le seul effet de la
boucle est d'incrémenter la variable |courant| à la valeur voulue. Mais
j'avais besoin d'un exemple utilisant |break|, donc prêtez également
attention à la première version.

***

Ajoutez un |while|, et optionnellement un |break|, à votre solution du
précédent exercice, afin qu'il continue à répéter la question jusqu'à
ce qu'une réponse correcte soit donnée.

Notez que |while (true) …| peut être utilisé pour créer une boucle qui
ne s'arrêtera pas d'elle-même. C'est un peu ridicule, vous demandez au
programme de boucler tant que |true| est |true|, mais c'est une astuce utile.

///

> var reponse;
> while (true) {
>   reponse = prompt("Hé vous ! Quelle est la valeur de 2 + 2 ?", "");
>   if (reponse == "4") {
>     alert("Vous êtes un vrai génie !");
>     break;
>   }
>   else if (reponse == "3" || reponse == "5") {
>     alert("Ça y était presque !");
>   }
>   else {
>     alert("Vous êtes nul !");
>   }
> }

Parce que le corps du premier |if| a deux instructions, j'ai ajouté des
accolades autour de tous les corps de |if|. C'est une question de goût. Avoir
une chaîne |if|/|else| où certains corps sont des blocs et d'autres des
instructions simples me semble un peu bancal. Mais je vous laisse vous faire
votre propre opinion à ce propos.

Une autre solution, probablement meilleure mais sans |break|, est la suivante :

> var valeur = null;
> while (valeur != "4") {
>   valeur = prompt("Hé vous ! Quelle est la valeur de 2 + 2 ?", "");
>   if (valeur == "4")
>     alert("Vous êtes un vrai génie !");
>   else if (valeur == "3" || valeur == "5")
>     alert("Ça y était presque !");
>   else
>     alert("Vous êtes nul !");
> }

---

Dans la solution de l'exercice précédent il y a une instruction |var
answer;|. Elle crée une variable appelée |answer|, mais ne lui donne pas de
valeur. Que se passe-t'il alors lorsqu'on prend la valeur de cette variable ?

> var variableMystere;
> show(variableMystere);

En termes de tentacules, cette variable se termine dans les airs, elle ne
s'accroche à rien. Quand vous demandez la valeur d'une variable vide, vous
obtenez une réponse spéciale appelée _|undefined|_. Les fonctions qui ne
retournent pas de valeur convenable, comme |print| et |alert|, retournent
la valeur |undefined|.

> show(alert("Je suis un effet de bord."));

Il y a aussi une valeur similaire, _|null|_, qui signifie que « cette
variable est définie mais qu'elle n'a pas de valeur ». La différence entre
|undefined| et |null| est principalement académique, et la majeure partie du
temps sans intérêt. Dans la pratique, il est souvent nécessaire de vérifier
si quelque chose possède une valeur. Dans ce cas, l'expression |quelqueChose
== undefined| peut être utilisée, parce que même si ces deux valeurs ne
sont pas strictement équivalentes, |null == undefined| retournera |true|.

---

Ceci nous amène vers un autre sujet un peu plus délicat…

> show(false == 0);
> show("" == 0);
> show("5" == 5);

@_conversion de type_Toutes ces expressions retournent |true|. Quand on
compare des valeurs de différents types, JavaScript utilise un ensemble de
règles complexes et déroutantes. Je ne vais pas essayer de les expliquer
précisément. Dans beaucoup de cas, il essayera juste de convertir une
des variables dans le type de l'autre variable. Cependant, quand |null| ou
|undefined| apparaît, il produira |true| seulement si les deux sont |null|
ou |undefined|.

Que faire si vous voulez tester si une variable se réfère à la valeur
|false| ? La règle pour convertir des chaînes et des nombres en valeurs
booléennes est que |0| et la chaîne vide sont considérés comme |false|,
alors que toutes les autres valeurs comptent pour |true|. À cause de ça,
l'expression |variable == false| est également |true| quand |variable|
se réfère à |0| ou à |""|. Pour des cas comme celui-ci, où vous ne
voulez *aucune* conversion automatique de types, il existe deux nouveaux
opérateurs : _|===|_ et _|!==|_. Le premier teste si une valeur est
précisément égale à l'autre. Le deuxième teste s'ils ne sont pas
précisément égaux.

> show(null === undefined);
> show(false === 0);
> show("" === 0);
> show("5" === 5);

Toutes ces instructions retournent |false|.

---

Les valeurs données comme conditions dans les instructions |if|, |while|, ou
|for| ne doivent pas forcément être booléennes. Elles seront automatiquement
converties en booléen avant d'être vérifiées. Cela signifie que le
nombre |0|, la chaîne vide |""|, |null|, |undefined|, et bien sûr |false|,
compteront comme faux.

Le fait que toutes les autres valeurs soient converties en |true| permet
dans beaucoup de situations d'omettre les comparaisons explicites. Si on
sait qu'une variable contient une chaîne de caractères ou |null|, elle
peut être utilisée pour une vérification de façon très simple…

> var maybeNull = null;
> // …code mystérieux qui pourrait affecter une chaîne à maybeNull…
> if (maybeNull)
>   print("maybeNull possède une valeur");

Notons l'exception où le code mystérieux affecterait la valeur |""| à
|maybeNull|. Une chaîne vide est fausse, donc rien ne sera affiché. Cette
méthode peut donc être *mauvaise*, en fonction de ce que vous voulez
faire. C'est donc souvent une bonne idée d'ajouter |=== null| ou |=== false|
dans des cas comme celui-ci, pour éviter des erreurs subtiles. Ce commentaire
s'applique aussi aux valeurs numériques qui peuvent être égales à |0|.

---

La ligne qui parle du « code mystérieux » dans l'exemple précédent
peut vous sembler un peu étrange. C'est souvent utile pour inclure du texte
supplémentaire dans un programme. On l'utilise le plus souvent pour ajouter
à un programme des explications en langage humain.

> // La variable compteur, qui va être définie, commencera
> // par la valeur 0, c'est-à-dire par zéro.
> var compteur = 0;
> // Maintenant, nous allons créer une boucle.
> while (compteur < 100 /* compteur est inférieur à 100 */)
> /* À chaque fois que l'on boucle, nous incrémentons la valeur du compteur,
>    Vraiment, on ajoute juste un. */
>   compteur++;
> // Puis c'est fini.

Ce type de texte est appelé un _commentaire_. Les règles sont les
suivantes : '|/*|' commence un commentaire qui se termine au prochain
'|*/|'. '|//|' débute un autre type de commentaire qui finit à la fin de
la ligne.

Comme vous pouvez le voir, même les programmes les plus simples peuvent
être faits pour avoir l'air gros, laid et compliqué, simplement en ajoutant
beacuoup de commentaires.

---

Il existe d'autres situations qui provoquent automatiquement une _conversion
de type_. Si vous ajoutez une valeur non chaîne à une chaîne, cette valeur
est automatiquement convertie en chaîne avant d'être concaténée. Si vous
multipliez un nombre et une chaîne, JavaScript essaie de créer un nombre
avec la chaîne.

> show("Apollo" + 5);
> show(null + "ifier");
> show("5" * 5);
> show("fraises" * 5);

La dernière instruction donne pour résultat _|NaN|_, qui est une valeur
particulière. Elle signifie « Pas un nombre » (« Not a Number »)
et elle est de type nombre (ce qui peut sembler légèrement paradoxal). Dans
ce cas, cela signifie  qu'une fraise n'est pas un nombre. Toutes les
opérations arithmétiques sur la valeur |NaN| ont pour résultat |NaN|,
c'est pourquoi en le multipliant par |5| comme dans cet exemple, cela donne
toujours |NaN|. De plus, et c'est parfois assez perturbant, |NaN == NaN|
est égal à |false|, vérifier si une valeur est |NaN| peut être fait
avec la fonction _|isNaN|_. |NaN| est encore (c'est la dernière) une de
ces valeurs qui renvoie |false| quand elle est convertie en booléen.

Ces conversions automatiques peuvent être très pratiques, mais elles sont
aussi plutôt bizarres et sujettes à erreur. Même si |+| et |*| sont tous
deux des opérateurs arithmétiques, ils se comportent de façon complètement
différente dans cet exemple. Dans mon propre code, j'utilise beaucoup |+|
pour combiner les chaînes et les non chaînes, mais notez bien qu'il ne
faut pas utiliser |*| ni les autres opérateurs numériques sur des valeurs
de chaînes. Convertir un nombre en chaîne est toujours possible et simple,
mais convertir une chaîne en nombre peut très bien ne pas marcher du tout
(voir la dernière ligne de l'exemple). Mais nous pouvons utiliser |Number|
pour convertir explicitement la chaîne en nombre, en montrant bien que nous
prenons le risque de nous retrouver devant une valeur |NaN|.

> show(Number("5") * 5);

---

Quand nous parlions des opérateurs booléens |&&| et ||||, je vous avais
dit qu'ils produisent des valeurs booléennes. C'est en fait un peu trop
simplifié. Si vous les appliquez sur des valeurs booléennes, ils retournent
des booléens. Mais ils peuvent aussi s'appliquer à d'autres types de valeurs,
et dans ces cas ils retournent un de leurs arguments.

En fait, ce que _||||_ fait réellement est ceci : il regarde la valeur de
gauche en premier. Si la conversion en booléen produit |true|, il retourne
cette valeur, sinon il retourne le membre de droite. Vérifiez par vous-même
que cela fonctionne correctement avec des arguments booléens. Pourquoi agit-il
comme cela ? Cela s'avère très pratique. Considérons l'exemple suivant :

> var input = prompt("Quel est votre nom ?", "Kilgore Trout");
> print("Bien le bonjour " + (input || "cher ami"));

Si l'utilisateur presse « Annuler » ou ferme la fenêtre de dialogue sans
donner de nom, la variable |input| prendra la valeur |null| ou |""|. Ces deux
donneront |false| en essayant de convertir en booléen. L'expression |input ||
"cher ami"| peut être lue dans ce cas commme « la valeur de la variable
|input|, sinon la chaîne |"cher ami"| ». C'est une manière simple de
fournir une valeur de secours.

L'opérateur _|&&|_ fonctionne sur le même principe mais dans l'autre
sens. Quand la valeur à sa gauche est quelque chose qui donnera |false| en
étant converti en booléen, il retournera cette valeur. Dans l'autre cas,
il retournera la valeur à sa droite.

Une autre propriété de ces deux opérateurs est que l'expression de
droite n'est évaluée que quand c'est nécessaire. Dans le cas |true ||X|,
peu immporte ce qu'est |X|, le résultat sera toujours |true|, donc |X|
n'est jamais évalué, et s'il a des effets de bord, ils ne se produiront
jamais. C'est la même chose pour |false && X|.

> false || alert("Je suis en train de me produire !");
> true || alert("Pas moi.");

=====================
Fonctions / functions
=====================

Un programme doit souvent exécuter la même tâche en différents
endroits. Il est fastidieux de répéter à chaque fois les instructions
nécessaires et c'est un facteur d'erreurs possibles. Il vaudrait mieux
réunir ces instructions au même endroit et demander au programme d'y
faire un détour chaque fois que c'est nécessaire. C'est pour ça qu'on a
inventé les _fonction_s : ce sont des unités de code que le programme
peut parcourir à volonté. Afficher une chaîne à l'écran nécessite un
certain nombre de déclarations, mais si nous disposons d'une fonction |print|
il nous suffit d'écrire |print("Aleph")| et le tour est joué.

Cependant, si on voit les fonctions simplement comme des boîtes de conserve
de code on ne les considére pas à leur juste valeur. Si nécessaire, elles
peuvent jouer les rôles de fonctions pures, d'algorithmes, de détours,
d'abstractions, de moyens de décision, de modules, de prolongements, de
structures de données et de beaucoup d'autres. Être capable d'utiliser
efficacement des fonctions est une compétence nécessaire pour qui veut
programmer sérieusement. Ce chapitre propose une introduction au sujet,
le \\cfp aborde plus en profondeur les subtilités des fonctions.

---

@_fonction pure_Pour commencer, les fonctions pures sont ce que l'on appelait
« fonction » en cours de mathématiques, que vous avez, je l'espère,
suivi à un moment de votre vie. Prendre le cosinus ou la valeur absolue
d'un nombre est une fonction pure à un argument. L'addition est une fonction
pure à deux arguments.

Les propriétés qui définissent les fonctions pures sont qu'elles retournent
toujours la même valeur pour les mêmes arguments et n'ont jamais d'effet
de bord. Elles prennent des arguments, retournent une valeur basée sur ces
arguments, et ne perdent pas leur temps à faire autre chose.

En JavaScript, l'addition est un opérateur, mais elle peut être encapsulée
dans une fonction comme ceci (et aussi inutile que cela puisse sembler,
nous allons rencontrer des situations dans lesquelles ça sera vraiment utile).

> function ajouter(a, b) {
>   return a + b;
> }
>
> show(ajouter(2, 2));

|ajouter| est le nom de la fonction. |a| et |b| sont les noms des deux
arguments.

Le mot-clé _|function|_ est toujours utilisé lorsque l'on crée
une fonction. Lorsqu'il est suivi d'un nom de variable, la fonction
créée sera stockée sous ce nom. À la suite du nom, vient une liste
de noms d'_argument_s, et enfin, après celle-ci le _corps_ de la
fonction. Contrairement à ceux autour du corps d'une boucle |while| ou
d'une instruction |if|, les accolades autours du corps d'une fonction sont
obligatoires##.

## Techniquement, cela ne devrait pas être nécessaire, mais je suppose que
les concepteurs de JavaScript se sont dit que cela clarifierait les choses
si le corps des fonctions était toujours entouré d'accolades.

Le mot-clé _|return|_, suivi d'une expression, est utilisé pour déterminer
la valeur qu'une fonction renvoie. Lorsque l’exécution arrive sur une
instruction |return|, elle saute immédiatement hors de la fonction courante
et transmet la valeur retournée au code qui a appelé la fonction. Une
instruction |return| sans expression à la suite fait renvoyer |undefined|
à la fonction.

Un corps peut évidemment avoir plus d'une instruction en son sein. Voici une
fonction pour calculer des puissances (avec des exposants entiers positifs) :

> function puissance(base, exposant) {
>   var resultat = 1;
>   for (var compteur = 0; compteur < exposant; compteur++)
>     resultat *= base;
>   return resultat;
> }
>
> show(puissance(2, 10));

Si vous avez résolu l'\\epower2, cette technique utilisée pour calculer
une puissance devrait vous sembler familière.

Créer une variable (|resultat|) et la mettre à jour sont des effets de
bord. Est-ce que je ne viens pas de dire que les fonctions pures n'ont pas
d'effets de bord ?

Une variable créée à l'intérieur d'une fonction existe uniquement
à l'intérieur de celle-ci. Heureusement, sinon le programmeur devrait
trouver un nom différent pour chaque variable dont il a besoin dans un
programme. Comme |resultat| existe uniquement à l'intérieur de |puissance|,
le changement ne dure que jusqu'à ce que la fonction retourne quelque chose,
et du point de vue du code qui l'appelle, il n'y a pas d'effet de bord.

***

Écrivez une fonction appelée |absolu| qui retourne la valeur absolue du
nombre qui lui est donné en argument. La valeur absolue d'un nombre négatif
est la version positive du même nombre, et la valeur absolue d'un nombre
positif (ou zero) est le nombre lui-même.

///

> function absolu(nombre) {
>   if (nombre < 0)
>     return -nombre;
>   else
>     return nombre;
> }
>
> show(absolu(-144));

---

Les fonctions pures ont deux propriétés très sympathiques. Il est facile
de s'en souvenir et de les réutiliser.

Si une fonction est pure, un appel à celle-ci peut être considéré
comme une chose indépendante. Si vous n'êtes pas sûr qu'elle fonctionne
correctement, vous pouvez la tester en l'appelant directement depuis la
console, ce qui est facile car elle ne dépend d'aucun contexte##. Il est
facile de faire ces tests automatiquement -- d'écrire un programme qui
teste une fonction spécifique. Les fonctions non-pures peuvent renvoyer
différentes valeurs basées sur toutes sortes de facteurs, et avoir des
effets de bord qui pourraient être difficiles à tester et à prévoir.

## Techniquement, une fonction pure ne peut utiliser la valeur d'aucune
variable externe. Ces valeurs pourraient changer et cela pourrait faire
renvoyer une valeur différente pour les mêmes arguments. En pratique, le
programmeur peut considérer certaines variables comme « constantes »
-- elles ne sont pas censées changer -- et considérer les fonctions qui
utilisent uniquement des variables constantes comme des fonctions pures. Les
variables qui contiennent une fonction sont souvent de bons exemples de
variables constantes.

Comme les fonctions pures sont auto-suffisantes, elles ont tendance à
être utiles et pertinentes dans un plus grand nombre de situations que
les non-pures.
Prenez |show|, par exemple. L'utilité de cette fonction dépend de la
présence d'un espace spécial à l'écran pour afficher sa sortie. Si cet
espace n'existe pas, la fonction est inutile. Nous pouvons imaginer une
fonction analogue, appelons-la |format|, qui prend une valeur en argument
et renvoie une chaîne de caractères représentant cette valeur. Cette
fonction est utile dans plus de situations que |show|.

Bien sûr, |format| ne résout pas le même problème que |show|, et aucune
fonction pure ne sera capable de résoudre ce problème, parce que cela
nécessite des effets de bord. Dans beaucoup de cas, les fonctions non-pures
sont exactement ce dont vous avez besoin. Dans d'autres cas, un problème
peut être résolu avec une fonction pure, mais la variante non-pure est
beaucoup plus adaptée ou efficace.

Par conséquent, lorsque quelque chose peut facilement être exprimé par une
fonction pure, écrivez-le ainsi. Mais ne vous sentez pas coupable d'avoir
écrit des fonctions non-pures.

---

Les fonctions avec effets de bord ne contiennent pas obligatoirement une
instruction |return|.
Si aucune instruction |return| n'est trouvée, la fonction renvoie |undefined|

> function crier(message) {
>   alert(message + " !!");
> }
>
> crier("Yow");

---

Les noms des arguments d'une fonction sont disponibles comme variables au sein
de celle-ci. Ils feront référence aux valeurs des arguments avec lesquels est
appelée la fonction, et comme les variables normales créées à l'intérieur
d'une fonction, ils n'existent pas à l’extérieur de celle-ci. En plus
de l’_environnement global_, il y a aussi de plus petits @_environnement
local_environnements locaux créés par des appels de fonctions. Lorsque l'on
cherche une variable à l'intérieur d'une fonction, l'environnement local
est contrôlé en premier, et ensuite, seulement si la variable n'existe pas
là, on la cherche dans l'environnement global. Cela permet à une variable
à l'intérieur d'une fonction de _masquer_ une variable globale du même nom.

> function alertEstPrint(value) {
>   var alert = print;
>   alert(value);
> }
>
> alertIsPrint("Troglodytes");

Les variables dans cet environnement local sont visibles seulement pour le
code à l'intérieur de la fonction. Si cette fonction appelle une autre
fonction, la fonction nouvellement créée ne voit pas les variables à
l'intérieur de la première fonction.

> var variable = "globale";
>
> function afficherVariable() {
>   print("à l'intérieur de afficherVariable, la variable contient '" +
>         variable + "'.");
> }
>
> function test() {
>   var variable = "locale";
>   print("à l'intérieur de test, la variable contient '" + variable + "'.");
>   afficherVariable();
> }
>
> test();

Cependant, et c'est un phénomène subtil mais extrêmement utile,
lorsqu'une fonction est définie *à l'intérieur* d'une autre fonction,
son environnement local sera basé sur l'environnement local qui l'entoure
plutôt que sur l'environnement global.

> var variable = "globale";
> function fonctionParente() {
>   var variable = "locale";
>   function fonctionFille() {
>     print(variable);
>   }
>   fonctionFille();
> }
> fonctionParente();

Au final, la visibilité des variables à l'intérieur d'une fonction est
déterminée par la place de cette fonction dans le texte du programme. Toutes
les variables définies « au dessus » de la définition d'une fonction
sont visibles, ce qui signifie à la fois celles dans les corps des fonctions
qui la renferme et celles globales pour tout le programme. Cette approche
de la visibilité des variables est appelée _portée lexicale_.

---

Les gens qui ont l'expérience d'autres langages de programmation pourraient
s'attendre à ce qu'un _bloc_ de code (entre accolades) crée également
un nouvel environnement local. Pas en JavaScript. Les fonctions sont les
seules qui délimittent une nouvelle portée. Vous avez le droit d'utiliser
des blocs libres comme ceci…

> var quelqueChose = 1;
> {
>   var quelqueChose = 2;
>   print("À l'intérieur : " + quelqueChose);
> }
> print("À l'extérieur : " + quelqueChose);

… mais le |quelqueChose| à l'intérieur du bloc fait référence à la même
variable que celui à l'extérieur du bloc. En fait, bien que les blocs comme
celui-ci soient permis, ils sont parfaitement inutiles. La plupart des gens
admettent que c'est une erreur de conception des créateurs de JavaScript,
et ECMAScript Harmony ajoutera certains moyens de définir des variables
qui restent à l'intérieur des blocs (le mot-clé |let|).

---

Voici un cas qui pourrait vous surprendre :

> var variable = "globale";
> function fonctionParente() {
>   var variable = "locale";
>   function fonctionFille() {
>     print(variable);
>   }
>   return fonctionFille;
> }
>
> var fille = fonctionParente();
> fille();

|fonctionParente| *renvoie* ses fonctions internes et le code en bas de
l'appel à cette fonction. Même si |fonctionParente| a fini de s'executer
à ce moment-là, l'environnement local dans lequel |variable| a la valeur
|locale| existe toujours, et |fonctionFille| continue de l'utiliser. Ce
phénomène s'appelle une fermeture lexicale (ou _closure_ en anglais).

---

La portée lexicale permet non seulement de rendre très facile et rapide à
discerner dans quelle partie d'un programme une variable sera disponible,
mais aussi de « synthétiser » des fonctions. En utilisant certaines
des variables venant d'une fonction l'englobant, une fonction interne peut
être amenée à faire des choses différentes. Imaginez que nous ayons
besoin de plusieurs fonctions différentes mais similaires, l'une d'entre
elles ajoutant 2 à son argument, l'autre ajoutant 5 et ainsi de suite.

> function makeAddFunction(quantite) {
>   function ajouter(nombre) {
>     return nombre + quantite;
>   }
>   return ajouter;
> }
>
> var ajouterDeux = makeAddFunction(2);
> var ajouterCinq = makeAddFunction(5);
> show(ajouterDeux(1) + ajouterCinq(1));

Pour vous rendre compte de cela, vous ne devez pas considérer que les
fonctions empaquettent seulement des calculs, mais aussi un environnement. Les
fonctions de haut niveau exécutent simplement l'environnement de haut niveau,
c'est assez évident. Mais une fonction définie à l'intérieur d'une autre
fonction conserve l'accès à l'environnement existant dans cette fonction
à l'instant où elle a été définie.

Par conséquent, la fonction |add| de l'exemple au-dessus, qui est crée
lorsque |makeAddFunction| est appelée, capture un environnement dans lequel
|amount| a une certaine valeur. Il empaquette cet environnement avec le
calcul |return number + amount| à l'intérieur d'une valeur qui est alors
retournée depuis la fonction extérieur.

Lorsque cette fonction renvoyée (|addTwo| ou |addFive|) est appelée, un
nouvel environnement — dans lequel la variable |number| a une valeur —
est créé comme un sous-environnement de l'environnement capturé (dans
lequel |amount| a une valeur). Ces deux valeurs sont ajoutées, et le
résultat est renvoyé.

---

Au-delà du fait que différentes fonctions peuvent contenir des variables de
même nom sans qu'elles ne se mélangent, ces règles de portée permettent
également aux fonctions de s'appeler *elles-mêmes* sans que ça ne
pose de problèmes. Une fonction qui s'appelle elle-même est qualifiée
de récursive. @_récursion_La récursion permet de donner certaines
définitions intéressantes. Jetez un coup d'œil à cette implémentation
de |puissance| :

> function puissance(base, exposant) {
>   if (exposant == 0)
>     return 1;
>   else
>     return base * puissance(base, exposant - 1);
> }

C'est très proche de ce que les mathématiciens définissent comme
l'exponentiation et, à mes yeux, c'est du code bien plus propre que dans
la version initiale. C'est pour ainsi dire une boucle, mais sans |while|,
|for|, ni même un effet de bord visible en local. En s'appelant elle-même,
la fonction produit le même effet.

Il reste toutefois un problème important : dans la plupart des
navigateurs, cette deuxième version est à peu près dix fois plus lente
que la première. En JavaScript, faire tourner une boucle est bien plus
économique qu'appeler une fonction à de multiples reprises.

---

@_efficacité_Le dilemme entre vitesse et _élégance_ est intéressant. Il
n'apparaît pas seulement quand on décide de faire ou non une récursion. Dans
de nombreuses situations, une solution élégante, intuitive et souvent
plus courte peut être remplacée par une solution plus sophistiquée mais
plus rapide.

Dans le cas de la fonction |puissance| ci-dessus la version peu élégante est
encore suffisamment simple et facile à lire. Cela n'aurait pas d'intérêt
de la remplacer par une version récursive. Pourtant il arrive souvent que
les concepts que traite un programme deviennent si complexes qu'il devient
tentant de renoncer à un peu d'efficacité pour gagner en simplicité.

La règle de base, qui a été répétée par de nombreux programmeurs et que
j'approuve de toutes mes forces, c'est de ne pas s'inquiéter de l'efficacité
tant que le programme ne devient pas un peu trop lent. Lorsque c'est le cas,
trouvez quelles parties ralentissent l'exécution et commencez à viser
l'efficacité plutôt que l'élégance.

Bien entendu, la règle ci-dessus ne signifie pas qu'on devrait démarrer
en ignorant complètement le critère de performance. Dans de nombreux cas,
comme la fonction |puissance|, on ne gagne que très peu de simplicité
avec l'approche « élégante ». Dans d'autres cas, un programmeur
expérimenté peut voir tout de suite que la simplicité ne sera jamais
assez rapide.

La raison pour laquelle j'en fais toute une histoire est que bizarrement
beaucoup de programmeurs se concentrent fanatiquement sur l'efficacité,
y compris dans les plus détails les plus insignifiants. Résultat, les
programmes sont plus longs, plus compliqués et souvent moins corrects,
ils prennent plus de temps à écrire que leur équivalent simple et ne
s'exécutent plus vite que de façon marginale.

---

Mais revenons à nos récursions. Un concept étroitement lié à la récursion
est une chose qu'on appelle la _pile_. Quand on appelle une fonction, on
donne le contrôle au corps de cette fonction. Quand le corps est exécuté,
le code qui a appelé la fonction reprend. Pendant que le corps est exécuté,
l'ordinateur doit se souvenir du contexte à partir duquel on a appelé la
fonction pour savoir où reprendre par la suite. L'endroit où ce contexte
est stocké est appelé la pile.

Le fait qu'on l'appelle une « pile » vient du fait que, comme nous
l'avons vu, un corps de fonction peut appeler à nouveau une fonction. À
chaque fois qu'une fonction est appelée, un autre contexte doit être
stocké. On peut se le représenter comme une pile de contextes. À chaque
appel de fonction, le contexte courant est mis sur le haut de la pile. Quand
une fonction se termine, le contexte du haut de la pile en est retiré pour
être restauré.

Cette pile nécessite un espace de stockage dans la mémoire de
l'ordinateur. Quand la pile prend trop d'ampleur, l'ordinateur abandonne
l'exécution en court avec un message du genre « plus d'espace disponible
dans la pile » ou « trop de récursions ». Mieux vaut s'en souvenir
quand on écrit des fonctions récursives.

!> function poule() {
!>   return oeuf();
!> }
!> function oeuf() {
!>   return poule();
!> }
!> print(poule() + " était là en premier.");

Non seulement cet exemple nous expose une manière très intéressante
d'écrire un programme qui plante, mais il montre aussi qu'une fonction n'a
pas à s'appeler elle-même directement pour être récursive. Si elle appelle
une autre fonction qui (directement ou non) appelle à nouveau la première,
elle est quand même récursive.

---

La récursion n'est pas toujours juste une alternative moins efficace à
une boucle. Certains problèmes sont bien plus faciles à résoudre avec
une récursion qu'avec des boucles. Il s'agit le plus souvent de problèmes
qui exigent l'exploration de plusieurs « branches », chacune d'elles
pouvant à son tour se subdiviser en autres branches.

Réfléchissez à cette énigme : en partant du nombre 1 et en lui ajoutant
toujours 5 ou bien en le multipliant toujours par 3, on peut générer une
quantité infinie de nouveaux nombres. Comment écririez-vous une fonction
qui, étant donné un nombre, essaie de trouver une suite d'additions et de
multiplications qui produise ce nombre ?

Par exemple le nombre 13 peut être obtenu en multipliant d'abord 1 par 3,
puis en ajoutant deux fois 5. Par contre, on ne peut pas obtenir le nombre 15.

Voici la solution :

> function findSequence(goal) {
>   function find(start, history) {
>     if (start == goal)
>       return history;
>     else if (start > goal)
>       return null;
>     else
>       return find(start + 5, "(" + history + " + 5)") ||
>              find(start * 3, "(" + history + " * 3)");
>   }
>   return find(1, "1");
> }
>
> print(findSequence(24));

Notez que le programme ne trouve pas forcément la plus *courte* suite
d'opérations, il estime avoir rempli sa mission dès qu'il trouve une
combinaison quelconque d'opérations.

La fonction interne |find|, en s'appelant elle-même de deux façons
différentes, explore à la fois la possibilité d'ajouter 5 au nombre
courant et celle de le multiplier par 3. Quand le nombre voulu est trouvé,
elle renvoie la chaîne |history|, qui est utilisée pour enregistrer tous
les opérateurs mis en œuvre pour parvenir au résultat. Elle vérifie
également si le nombre courant est plus grand que |goal| qui est le nombre
recherché, puisque si c'est le cas, nous devons interrompre l'exploration
de cette branche car elle ne peut nous donner le nombre que nous voulons.

L'utilisation de l'opérateur |||| dans l'exemple peut être compris comme
« renvoyer la solution trouvée en ajoutant 5 à |start| et, si cela
échoue, renvoyer la solution trouvée en multipliant |start| par 3 ». On
peut aussi écrire d'une façon plus verbeuse de la façon suivante :

!> else {
!>   var found = find(start + 5, "(" + history + " + 5)");
!>   if (found == null)
!>     found = find(start * 3, history + " * 3");
!>   return found;
!> }

---

Même si les définitions de fonctions interviennent comme des instructions au
milieu du reste du programme, elles ne font pas partie de la même chronologie.

> print("On dit que dans le futur ", futur());
>
> function futur() {
>   return "nous n'aurons toujours pas de voitures volantes.";
> }

Ce qui se passe c'est que l'ordinateur examine toutes les définitions de
fonctions et les stocke dans les fonctions associées, *avant* de commencer
à exécuter le reste du programme. Il en va de même avec les fonctions qui
sont définies à l'intérieur d'autres fonctions. Quand la fonction externe
est appelée, la première chose qui se passe est que toutes les fonctions
internes sont ajoutées au nouvel environnement.

---

Il existe une autre façon de définir des valeurs de type fonction,
ressemblant davantage à la façon dont les autres valeurs sont créées. Quand
le mot-clé |function| est utilisé dans un endroit où une expression est
attendue, il est considéré comme une expression qui produit une valeur de
type fonction. Les fonctions créées de cette façon n'ont même pas besoin
d'être nommées (bien qu'il soit autorisé de le faire).

> var add = function(a, b) {
>   return a + b;
> };
> show(add(5, 5));

Notez le point-virgule après la définition de |add|. Les définitions
normales de fonctions n'en ont pas besoin, mais cette instruction a la
structure générale de |var add = 22;| et donc nécessite un point-virgule.

Ce type de valeur est appelé _fonction anonyme_, parce que la fonction
définie n'a alors pas de nom. Parfois il est inutile de donner un nom aux
fonctions, comme dans l'exemple précédant de |makeAddFunction| :

> function makeAddFunction(amount) {
>   return function (number) {
>     return number + amount;
>   };
> }

Puisque dans la première version de |makeAddFunction|, la fonction |add| n'a
servi qu'une fois, le nom n'est pas nécessaire et nous pouvons directement
retourner la valeur de la fonction.

***

Écrivez une fonction |greaterThan|, qui prend un nombre en argument
et retourne une fonction qui représente un test. Quand cette nouvelle
fonction est appelée avec un simple nombre comme argument, elle retourne
un booléen : |true| si le nombre donné est plus grand que le nombre
utilisé pour créer la fonction, et |false| sinon.

///

> function greaterThan(x) {
>   return function(y) {
>     return y > x;
>   };
> }
>
> var greaterThanTen = greaterThan(10);
> show(greaterThanTen(9));

---

Essayez cela :

> alert("Salut", "Bonsoir", "Comment allez-vous ?", "Au revoir");

La fonction |alert| n'accepte officiellement qu'un argument. Cependant,
quand vous l'appelez ainsi, l'ordinateur ne se plaint pas, il ignore juste
les autres arguments.

> show();

Vous pouvez même, apparemment, vous passer d'arguments. Quand un argument
n'est pas transmis, sa valeur dans la fonction est |undefined|.

Dans le chapitre suivant, nous verrons un moyen pour que le corps de la
fonction connaisse la liste exacte des arguments qui lui sont donnés. Cela
peut être utile, par exemple, pour réaliser une fonction qui accepte
n'importe quel nombre d'arguments : |print| se comporte comme cela.

> print("R", 2, "D", 2);

Bien sûr, un inconvénient est qu'il est aussi possible de donner un nombre
incorrect d'arguments aux fonctions qui doivent en recevoir un nombre fixe,
comme |alert|, et de ne pas en être prévenu.

=================================================
Structures de données : objets et tableaux / data
=================================================

Ce chapitre sera consacré à la résolution de quelques problèmes simples. En
chemin, nous allons étudier deux nouveaux types de valeurs, les tableaux
et les objets, et étudier quelques techniques les concernant.

Considérons la situation suivante : votre tante Émilie l'excentrique,
dont la rumeur dit qu'elle vit avec cinquante chats (en fait personne n'arrive
à les compter), vous envoie régulièrement des e-mails pour vous tenir au
courant de ses exploits. Ils sont de la forme suivante :

| Mon cher neveu,
| Ta mère m'a dit que tu as commencé à faire du parachutisme. Est-ce
| que c'est vrai ? Fais attention à toi, mon garçon ! Souviens-toi de
| ce qui est arrivé à mon mari et ce n'était que du deuxième étage !
|
| En tout cas, les choses sont très intéressantes de mon côté. J'ai
| passé toute la semaine à essayer d'obtenir l'attention de Mr. Drake,
| le sympathique monsieur qui a emménagé à côté, mais je pense qu'il a
| peur des chats. À moins qu'il n'y soit allergique ? À la prochaine
| rencontre, je vais essayer de poser Igor Le Gros sur son épaule. Je
| suis curieuse de voir le résultat.
|
| Par ailleurs, l'escroquerie dont je t'avais parlé fonctionne mieux
| que je pensais. J'ai déjà récupéré cinq « paiements » et seulement
| une seule plainte. Mais j'ai quelques remords malgré tout. Et tu as
| sans doute raison de dire que c'est probablement illégal d'une
| manière ou d'une autre.
|
| (…etc.)
|
| Grosses bises, Tante Émilie
|
| Décès le 27/04/2006 : Black Leclère
|
| Nés le 05/04/2006 (mère Lady Pénélope) : Lion Rouge,
| Docteur Hobbles III, Petit Iroquois

Pour amuser cette vieille dame, vous voudriez garder une trace de la
généalogie de ses chats, pour pouvoir ajouter des commentaires comme
« P.-S. J'espère que Docteur Hobbles II a bien fêté son anniversaire
samedi ! », ou bien « Comment va cette vieille Lady Pénélope ? Elle
a cinq ans maintenant, n'est-ce pas ? », en évitant de préférence de
demander des nouvelles des chats décédés. Vous avez une grande quantité
de vieux emails de votre tante et, par chance, elle est très constante dans
sa manière de donner les renseignements sur les naissances et décès des
chats à la fin de ses e-mails, toujours dans le même format.

Vous n'avez pas envie de parcourir à la main tous ces messages. Heureusement,
nous avions justement besoin d'un exemple, nous allons donc écrire un
programme qui va faire le travail pour nous. Pour commencer, nous allons
écrire un programme qui va nous donner la liste des chats qui sont toujours
vivants à la fin du dernier e-mail.

Avant que vous ne posiez la question, au début de cette correspondance,
la tante Émilie n'avait qu'un seul chat : Spot (elle était encore assez
conformiste à cette époque).

---

[[[eyes.png]]]

---

Il est généralement préférable d'avoir une idée de départ sur ce que
va faire un programme avant de se mettre à l'écrire… Voici le plan :

 1. Commencer avec un ensemble de noms de chats ne comprenant que « Spot ».
 2. Parcourir chaque e-mail dans l'archive dans l'ordre chronologique.
 3. Chercher les paragraphes qui commencent par « Nés le » ou « Décès le ».
 4. Ajouter les noms trouvés dans les paragraphes qui commencent par « Nés le » à l'ensemble de noms.
 5. Supprimer les noms de chats trouvés dans les paragraphes qui commencent par « Décès le » de notre ensemble.

On extraira les noms d'un paragraphe de la façon suivante :

 1. Trouver les deux-points (:) dans le paragraphe.
 2. Prendre la partie après ce signe.
 3. Dans cette partie, séparer les noms en cherchant les virgules.

Cet énoncé d'exercice peut rendre nécessaire d'oublier quelques instants
les exceptions possibles et d'accepter aveuglément que tante Émilie utilise
toujours le même format d'écriture, qu'elle n'oublie jamais un nom de chat,
ni ne fait de faute de frappe. Mais votre tante est comme ça et ça tombe
bien pour nous.

---

D'abord, je vais vous expliquer les _propriété_s. Beaucoup de valeurs en
Javascript ont d'autres valeurs qui leur sont associées. Ces associations
sont appelées propriétés. Chaque chaîne de caractères a une propriété
appelée _|length|_, (longueur), qui correspond à un nombre, la quantité
de caractères dans cette chaîne.

On peut accéder aux @_|[]|_propriétés de deux manières :

> var text = "brume pourpre";
> show(text["length"]);
> show(text.length);

La deuxième manière est un raccourci de la première et ne fonctionne
que lorsque le nom de la propriété s'écrit comme un nom de variable
-- lorsqu'il n'y a pas d'espace ou de symbole et lorsqu'elle ne commence
pas par un chiffre.

Les valeurs |null| et |undefined| n'ont pas de propriété. Essayez de lire des
propriétés de ces valeurs donnera une erreur. Essayez le code suivant, juste
pour voir le type de message d'erreur que votre navigateur va retourner dans ce
cas de figure (dans certains navigateurs, ce message sera assez mystérieux).

!> var rienDuTout = null;
!> show(rienDuTout.length);

---

Les propriétés d'une chaîne de caractères ne peuvent pas être
changées. Elles sont plus nombreuses que la seule longueur |length|,
comme nous allons le voir, mais vous ne pouvez ajouter ni supprimer aucune
propriété.

C'est différent avec les valeurs du type _object_. Leur rôle principal est
de conserver d'autres valeurs. Ils ont, en quelque sorte, leur propre jeu
de « tentacules » sous forme de propriétés. Vous pouvez les modifier,
les supprimer ou en ajouter de nouvelles.

@_|{}|_Un objet peut s'écrire de la façon suivante :

> var chat = {couleur: "gris", nom: "Spot", taille: 46};
> chat.taille = 47;
> show(chat.taille);
> delete chat.taille;
> show(chat.taille);
> show(chat);

Comme les variables, chaque propriété attachée à un objet a un nom
sous forme d'une chaîne de caractères. La première instruction crée un
objet dans lequel la propriété |"couleur"| contient la chaîne |"gris"|,
la propriété |"nom"| est liée à la chaîne |"Spot"|, et la propriété
|"taille"| fait référence au nombre |46|. La deuxième ligne modifie la
propriété |taille| en lui donnant une nouvelle valeur, ce qui se fait de
la même manière que pour la modification d'une variable.

Le mot-clé _|delete|_ supprime les propriétés. Essayez de lire une
propriété qui n'existe pas donnera la valeur |undefined|.

Si une propriété qui n'existe pas encore est affectée avec l'opérateur
_|=|_, elle est ajoutée à l'objet.

> var vide = {};
> vide.plusVraiment = 1000;
> show(vide.plusVraiment);

Les propriétés dont le nom ne pourrait pas être une variable doivent être
mises entre guillemets au moment de la création de l'objet et utilisées
avec des parenthèses :

> var truc = {"gabba gabba": "hey", "5": 10};
> show(truc["5"]);
> truc["5"] = 20;
> show(truc[2 + 3]);
> delete truc["gabba gabba"];

Comme vous pouvez le voir, on peut mettre n'importe quelle expression entre
les parenthèses. Elle sera convertie dans une chaîne pour définir le nom
de la propriété. On peut aussi utiliser des variables pour donner un nom
à une propriété :

> var nomDePropriete = "length";
> var texte = "grandeLigne ";
> show(texte[nomDePropriete]);

L'opérateur _|in|_ peut servir à tester si un objet possède une certaine
propriété. Son résultat est un booléen.

> var poupeeRusse = {};
> poupeeRusse.contenu = poupeeRusse;
> show("contenu" in poupeeRusse);
> show("contenu" in poupeeRusse.contenu);

---

Quand les valeurs d'un objet sont affichées sur la  console, on peut cliquer
à la souris pour inspecter leurs propriétés. La  fenêtre de sortie
devient une fenêtre « inspecteur ». Le petit « x » en  haut
à droite s'utilise pour retourner à la fenêtre de sortie et la  flèche
gauche permet de retourner aux propriétés de l'objet inspecté.

> show(poupeeRusse);

***

La solution pour le problème des chats passe par un ensemble de noms. Un
ensemble (ou « _set_ ») est un groupe de valeurs dans lequel aucune
valeur ne peut apparaître plus d'une fois. Si les noms de chats sont des
chaînes de caractères, pouvez-vous imaginer une façon pour qu'un objet
devienne un ensemble de noms ?

Écrivez maintenant la façon dont un nom peut être ajouté à cet ensemble,
comment on peut le supprimer et comment on peut vérifier si un certain nom
est bien présent dans l'ensemble.

///

Une solution consiste à mémoriser le contenu de l'ensemble sous la forme
de propriétés d'un objet. Pour ajouter un nom, on crée une propriété
avec ce nom en lui affectant une valeur, n'importe laquelle. Pour supprimer
un nom, on supprimera la propriété de l'objet. L'opérateur |in| sera
utilisé pour savoir si une certaine propriété fait partie de l'ensemble##.

## Il y a quelques problèmes subtils avec cette approche dont nous
parlerons et que nous résoudrons dans le \\coo. On ne s'en occupera pas
pour ce chapitre.

> var set = {"Spot": true};
> // Ajoute "Croc Blanc" à l'ensemble
> set["Croc Blanc"] = true;
> // Supprime "Spot"
> delete set["Spot"];
> // Regarde si "Asoka" est dans l'ensemble
> show("Asoka" in set);

---

Les valeurs des @_mutability_objets peuvent apparemment changer. Les types
de valeurs vues dans le \\cbasics sont toutes invariables, il n'est pas
possible de changer une valeur existante pour ces types de données. Vous
pouvez les associer ou en tirer de nouvelles valeurs, mais lorsque vous
prenez une chaîne de caractères particulière, le texte à l'intérieur
ne peut pas être modifié. Avec les objets, d'un autre côté, le contenu
d'une valeur peut être modifié en changeant ses propriétés.

Lorsque nous considérons deux nombres, |120| et |120|, il est possible dans
tous les cas pratiques de les considérer comme des nombres identiques. Avec
des objets, il y a une différence importante entre avoir deux « références
» du même objet et avoir deux objets distincts qui possèdent les mêmes
propriétés. Considérons le code suivant :

> var objet1 = {valeur: 10};
> var objet2 = objet1;
> var objet3 = {valeur: 10};
>
> show(objet1 == object2);
> show(objet1 == object3);
>
> objet1.valeur = 15;
> show(objet2.valeur);
> show(objet3.valeur);

|objet1| et |objet2| sont deux variables attachées à la *même* valeur. Il
n'y a en fait qu'un seul objet, c'est pourquoi en changeant |objet1| on
change également la valeur de |objet2|. La variable |objet3| pointe vers
un autre objet qui contient au départ la même propriété que |objet1|
mais elle a une existence distincte.

L'opérateur JavaScript _|==|_, lorsqu'il compare des objets, ne retournera
la valeur booléenne |true| que si chacune des valeurs qu'on lui donne à
comparer sont exactement les mêmes. Comparer des objets différents ayant des
contenus identiques donnera le résultat |false|. C'est utile dans certaines
situations, mais peu adapté à d'autres.

---

Les valeurs d'un objet peuvent jouer de nombreux rôles. Se comporter comme
un ensemble n'est que l'un d'entre eux. Nous allons voir d'autres utilisations
dans ce chapitre et le \\coo montrera d'autres façons importantes d'utiliser
les objets.

Dans le plan d'action pour le problème des chats — en fait, appelons-le
un *algorithme* au lieu d'un plan, cela nous donne l'impression qu'on sait
de quoi on parle — dans l'algorithme, on parle de parcourir chaque e-mail
contenu dans une archive. Mais comment se présente cette archive ? Et
d'où vient-elle ?

Ne vous inquiétez pas de la deuxième question pour le moment. Le \\cxhr
explique quelques-unes des possibilités pour importer des données dans
vos programmes. Pour l'instant, on dira que les e-mails sont déjà là,
comme par magie. La magie est parfois très facile, avec les ordinateurs.

---

La façon dont l'archive est enregistrée reste une question pertinente. Elle
contient quantité d'e-mails. Un e-mail peut être vu comme une chaîne de
caractères, c'est évident. Toute l'archive pourrait être mise dans une
énorme chaîne de caractères mais ce ne serait pas pratique. Ce qu'il nous
faut, c'est une structure de chaînes de caractères distinctes.

Les objets sont justement utilisés pour structurer des choses. On pourrait
très bien créer un objet comme celui-ci :

> var archiveMail = {"le premier e-mail": "Cher neveu, …",
>                    "le deuxième e-mail": "…"
>                    /* et ainsi de suite… */};

Mais parcourir les e-mails du début à la fin serait difficile — comment
le programme peut-il deviner le nom de ces propriétés ? La solution est
d'utiliser des noms de propriétés plus prévisibles :

> var archiveMail = {0: "Cher neveu, … (mail numéro 1)",
>                    1: "(mail numéro 2)",
>                    2: "(mail numéro 3)"};
>
> for (var courant = 0; courant in archiveMail; courant++)
>   print("Traitement de l'e-mail #", courant, ": ", archiveMail[courant]);

La chance veut qu'il existe un type d'objet particulier qui corresponde
exactement à ce type de besoin. Ce sont les @_array_tableaux et ils
fournissent des commodités très utiles, comme par exemple _|length|_
(longueur), une propriété qui contient le nombre d'éléments dans le
tableau et bien d'autres fonctions utiles pour ce type de structure.

@_|[]|_Pour créer de nouveaux tableaux on utilise des crochets (|[| et |]|):

> var archiveMail = ["mail un", "mail deux", "mail trois"];
>
> for (var courant = 0; courant < archiveMail.length; courant++)
>   print("Traitement de l'e-mail #", courant, ": ", archiveMail[courant]);

Dans cet exemple, le nombre d'éléments n'est plus spécifié
explicitement. Le premier a automatiquement le numéro 0, le deuxième le
numéro 1 et ainsi de suite.

Pourquoi commencer à 0 ? Dans la vie courante on compte d'habitude à
partir de 1. Aussi étrange que cela paraisse, la numérotation à partir
de 0 est souvent plus pratique pour programmer. Faites avec pour l'instant,
vous allez vous y faire.

Commencer par l'élément 0 veut aussi dire que dans une structure qui
a |X| éléments, le dernier élément sera trouvé à la position |X -
1|. C'est pourquoi la boucle |for| dans notre exemple teste la valeur
|current < mailArchive.length|. Il n'y a pas d'élément à la position
|mailArchive.length|, donc dès que |current| atteint cette valeur, on
arrête la boucle.

*** range

Écrivez une fonction nommée |série| qui prend un argument, un nombre
positif et retourne un tableau contenant chaque nombre de 0 jusqu'au nombre
donné en paramètre inclus.

Un tableau vide peut être créé en tapant simplement |[]|. Souvenez-vous que
pour ajouter des propriétés à un tableau, comme pour un objet, il suffit
d'affecter une valeur à la propriété avec l'opérateur |=|. La propriété
|length| est mise à jour automatiquement quand des éléments sont ajoutés.

///

> function serie(max) {
>   var resultat = [];
>   for (var i = 0; i <= max; i++)
>     resultat[i] = i;
>   return resultat;
> }
> show(serie(4));

Au lieu de nommer la variable de boucle |compteur| ou |courant|, comme je l'ai
fait jusqu'à présent, elle s'appelle désormais simplement |i|. L'utilisation
d'une seule lettre, habituellement |i|, |j| ou |k| pour les variables de boucle
est une habitude très répandue en programmation. Son origine tient presque
à de la paresse : on préfère taper un caractère que sept et des noms
comme |counter| et |current| ne donnent pas forcément plus d'informations
sur la variable.

Si un programme utilise trop souvent des variables à un seul caractère, sans
explication, il peut devenir très difficile à comprendre. Dans mes propres
programmes, j'essaie de me limiter à quelques cas de figures seulement. Les
petites boucles font partie de ces cas. Si la boucle contient une autre
boucle et que celle-ci utilise aussi une variable appelée |i|, la boucle
intérieure va modifier la variable dont se sert la première boucle, et rien
ne va fonctionner. Ou pourrait utiliser |j| pour la boucle intérieure, mais
en général, lorsque le corps d'une boucle est grand, vous devriez utiliser
un nom de variable ayant une signification utile pour la compréhension.

---

Les chaînes de caractères et les objets « tableaux » contiennent tous
deux, outre la propriété |length|, un certain nombre d'autres propriétés
qui font référence à des fonctions.

> var doh = "Doh";
> print(typeof doh.toUpperCase);
> print(doh.toUpperCase());

Chaque chaîne de caractères a une propriété _|toUpperCase|_. Lorsqu'elle
est appelée, elle retourne une copie de la chaîne, transformée avec chaque
lettre en majuscule. Il y a aussi l'équivalent _|toLowerCase|_. Devinez
le résultat…

Remarquez que même si l'appel de |toUpperCase| se fait sans arguments,
la fonction a malgré tout accès au contenu de la chaîne de caractères
|"Doh"|, la valeur dont elle est une propriété. La façon dont cela
fonctionne est décrite dans le \\coo.

Les propriétés qui se comportent comme des fonctions sont généralement
appelées @_methode_méthodes, comme pour « |toUpperCase| qui est une
méthode des objets de type chaîne de caractères ».

> var flipper = [];
> flipper.push("Flipper");
> flipper.push("le");
> flipper.push("dauphin");
> show(flipper.join(" "));
> show(flipper.pop());
> show(flipper);

La méthode _|push|_, associée aux tableaux, peut être utilisée pour
ajouter des valeurs à ceux-ci. Nous aurions pu l'utiliser dans l'exercice
précédent, à la place de |resultat[i] = i|. Il y a aussi la méthode
_|pop|_, complémentaire de |push| : elle supprime le dernier élément
d'un tableau et retourne sa valeur. _|join|_ construit une seule chaîne de
caractères à partir d'un tableau de chaînes de caractères. Le paramètre
utilisé avec cette méthode sera inséré entre chaque valeur du tableau,
avant l'assemblage de la chaîne de caractères finale.

---

Revenons à nos chats : nous savons maintenant qu'utiliser un tableau
serait une bonne idée pour ranger les archives des e-mails. Sur cette page,
la fonction |recupererMails| sera utilisée pour récupérer (magiquement)
ce tableau. Parcourir les emails qu'il contient pour les traiter un par un
devient simple comme un jeu d'enfant :

> var archiveMail = recupererMails();
>
> for (var i = 0; i < archiveMail.length; i++) {
>   var email = archiveMail[i];
>   print("Traitement de l'e-mail #", i);
>   // Faire plus de choses…
> }

Nous avons également décidé d'une manière de représenter un ensemble
de chats vivants. Le problème qui reste à traiter, cependant, est celui
de détecter des paragraphes d'un e-mail qui contiennent |"Nés le"|  ou
|"Décès le"|.

---

La première question qui vient à l'esprit est de savoir ce qu'est un
paragraphe au juste. Dans ce cas, la valeur de la chaîne elle-même n'est
pas d'une grande utilité : le concept du texte en JavaScript ne va guère
plus loin que l'idée de « suite de caractères », si bien que nous
devons définir les paragraphes de cette façon.

Nous avons vu plus haut qu'il existe une chose qui s'appelle un caractère
de fin de ligne. C'est ce que la plupart des gens utilisent pour séparer les
paragraphes. Nous considérons donc un paragraphe comme une partie de mail qui
commence par un caractère saut de ligne ou au début du contenu du message
et se termine au caractère saut de ligne suivant ou bien à la fin du contenu.

Et nous n'avons même pas à écrire nous-mêmes l'algorithme pour scinder
une chaîne en paragraphes. Les chaînes ont déjà une méthode appelée
_|split|_,  qui est (pratiquement) l'inverse de la méthode |join| pour les
tableaux. Elle découpe une chaîne en un tableau en utilisant la chaîne
fournie comme argument pour déterminer à quel endroit opérer les divisions
en paragraphes.

> var words = "Les villes de l'arrière-pays";
> show(words.split(" "));

Ainsi, découper avec des caractères saut de ligne (|"\n"|) est une méthode
utilisable pour diviser un e-mail en paragraphes.

***

|split| et |join| ne sont pas exactement l'inverse l'une de
l'autre. |string.split(x).join(x)| produit toujours la valeur originale,
mais pas  |array.join(x).split(x)|. Pouvez-vous donner un exemple de tableau
dans  lequel |.join(" ").split(" ")| produit une valeur différente ?

///

> var array = ["a", "b", "c d"];
> show(array.join(" ").split(" "));

---

Les paragraphes qui ne commencent ni par « Nés le » ni par
« Décès le » peuvent être ignorés par le programme. Comment peut-on
tester si une chaîne commence par un mot particulier ? On peut utiliser
la méthode _|charAt|_ pour obtenir un caractère particulier dans une chaîne.
|x.charAt(0)| donne le premier caractère, |1| est le deuxième et ainsi de
suite. Voici une façon de vérifier si une chaîne commence par « Nés
le» :

> var paragraphe = "Nés le  15/11/2003 (mère Spot) : Croc Blanc";
> show(paragraphe.charAt(0) == "N" && paragraphe.charAt(1) == "é" &&
>      paragraphe.charAt(2) == "s" && paragraphe.charAt(3) == " " &&
>      paragraphe.charAt(4) == "l" && paragraphe.charAt(5) == "e") ;

Mais cela devient un peu pénible -- imaginez que vous devez vérifier la
présence d'un mot de 30 caractères. On peut cependant en tirer une leçon
utile : si une ligne est démesurément longue, on peut l'étendre sur
plusieurs lignes. Le résultat peut être plus facile à lire en alignant
le début d'une nouvelle ligne avec la ligne originale jouant le même rôle

Les chaînes possèdent également une méthode nommée _|slice|_. Elle permet
de copier un morceau de la chaîne de caractères, en commençant par le
caractère à la position donnée par le premier argument, et se terminant
avant le caractère (non inclus) à la position donnée par le second
argument. Cela permet de vérifier une chaîne de caractères en peu de lignes.

> show(paragraphe.slice(0, 12) == "Nés le");

***

Écrivez une fonction nommée |startWith| qui prend deux arguments, tous les
deux des chaînes de caractères. Elle renvoie |true| quand le premier argument
commence avec les caractères du second arguments, sinon elle renvoie |false|.

///

> function startsWith(string, pattern) {
>   return string.slice(0, pattern.length) == pattern;
> }
>
> show(startsWith("rotation", "rot"));

---

Que se passe-t-il quand |charAt| ou |slice| sont utilisés pour prendre un
fragment de chaîne qui n'existe pas ? Est-ce que le |startsWith| que j'ai
montré va encore fonctionner si le la chaîne recherchée est plus longue
que celle dans laquelle on cherche ?

> show("Pip".charAt(250));
> show("Nop".slice(1, 10));

|charAt| va renvoyer |""| s'il n'existe pas de caractère à la position
donnée et |slice| va tout simplement laisser tomber la partie de la nouvelle
chaîne qui n'existe pas.

Cela confirme que cette version de |startWith| fonctionne. Quand la fonction
|startsWith("Idiots","Mes très chers collègues")| est appelée, l'appel
à |slice| renverra toujours une chaîne plus courte que |pattern|, parce
que |string| ne comporte pas assez de caractères. C'est pour cette raison
que la comparaison avec |==| renverra |false|, ce qui est correct.

C'est une bonne idée de toujours consacrer un moment pour prendre en
considération les entrées aberrantes (mais valides) dans un programme. On
les appelle en général des cas imprévus et il est très fréquent qu'un
programme qui tourne à merveille avec toutes les entrées « normales »
se plante complètement avec des cas imprévus.

---

La seule partie de notre problème de chats qui ne soit pas encore résolue
est l'extraction des noms d'un paragraphe. L'algorithme était le suivant :

 1. Trouver le deux-points (:) dans le paragraphe.
 2. Prendre la partie après ce signe.
 3. Dans cette partie, séparer les noms en cherchant les virgules.

Il faut reproduire cela à la fois pour les paragraphes qui commencent par
|Décés le| et ceux qui commencent par |Nés le|. Ce serait une bonne idée
de le mettre dans une fonction, de sorte que les deux parties de code qui
gèrent les différentes sortes de paragraphes puissent l'utiliser.

***

Savez-vous écrire une fonction |nomChats| qui prenne un paragraphe comme
argument et renvoie un tableau de noms ?

Les chaînes ont une méthode _|indexOf|_que l'on peut utiliser pour trouver la
(première) position d'un caractère ou une sous-chaîne à l'intérieur d'une
chaîne. De même si on ne donne qu'un seul argument à |slice|, elle renverra
la partie de la chaîne depuis la première position jusqu'à son extrémité.

Il peut être pratique d'utiliser la console pour « explorer » les
fonctions. Par exemple, tapez |"foo: bar".indexOf(":")| et voyez ce qui
se passe.

///

> function catNames(paragraph) {
>   var colon = paragraph.indexOf(":");
>   return paragraph.slice(colon + 2).split(", ");
> }
>
> show(catNames("Nés le 20/09/2004 (de mère Yellow Bess): " +
>               "Doctor Hobbles the 2nd, Noog"));

La partie la plus délicate qui est ignorée par la description originale
de l'algorithme, est le traitement des espaces après les deux-points
et les virgules. Le |+2|, utilisé pour le découpage de chaînes, est
nécessaire pour laisser de côté le deux-points lui-même et l'espace qui
le suit. L'argument pour |split| contient à la fois une virgule et un espace,
parce que ce sont les séparateurs de noms, plutôt que par une simple virgule.

Cette fonction n'effectue aucune vérification de problèmes éventuels. Nous
faisons comme si, dans ce cas précis, l'entrée était toujours correcte.

---

Tout ce qui nous reste à faire maintenant, c'est de rassembler les pièces
du puzzle. Voici une façon de s'y prendre :

> var mailArchive = retrieveMails();
> var livingCats = {"Spot": true};
>
> for (var mail = 0; mail < mailArchive.length; mail++) {
>   var paragraphs = mailArchive[mail].split("\n");
>   for (var paragraph = 0;
>        paragraph < paragraphs.length;
>        paragraph++) {
>     if (startsWith(paragraphs[paragraph], "Nés le")) {
>       var names = catNames(paragraphs[paragraph]);
>       for (var name = 0; name < names.length; name++)
>         livingCats[names[name]] = true;
>     }
>     else if (startsWith(paragraphs[paragraph], "Décès le")) {
>       var names = catNames(paragraphs[paragraph]);
>       for (var name = 0; name < names.length; name++)
>         delete livingCats[names[name]];
>     }
>   }
> }
>
> show(livingCats);

Voilà un bloc de code assez copieux et dense. Nous allons voir tout de
suite comment l'alléger un peu. Mais d'abord jetons un coup d'œil aux
résultats. Nous savons comment vérifier si un chat particulier a survécu :

> if ("Spot" in livingCats)
>   print("Spot est vivant !");
> else
>   print("Ce bon vieux Spot, qu'il repose en paix.");

Mais comment allons-nous faire pour dresser la liste de tous les chats
vivants ? Le mot-clé _|in|_ a une signification légèrement différente
lorsqu'il est utilisé avec |for| :

> for (var cat in livingCats)
>   print(cat);

Une boucle comme celle-là va parcourir les noms des propriétés d'un objet,
ce qui nous permettra d'énumérer tous les noms de notre ensemble.

---

Certaines parties de code ressemble à une jungle impénétrable. L'exemple
de solution pour le problème des chats souffre de ce défaut. Une façon
de ménager des clairières consiste tout simplement à ajouter des lignes
vides. Cela améliore la lisibilité, mais ne résout pas véritablement
le problème.

Ce qu'il nous faut ici, c'est casser le code. Nous avons déjà écrit deux
fonctions d'aide, |startsWith| et |catNames|, qui toutes deux résolvent
une petite partie du problème de façon compréhensible. Continuons sur
cette lancée.

> function addToSet(set, values) {
>   for (var i = 0; i < values.length; i++)
>     set[values[i]] = true;
> }
>
> function removeFromSet(set, values) {
>   for (var i = 0; i < values.length; i++)
>     delete set[values[i]];
> }

Ces deux fonctions traitent de l'ajout et de la suppression des noms dans
l'ensemble. Ce qui supprime déjà les deux plus importantes boucles internes
de la solution :

> var livingCats = {Spot: true};
>
> for (var mail = 0; mail < mailArchive.length; mail++) {
>   var paragraphs = mailArchive[mail].split("\n");
>   for (var paragraph = 0;
>        paragraph < paragraphs.length;
>        paragraph++) {
>     if (startsWith(paragraphs[paragraph], "Nés le"))
>       addToSet(livingCats, catNames(paragraphs[paragraph]));
>     else if (startsWith(paragraphs[paragraph], "Décès le"))
>       removeFromSet(livingCats, catNames(paragraphs[paragraph]));
>   }
> }

C'est un sacré progrès, si je peux me permettre.
Pourquoi |addToSet| et |removeFromSet| prennent-ils l'ensemble comme
argument ? Ils pourraient utiliser la variable |livingCats| directement,
s'ils le voulaient. La raison, c'est que de cette façon elles ne sont pas
totalement liées à notre problème. Si |addToSet| changeait directement
|livingCats|, il faudrait l'appeler |addCatsToCatSet| (ajouter des chats à
l'ensemble des chats) ou quelque chose comme ça. Tel que nous l'utilisons,
c'est un outil utile pour des cas plus généraux.

Même si nous ne devions jamais utiliser ces fonctions pour quoi que ce
soit d'autre, ce qui est très probable, il est utile de les décrire de
cette façon. Car elles se « suffisent à elles-même », on peut les
lire et les comprendre, sans avoir besoin de connaître une variable externe
nommée |livingCats|.

Les fonctions ne sont pas pures : elles modifient l'objet qui a été passé
en premier argument (|set|). Cela rend les choses un peu plus délicates
qu'avec des fonctions pures mais c'est déjà beaucoup moins perturbant que
des fonctions qui perdent les pédales et modifient les valeurs de variables
comme ça leur chante.

---

Nous continuons à découper l'algorithme en petites unités :

> function findLivingCats() {
>   var mailArchive = retrieveMails();
>   var livingCats = {"Spot": true};
>
>   function handleParagraph(paragraph) {
>     if (startsWith(paragraph, "Nés le"))
>       addToSet(livingCats, catNames(paragraph));
>     else if (startsWith(paragraph, "Décès le"))
>       removeFromSet(livingCats, catNames(paragraph));
>   }
>
>   for (var mail = 0; mail < mailArchive.length; mail++) {
>     var paragraphs = mailArchive[mail].split("\n");
>     for (var i = 0; i < paragraphs.length; i++)
>       handleParagraph(paragraphs[i]);
>   }
>   return livingCats;
> }
>
> var howMany = 0;
> for (var cat in findLivingCats())
>   howMany++;
> print("Il y a ", howMany, " chats.");

La totalité de l'algoritme est encapsulée dans une fonction. Cela signifie
qu'elle ne laisse rien traîner en vrac derrière elle après exécution :
|livingCats| est maintenant une variable locale dans la fonction et non plus
une variable globale, si bien qu'elle n'existe que pendant que la fonction
s'exécute. Le code qui a besoin de cet ensemble peut appeler |findLivingCats|
et utiliser la valeur qu'il renvoie.

Il me semble que faire de |handleParagraph| une fonction distincte peut
aussi clarifier les choses. Mais celle-ci est si étroitement liée à
l'algorithme-des-chats qu'elle n'aurait aucun sens dans une autre situation. De
plus, elle a besoin d'accéder à la variable |livingCats|. C'est donc
une candidate parfaite pour devenir une fonction à l'intérieur d'une
fonction. Quand elle existe à l'intérieur de |findLivingCats|, il est
clair qu'elle n'est pertinente que là et qu'elle a accès aux variables de
sa fonction parente.

Cette solution est en fait plus *grande* que la précédente. Mais elle est
plus propre et j'espère que vous reconnaîtrez qu'elle est plus lisible.

---

Le programme ignore encore un grand nombre d'informations qui sont incluses
dans les mails. Il s'agit des dates de naissance, de mort et des noms
des mères.

Commençons avec les dates : quelle pourrait être la meilleure façon
de stocker une date ? Nous pourrions créer un objet avec ces trois
propriétés,  |year|, |month|, et |day| et stocker ensuite des nombres
à l'intérieur.

> var when = {year: 1980, month: 2, day: 1};

Mais JavaScript fournit déjà une sorte d'objet pour cela.
Un tel objet peut être créé en utilisant le mot-clé _|new|_:

> var when = new Date(1980, 1, 1);
> show(when);

Tout comme la notation avec les accolades et les deux-points que nous avons
déjà vue, |new| est une façon de créer des valeurs d'un objet. Au lieu
de préciser tous les noms de propriétés et les valeurs, une fonction est
utilisée pour créer l'objet. Cela rend possible de définir une sorte de
procédure standard pour créer des objets. Les fonctions comme celle-là
s'appellent _constructeur_s et nous verrons comment les écrire dans \\coo.

Le constructeur  _|Date|_ peut être utilisé de différentes manières

> show(new Date());
> show(new Date(1980, 1, 1));
> show(new Date(2007, 2, 30, 8, 20, 30));

Comme vous pouvez le voir, ces objets peuvent enregistrer l'heure d'un
jour aussi bien qu'une date. Quand aucun argument n'est précisé, un objet
réprésentant l'heure et la date actuelles est créé. Des arguments peuvent
être précisés pour stocker une heure et une date précises. L'ordre des
arguments est l'année, le mois, le jour, l'heure, la minute, la seconde puis
la milliseconde. Les quatre derniers arguments sont optionnels et définis
à 0 s'il ne sont pas précisés.

Pour décrire les mois, on utilise la numérotation de 0 à 11, qui peut
provoquer une confusion. Surtout que les nombres définissant les jours
commencent eux à 1.

---

Le contenu de l'objet |Date|  peut être inspecté avec un nombre de
méthodes |get…|.

> var today = new Date();
> print("Année : ", today.getFullYear(), ", mois : ",
>       today.getMonth(), ", jour : ", today.getDate());
> print("Heure : ", today.getHours(), ", minutes : ",
>       today.getMinutes(), ", secondes: ", today.getSeconds());
> print("Jour de la semaine : ", today.getDay());

Tous ces éléments, expecté la méthode |getDay|, ont une variable |set...|
qui peut être utilisée pour modifier la valeur de l'objet date.

Dans l'objet, une date est représentée par la somme de millisecondes
cumulée depuis le 1er Janvier 1970. Vous pouvez imaginer que c'est un nombre
assez impressionnant.

> var  aujourdhui = new Date();
> show(aujourdhui.getTile());

Une chose très utile à faire avec les dates, c'est de les comparer.

> var chuteDuMur = new Date(1989, 10, 9);
> var premiereGuerreDuGolf = new Date (1990, 6, 2);
> show(chuteDuMur < premiereGuerreDuGolf);
> show(chuteDuMur == chuteDuMur);
> // mais
> show(chuteDuMur == new Date(1989, 10, 9));

Comparer les dates avec |<|, |>|, |<=| et |>=| remplit exactement l'office
que nous voulons en faire. Quand un objet date est comparé avec lui-même,
le résultat est |true|, ce qui est bien également. Mais quand _|==|_ est
utilisé pour comparer un objet date à un autre objet date différent mais
de même valeur, on obtient |false|. Etrange, non ?

Comme précisé plus tôt, |==| retournera la valeur [false| lors de la
comparaison de deux éléments différents, même si ces deux éléments
contiennent les mêmes propriétés. Ceci est un peu maladroit et sujet
à erreur, puisqu''on s'attendrait à ce que |>=| et |==| aient le même
comportement. Pour tester si deux dates sont égales, peut être fait de
cette manière :

> var chuteDuMur1 = new Date(1989, 10, 9),
chuteduMur2 = new Date(1989, 10 ,9);
> show(chuteDuMur1.getTime() == chuteDuMur2.getTime());

---

---

Au-delà de la date et l'heure, l'objet |Date| contient aussi des informations
sur le _fuseau horaire_. Quand il est une heure à Amsterdam, en fonction
de la période de l'année il peut être midi à Londres et sept heures du
matin à New York. De telles heures ne peuvent être rapprochées que si vous
prenez les fuseaux horaires en compte. La fonction _|getTimezoneOffset|_
d'une |Date| peut être utilisée pour trouver de combien de minutes elle
s'éloigne du GMT (Heure du méridien de Greenwich)

> var now = new Date();
> print(now.getTimezoneOffset());

***

] "Décès le 27/04/2006 : Black Leclère"

La partie date est toujours exactement à la mëme place du paragraphe. Comme
c'est pratique. Écrivez une fonction |extractDate| qui prend un tel paragraphe
pour argument, extrait la date et le renvoit sous la forme d'un objet date.

///

> function extractDate(paragraph) {
>   function numberAt(start, length) {
>     return Number(paragraph.slice(start, start + length));
>   }
>   return new Date(numberAt(11, 4), numberAt(8, 2) - 1,
>                   numberAt(5, 2));
> }
>
> show(extractDate("Décès le 27-04-2006 : Black Leclère"));

Cela ne marcherait pas sans les appels à |Number|, mais comme je l'ai
expliqué plus haut, je préfère ne pas utiliser de chaînes comme si elles
étaient des nombres. La fonction interne a été introduite pour éviter
d'avoir à répéter trois fois les parties |Number| et |slice|.

Notez le |-1| pour le numéro du mois. Comme la plupart des gens, tante Émilie
compte les mois à partir de 1, nous devons donc ajuster cette valeur avant
de donner la |Date| au constructeur (le numéro du jour ne relève pas du
même problème, puisque les objets |Date| compte les jours de la façon
humaine habituelle).

Dans le \\cregexp,, nous verrons une façon plus pratique et plus sûre
d'extraire des parties de chaînes qui ont une structure déterminée.

---

Stocker des chats est une opération qui va se dérouler différemment
à partir de maintenant. Au lieu de simplement mettre la valeur |true| sur
l'ensemble, nous stockons un objet avec les informations sur le chat. Lorsqu'un
chat meurt, nous ne le supprimons pas de l'ensemble, nous ajoutons simplement
la propriété |death| à l'objet pour stocker la date à laquelle le pauvre
animal a trépassé.

Cela signifie que nos fonctions |addToSet| et |removeFromSet| sont devenues
inutiles. Quelque chose de comparable est nécessaire, mais il s'agit de
stocker aussi les dates de naissance et par la suite, les noms des mères.

> function catRecord(nom, dateAnniversaire, mere) {
>   return {nom: nom, naissance: dateNaissance, mere: mere};
> }
>
> function addCats(set, noms, dateNaissance, mere) {
>   for (var i = 0; i < noms.length; i++)
>     set[names[i]] = catRecord(noms[i], dateNaissance, mere);
> }
> function deadCats(set, noms, dateDeces) {
>   for (var i = 0; i < noms.length; i++)
>     set[names[i]].deces = dateDeces;
> }

|catRecord| est une fonction distincte pour créer ces objets de stockage. Elle
pourrait être utile dans d'autres situations, telles que la création d'un
objet pour Spot. « Record » (« enregistrement » en français)
est le terme qu'on emploie couramment pour des objets de ce type, qui sont
utilisés pour regrouper un nombre limité de valeurs.

---

Essayons donc maintenant d'extraire les noms des mamans chats qui se trouvent
dans des paragraphes.

] "né le 15/11/2003 (mère : Spot): Croc Blanc"

Voici un moyen d'obtenir cela…

> function extractMother(paragraphe) {
>   var start = paragraphe.indexOf("(mère ") + "(mère ".length;
>   var end = paragraphe.indexOf(")");
>   return paragraphe.slice(start, end);
> }
>
> show(extractMother("Nés le 15/11/2003 (mère Spot): Croc Blanc"));

Notez comment la position de départ a dû être ajustée à la longueur de
|"(mère "|, parce que |indexOf| renvoie la position initiale de la chaîne
et non la finale.

***

Ce que fait |extractMother| peut être exprimé d'une façon plus
générale. Écrivez une fonction |between| qui prend trois arguments,
qui seront tous des chaînes. Elle renverra la partie du premier argument
qui apparaît entre les chaînes fournies par le deuxième et le troisième
argument.

Ainsi, |between("Nés le 15/11/2003 (mère Spot): Croc Blanc", "(mère ",
")")|  donne |"Spot"|.

|between("bu ] boo [ bah ] gzz", "[ ", " ]")| renvoie |"bah"|.

Pour faire marcher ce deuxième test, il peut être utile de savoir qu'on
peut attribuer à |indexOf| un second paramètre facultatif qui précise à
partir de quel point doit commencer la recherche.

///

> function between(string, start, end) {
>   var startAt = string.indexOf(start) + start.length;
>   var endAt = string.indexOf(end, startAt);
>   return string.slice(startAt, endAt);
> }
> show(between("bu ] boo [ bah ] gzz", "[ ", " ]"));

---

Avoir la fonction |between| rend possible l'expression de extractMother de
façon plus simple :

> function extractMother(paragraph) {
>   return between(paragraph, "(mother ", ")");
> }

---

Le nouvel algorithme à chats amélioré ressemble maintenant à ça :

> function findCats() {
>   var mailArchive = retrieveMails();
>   var cats = {"Spot": catRecord("Spot", new Date(1997, 2, 5),
>               "inconnue")};
>
>   function handleParagraph(paragraph) {
>     if (startsWith(paragraph, "Nés le"))
>       addCats(cats, catNames(paragraph), extractDate(paragraph),
>               extractMother(paragraph));
>     else if (startsWith(paragraph, "Décès le"))
>       deadCats(cats, catNames(paragraph), extractDate(paragraph));
>   }
>
>   for (var mail = 0; mail < mailArchive.length; mail++) {
>     var paragraphs = mailArchive[mail].split("\n");
>     for (var i = 0; i < paragraphs.length; i++)
>       handleParagraph(paragraphs[i]);
>   }
>   return cats;
> }
>
> var catData = findCats();

Avoir ces données supplémentaires nous permet d'avoir finalement une idée
plus précise des chats dont parle tante Émilie. Une fonction comme celle-ci
pourrait être utile :

> function formatDate(date) {
>   return date.getDate() + "/" + (date.getMonth() + 1) +
>          "/" + date.getFullYear();
> }
>
> function catInfo(data, name) {
>   if (!(name in data))
>     return "Aucun chat s'appelant " + name + " n'a été trouvé.";
>
>   var cat = data[name];
>   var message = name + ", né le " + formatDate(cat.birth) +
>                 " de la mère " + cat.mother;
>   if ("death" in cat)
>     message += ", mort le " + formatDate(cat.death);
>   return message + ".";
> }
>
> print(catInfo(catData, "Igor Le Gros"));

La première instruction |return| dans |catInfo| est utilisée comme issue de
secours. Si aucune donnée n'est fournie sur un chat particulier, le reste
de la fonction est dépourvu de sens, nous renvoyons donc immédiatement
une valeur qui empêche le reste du code de s'exécuter.

Dans le passé, certains groupes de programmeurs considéraient comme
malsaines les fonctions contenant de multiples instructions |return|. Selon
eux, cela rendait difficile de voir quel code était exécuté et quel code
ne l'était pas.
D'autres techniques, qui seront abordées dans le \\cerror, ont rendu
cet argument plus ou moins obsolète, mais vous pouvez toujours tomber à
l'occasion sur quelqu'un qui critiquera l'utilisation de raccourcis avec
l'instruction |return|.

***

La fonction |formatDate| utilisée par |catInfo| n'ajoute pas de zéro avant
la partie mois et jour quand ce sont des nombres à un seul chiffre. Écrivez
une nouvelle version qui fera cela.

///

> function formatDate(date) {
>   function pad(number) {
>     if (number < 10)
>       return "0" + number;
>     else
>       return number;
>   }
>   return pad(date.getDate()) + "/" + pad(date.getMonth() + 1) +
>              "/" + date.getFullYear();
> }
> print(formatDate(new Date(2000, 0, 1)));

***

Écrivez une fonction |oldestCat| qui, étant donné un objet ayant des
chats comme arguments, renvoie le nom du plus vieux chat vivant.

///

> function oldestCat(data) {
>   var oldest = null;
>
>   for (var name in data) {
>     var cat = data[name];
>     if (!("deces" in cat) &&
>         (oldest == null || oldest.birth > cat.birth))
>       oldest = cat;
>   }
>
>   if (oldest == null)
>     return null;
>   else
>     return oldest.name;
> }
>
> print(oldestCat(catData));

La condition donnée avec la commande |if| pourrait paraître un peu intimidante.
On peut la lire comme : «  ne stocker le chat courant dans la variable
|oldest| que s'il n'est pas mort, et |oldest| est soit |null| soit un chat
qui est né après le chat en cours ».

Notez que cette fonction renvoie |null| quand il n'existe aucun chat vivant
dans |data|. Que devient notre solution dans cas ?

---

Maintenant que vous êtes familiarisé avec les tableaux, je peux vous montrer
quelque chose de lié. Quel que soit le nom d'une fonction, une variable
spéciale nommée _|arguments|_ est ajoutée à l'environnement dans lequel
le corps de la fonction tourne. Cette variable se réfère à un objet qui
ressemble à un tableau. Il a la propriété |0| pour le premier argument,
|1| pour le second, et ainsi de suite pour chaque argument donné par la
fonction. Il possède également une propriété _|length|_.

Cependant, cet objet n'est pas véritablement un tableau, il ne possède pas
de méthodes telles que |push| et il ne met pas pas à jour automatiquement sa
propriété |length| quand vous lui ajoutez quelque chose. Pourquoi n'est-ce
pas le cas ? Je n'ai jamais vraiment compris l'utilité de tout cela, mais
c'est quelque chose dont vous devez avoir connaissance.

> function compteurArgument() {
print("Vous m'avez donné", arguments.length, "arguments.");
> }
> compteurArgument("Mort", "Famine", "Fléau");

Certaines fonctions peuvent prendre un certain nombre d'arguments, comme par
exemple la fonction |print|. Cette fonction particulière opére une boucle sur
les valeurs des |arguments| d'un objet pour en faire quelque chose. Les autres
peuvent prendre des arguments de manière optionnelle qui sont initialisés
à une valeur par défaut sensée si l'utilisateur ne fournit pas de valeur.

> function add(nombre, combien) {
>    if (arguments.length < 2)
>      combien = 1;
>    return nombre + combien ;
> }
>
> show(add(6));
> show(add(6, 4));

***

Étendez la fonction |serie| de l'\\erange pour prendre un second argument,
optionnel. Si un seul argument est donné à la fonction, elle se comporte
comme précédemment et produit une série commençant à 0 jusqu'au nombre
donné. Si deux arguments sont donnés, le premier indique le début de la
série, le second la fin.

///

> function serie(debut, fin) {
>   if (arguments.length < 2) {
>     fin = debut;
>     debut = 0;
>   }
>   var resultat = [];
>   for (var i = debut; i <= fin; i++)
>     resultat.push(i);
>   return resultat;
> }
>
> show(serie(4));
> show(serie(2, 4));

L'argument optionnel ne fonctionne pas exactement comme le premier, dans
l'exemple |add| ci-dessus. Quand il n'est pas précisé, le premier argument
prend le rôle de |fin| et |debut| devient |0|.

***

Vous devez vous rappeler de la ligne de code cité en introduction :

!> print(sum(serie(1, 10)));

Nous avons la fonction |range| maintenant. Tout ce que nous avons besoin
pour faire fonctionner cette ligne est une fonction |sum|. Cette fonction
prend un tableau de nombre en arguments et retourne leur somme. Écrivez-la,
ce devrait être simple.

///

> function sum(numbers) {
>   var total = 0;
>   for (var i = 0; i < numbers.length; i++)
>     total += numbers[i];
>   return total;
> }
>
> print(sum(serie(1, 10)));

---

Le chapitre précédent nous a permis d'étudier les fonctions |Math.max|
et |Math.min|. Avec ce que vous connaissez maintenant, vous pourrez noter
que |max| et |min| sont déjà les propriétés d'un objet enregistré sous
le nom de |Math|. Voici un autre rôle que les objets peuvent jouer :
celui d'entrepôt pour un grand nombre de valeurs liées.

Il y a beaucoup de valeurs dans |Math|, si elles avaient été placées
directement dans l'environnement global,  elles l'auraient, comme on dit,
pollué. Plus il y a de noms utilisés, plus il est probable d'écraser par
accident la valeur d'une variable. Par exemple, il n'est pas incongru de
vouloir nommer une variable |max|.

La plupart des langages vous arrêteront, ou du moins vous alerteront,
quand vous définirez une variable avec un nom déjà utilisé par
l'environnement. Pas JavaScript.

Dans tous les cas, on peut trouver tout un ensemble de fonctions mathématiques
et de constantes dans |Math|. Toutes les fonctions trigonométriques sont
présentes : |cos|, |sin|, |tan|, |acos|, |asin| et |atan|. π et e, qui sont
écrits en capitales (|PI| et |E|), ce qui était à une époque une façon
très à la mode d'indiquer que quelque chose est une constante. |pow| est un
bon moyen de substitution des fonctions |puissance| que nous avons écrites,
il accepte les exposants négatifs et fractionnels. |sqrt| extrait la racine
carrée d'un nombre. |max| et |min| peuvent donner le maximum ou le minimum de
deux valeurs. @_|Math.round|_@_|Math.floor|_@_|Math.ceil|_|round|, |floor|,
et |ceil| vont respectivement arrondir un nombre à l'entier le plus proche,
à l'entier inférieur et supérieur le plus proche.

Il existe un grand nombre d'autres valeurs dans |Math|, mais ce texte est
une introduction, pas une _référence_. Les références sont ce que vous
consultez lorsque vous soupçonnez qu'il existe quelque chose dans un langage,
mais avez besoin de savoir comment ça s'appelle ou comment ça marche au
juste. Malheureusement, il n'existe aucune référence totalement exhaustive
pour le JavaScript. C'est essentiellement parce que sa forme courante est la
résultante d'un processus chaotique pendant lequel différents navigateurs
lui ont ajouté diverses extensions à différentes périodes. Le document
standard ECMA, mentionné dans l'introduction, fournit une solide documentation
du langage de base, mais il est plus ou moins lisible. Pour les choses comme
l'objet |Math| et autres fonctions élémentaires, on peut trouver une bonne
source de référence [ici
http://www.webreference.com/javascript/reference/core_ref/contents.html].
L'ancienne documentation de Netscape, que l'on peut encore trouver sur le
[site de Sun | http://docs.sun.com/source/816-6408-10], peut encore être
utile, mais elle est dépassée et n'est plus complètement correcte.
[NdT] Le site de [Mozilla dédié aux
développeurs|https://developer.mozilla.org/en/JavaScript] regroupe de
nombreuses informations à jour.

---

Vous avez peut-être déjà pensé à un moyen de découvrir ce qui est
disponible avec l'objet |Math| :

> for (var name in Math)
>   print(name);

Mais hélas, rien n'apparaît. De même, quand vous faites ceci :

> for (var name in ["Huey", "Dewey", "Loui"])
>   print(name);

Vous ne voyez que |0|, |1|, et |2|, pas |length|, ni |push|, ou |join|,
qui s'y trouvent pourtant bel et bien. Apparemment, certaines propriétés
des objets sont cachées@_propriétés cachées_. Il y a une bonne raison à
ça : tous les objets ont quelques méthodes, par exemple  _|toString|_
qui convertit l'objet en une sorte de chaîne pertinente, mais vous ne
souhaiterez sûrement pas les voir quand vous êtes par exemple, à la
recherche des chats que vous avez stockés dans l'objet.

Pourquoi les propriétés de |Math| sont-elles cachées ? Ce n'est pas
très clair pour moi. Il y a sûrement quelqu'un qui a voulu en faire un
type d'objet mystérieux.

Toutes les propriétés que vos programmes ajoutent aux objets sont
visibles. Il n'y a pas moyen de les cacher, ce qui est regrettable parce que,
comme vous le verrez dans le \\coo, il serait sympa d'ajouter des méthodes
aux objets sans avoir à les rendre visibles dans des boucles |for|/|in|.

---

@_propriétés en lecture seule_Certaines propriétés sont en lecture seule,
vous pouvez récupérer leur valeur mais pas la modifier. Par exemple,
les propriétés d'une valeur de chaîne sont toutes en lecture seule.

> var array = ["Ciel", "Terre", "Homme"];
> array.length = 2;
> show(array);

===========================
Gestion des erreurs / error
===========================

Écrire des programmes qui fonctionnent quand tout se passe comme prévu,
c'est un bon point de départ. Mais vous arranger pour que vos programmes
se comportent de façon acceptable dans des circonstances inattendues,
cela devient un véritable défi.

Les situations problématiques qu'un programme peut rencontrer se classent en
deux catégories : les erreurs du développeur et les réels problèmes. Si
quelqu'un oublie de passer un argument requis à une fonction, c'est un
exemple de la première catégorie. En revanche, si un programme demande à
l'utilisateur de saisir un nom et qu'il obtient en retour une chaîne vide,
il s'agit d'un problème que le développeur ne peut pas empêcher.

En général, on traite les erreurs du développeur en les cherchant et en
les corrigeant, et pour les erreurs réelles, en faisant en sorte que le
code les vérifie et effectue l'action appropriée pour y remédier (par
exemple en redemandant le nom de l'utilisateur), ou au moins en échouant
de façon bien définie et propre.

---

Il est important de décider de quelle catégorie un certain problème peut
relever. Par exemple, reprenons notre ancienne fonction |puissance| :

> function puissance(base, exponent) {
>   var result = 1;
>   for (var count = 0; count < exponent; count++)
>     result *= base;
>   return result;
> }

Quand un geek essaie d'appeler |puissance("Lapin", 4)|, c'est de toute
évidence une erreur du développeur, mais qu'en est-il de |power(9,
0.5)| ? La fonction ne sait pas manipuler des exposant sous forme de
fraction, mais mathématiquement parlant, élever un nombre à la puissance
1/2 est parfaitement raisonnable (_|Math.pow|_ sait le faire). Dans des
situations où le type de saisie que peut accepter une fonction n'est pas
totalement clair, il est préférable de préciser explicitement le type
d'arguments acceptables dans un commentaire.

---

Si une fonction rencontre un problème qu'elle ne peut résoudre par
elle-même, que doit-elle faire ? Dans le \\cdata, nous avons écrit la
fonction |between| :

> function between(string, start, end) {
>   var startAt = string.indexOf(start) + start.length;
>   var endAt = string.indexOf(end, startAt);
>   return string.slice(startAt, endAt);
> }

Si le |start| et le |end| donnés n'apparaissent pas dans la chaîne, |indexOf|
renverra |-1| et cette version de |between| retournera des absurdités :
|between("Ta mère !", "{-", "-}")| renvoie |"a mère"|.

Quand le programme s’exécute et que la fonction est appelée ainsi,
le code qui l'a appelé obtiendra une chaîne, comme prévu, et continuera
joyeusement à la manipuler. Mais la valeur est erronée, donc quel que soit
le résultat obtenu, il sera faux. Et si vous êtes malchanceux, cette erreur
ne provoquera de problème qu'après avoir été passée à une vingtaine
d'autres fonctions. Dans des cas comme celui-ci, il est extrêmement difficile
de trouver où le problème a débuté.

Dans certains cas, vous ne serez absolument pas concerné par ce genre de
problème et vous n'aurez que faire du mauvais comportement de la fonction
lorsqu'elle reçoit un mauvais type d'argument. Par exemple, si vous êtes
sûr qu'une fonction ne sera appelée qu'à quelques endroits et que vous
pouvez prouver que ces endroits ne fournissent que le bon type d'argument,
ça ne vaut alors généralement pas le coup de faire grossir la fonction
et de la rendre plus moche pour qu'elle puisse traiter des cas problématiques.

Mais la plupart du temps, les fonctions qui échouent « silencieusement »
sont difficiles à utiliser, et même dangereuses. Que se passe-t-il si le
code appelant |between| veut savoir si tout s'est bien passé ? Sur le
moment, il ne peut le dire, sauf à refaire tout le travail qu'a effectué
|between| et à vérifier le résultat de |between| par rapport au sien. Ce
qui n'est pas bien. Une solution serait de faire renvoyer par |between|
une valeur spéciale telle que |false| ou [undefined| quand elle échoue.

> function between(string, start, end) {
>   var startAt = string.indexOf(start);
>   if (startAt == -1)
>     return undefined;
>   startAt += start.length;
>   var endAt = string.indexOf(end, startAt);
>   if (endAt == -1)
>     return undefined;
>
>   return string.slice(startAt, endAt);
> }

Vous pouvez voir que les vérifications d'erreurs ne rendent généralement
pas les fonctions plus jolies. Mais maintenant, le code qui appelle |between|
peut faire quelque chose comme :

> var input = prompt("Dites-moi quelque chose", "");
> var parenthesized = between(input, "(", ")");
> if (parenthesized != undefined)
>   print("Vous avez mis entre parenthèses '", parenthesized, "'.");

---

Dans beaucoup de cas, renvoyer une valeur spéciale est une façon tout à
fait appropriée pour indiquer une erreur. Il y a malheureusement un revers à
la médaille. D'abord, que se passe-t-il si la fonction peut déjà renvoyer
toutes sortes de valeurs possibles ? Par exemple, prenons cette fonction
qui récupère le dernier élément d'un tableau :

> function lastElement(array) {
>   if (array.length > 0)
>     return array[array.length - 1];
>   else
>     return undefined;
> }
>
> show(lastElement([1, 2, undefined]));

Le tableau avait-il un dernier élément ? En regardant la valeur que
renvoie |lastElement|, c'est impossible à dire.

Le second problème quand on renvoie des valeurs spéciales, c'est que
cela peut conduire à créer pas mal de bazar. Si une partie de code
appelle |between| dix fois, elle doit vérifier dix fois si |undefined|
a été retourné. De même, si une fonction appelle |between|, mais n'a
pas de stratégie gérer un éventuel échec, elle devra vérifier la valeur
renvoyée par |between|, et si c'est |undefined|, cette fonction peut alors
renvoyer |undefined| ou une autre valeur spéciale à sa fonction appelante,
qui à son tour vérifiera cette valeur.

Des fois, quand quelque chose de bizarre se passe, il serait pratique de juste
arrêter ce que l'on est en train de faire, et de revenir immédiatement à
un endroit où le problème peut être réglé.

Nous avons de la chance. Beaucoup de langages de programmation fournissent
de tels mécanismes. C'est ce qu'on appelle généralement _la gestion
des exceptions_.

---

La théorie derrière la gestion des exceptions fonctionne ainsi : il est
possible pour le code de _lever_ (ou _jeter_) une _exception_, qui est une
valeur. Quand on lève une exception, cela ressemble parfois à un retour de
fonction boosté aux stéroïdes : on ne sort pas simplement de la fonction
en cours, mais aussi des fonctions appellantes, en remontant à la fonction
appellante de plus haut niveau qui a initié l'exécution actuelle. Cela
s'appelle _dépiler_. Vous vous rappelez peut-être que la _pile_ des appels
de fonction qui avait été abordée au \\cfunctions. Une exception descend
dans cette pile, en renvoyant tous les contextes des appels qu'elle rencontre.

Si elles descendaient sans s'arrêter jusqu'au bas de la pile, les exceptions
ne seraient pas d'un grand intérêt, elles fourniraient juste un moyen
original de détruire le programme. Heureusement, il est possible de dresser
des obstacles aux exceptions le long de la pile. Ceux-ci « _attrapent_ »
l'exception quand elle descend, et ils peuvent s'en charger, après quoi
le programme continue de fonctionner normalement à partir du point où
l'exception a été attrapée.

Un exemple :

> function lastElement(array) {
>   if (array.length > 0)
>     return array[array.length - 1];
>   else
>     throw "Impossible de prendre le dernier élément d'un tableau vide.";
> }
>
> function lastElementPlusTen(array) {
>   return lastElement(array) + 10;
> }
>
> try {
>   print(lastElementPlusTen([]));
> }
> catch (error) {
>   print("Une erreur est survenue : ", error);
> }

_|throw|_ est le mot-clé qui est utilisé pour lever l'exception. Le mot-clé
_|try|_ lève un obstacle pour les exceptions : quand une exception est
levée dans le code du bloc suivant ce _|try|_, le bloc _|catch|_ sera
exécuté. La variable nommée entre parenthèses après le mot |catch|
est le nom donné à la valeur d'exception à l'intérieur du bloc.

On remarque que la fonction |LastelementPlusTen| ignore complètement la
possibilité que |LastElement| puisse ne pas fonctionner. C'est là le grand
avantage des exceptions, un code pour s'occuper de l'erreur n'est nécessaire
qu'au moment où l'erreur survient, et à l'endroit où on s'en occupe. Les
fonctions sur le chemin peuvent tout ignorer à ce sujet.

Enfin, presque.

---

Réfléchissez un instant à ceci : une fonction |processThing| veut
déclarer une variable globale |currentThing| pour pointer vers quelque
chose de spécifique pendant que son corps exécute, de manière à ce que
d'autres fonctions puissent également y avoir accès. Normalement, vous
passeriez simplement cette chose comme un argument, mais imaginons l'espace
d'un instant que ce n'est pas possible en pratique. Quand la fonction se
termine, |currentThing| devrait être redéfinie avec une valeur |null|.

> var currentThing = null;
>
> function processThing(thing) {
>   if (currentThing != null)
>     throw "Oh non ! Nous sommes déjà en train d'exécuter quelque chose !";
>
>   currentThing = thing;
>   /* do complicated processing… */
>   currentThing = null;
> }

Mais que ce se passerait-il si cette opération compliquée lève une exception
? Dans ce cas, l'appel à |processThing| sera rejeté en dehors de la pile par
l'exception, et |currentThing| n'aura pas de valeur redéfinie comme |null|.

Les instructions |try| peuvent aussi être suivies par un mot-clé _|finally|_,
ce qui veut dire « quoi qu'il arrive, exécutez ce code après avoir
essayé d'exécuter ce code dans un bloc |try| ». Si une fonction doit
nettoyer quelque chose, le code qui effectue ce nettoyage doit en général
être inséré dans un bloc |finally| :

> function processThing(thing) {
>   if (currentThing != null)
>     throw "Oh non ! Nous sommes déjà en train d'exécuter quelque chose !";
>
>   currentThing = thing;
>   try {
>     /* do complicated processing... */
>   }
>   finally {
>     currentThing = null;
>   }
> }

---

Beaucoup d'erreurs de programmation obligent l'environnement JavaScript à
lever des exceptions. Par exemple :

> try {
>   print(Sasquatch);
> }
> catch (error) {
>   print("A: " + error.message);
> }

Dans des cas comme celui-là, des objets spéciaux de type erreur sont
levés. Ils ont toujours une propriété |message| contenant une description
du problème. Vous pouvez lever des objets similaires en utilisant le mot-clé
|new| et le constructeur _|error|_ :

> throw new Error("Au feu !");

---

Quand une exception descend tout en bas de la pile sans être attraée, elle
est prise en charge par l'environnement. Ce que cela signifie diffère selon
les différents navigateurs, quelquefois une description de l'erreur est
écrite sous la forme d'une entrée de  journal, d'autres fois une fenêtre
décrivant l'erreur apparaît.

Les erreurs générées par le code entré dans la console sur cette page
sont toujours attrapée par la console, et sont affichées avec les autres
sorties de la console.

---

La plupart des programmeurs considèrent les exceptions uniquement comme un
mécanisme de gestion des erreurs. Par essence, pourtant, elles représentent
juste une autre manière d'influer sur le contrôle du flux d'un programme. Par
exemple, elles peuvent être utilisées comme une sorte d'instruction |break|
dans une fonction récursive. Voici une fonction un peu bizarre qui détermine
si un objet, ainsi que les autres objets stockés à l'intérieur, contiennent
au moins sept valeurs |true| :

> var FoundSeven = {};
>
> function hasSevenTruths(object) {
>   var counted = 0;
>
>   function count(object) {
>     for (var name in object) {
>       if (object[name] === true) {
>         counted++;
>         if (counted == 7)
>           throw FoundSeven;
>       }
>       else if (typeof object[name] == "object") {
>         count(object[name]);
>       }
>     }
>   }
>
>   try {
>     count(object);
>     return false;
>   }
>   catch (exception) {
>     if (exception != FoundSeven)
>       throw exception;
>     return true;
>   }
> }

La fonction interne |count| est appelée récursivement pour chaque objet qui
fait partie d'un argument. Quand la variable |counted| atteint sept, il n'y
a aucun intérêt à continuer de compter, mais se contenter de remonter de
l'appel courant à |count| ne va pas nécessairement arrêter l'énumération,
comme il pourrait y avoir plusieurs appels derrière. Donc ce que l'on fait
c'est juste lever une exception, ce qui obligera le contrôleur à rejeter
tout appel, et à se rendre au bloc |catch|.

Mais se contenter de retourner |true| dans le cas d'une exception n'est
pas correct. Quelque chose peut mal se passer, donc on vérifie d'abord si
l'exception est l'objet |FoundSeven|, créé spécifiquement dans ce but. Si
ce n'est pas le cas, ce bloc |catch| ne sait pas comment s'en occuper,
donc il la lève encore.

On a ici un modèle qui est également habituel lorsqu'on s'occupe de
conditions d'erreur : vous devez vous assurez que votre bloc |catch|
s'occupe seulement des exceptions qu'il sait traiter. Lever des exceptions de
type chaîne de caractères, comme certains exemples de ce chapitre le font,
est rarement une bonne idée, car cela rend difficile de reconnaître le type
de l'exception. Une meilleure idée consiste à utiliser des valeurs uniques,
comme l'objet |FoundSeven|, ou d'introduire un nouveau type d'objets, comme
cela a été décrit dans le \\coo.

================================
Programmation fonctionnelle / fp
================================

Au fur et à mesure que les programmes prennent de l'ampleur, ils deviennent
plus complexes et plus durs à comprendre. Nous nous considérons tous comme
étant plutôt intelligents, bien sûr, mais nous ne sommes que des êtres
humains et même une petite dose de chaos peut nous laisser perplexes. Et
ensuite cela devient infernal. Travailler sur quelque chose que vous ne
maîtrisez pas vraiment, c'est un peu comme couper des fils au hasard sur
une de ces bombes à retardement que vous voyez dans les films. Si vous
avez de la chance, vous couperez le bon, particulièrement si vous êtes
le héros du film et que vous prenez une attitude héroïque, mais il y a
toujours une possibilité de tout faire sauter.

Je vous le concède, la plupart du temps, casser un programme ne va pas
causer une grosse explosion. Mais quand un programme qui a été trifouillé
par quelqu'un d'ignorant, dégénère en un ramassis d'erreurs, remettre de
l'ordre dans le code est un travail de longue haleine, parfois il est aussi
simple de recommencer depuis le début.

@_abstraction_Ainsi, le développeur recherche toujours les moyens de faire
un code aussi simple que possible. Une manière importante d'y arriver c'est
de rendre le code plus abstrait. Quand on fait du code pour un programme, on
se perd très facilement dans des petits détails. Vous butez sur un petit
problème, vous vous penchez dessus et puis vous vous occupez du problème
d'après et ainsi de suite. Au final, on lit le code à la façon d'une
recette de grand-mère.

| Oui, mon cher, pour faire de la soupe aux pois, vous aurez besoin de
| petits pois, de type sec. Et vous devez les laisser tremper pour au
| moins une nuit, ou vous devrez les faire cuire pendant des heures.
| Je me souviens une fois quand mon idiot de fils a essayé de faire
| de la soupe de pois. Me croirez-vous si je vous dis qu'il n'a pas
| fait tremper ses pois ? Nous nous sommes presque cassés les dents,
| tout le monde. Bref, quand vous aurez trempé les pois, et vous en
| voulez à peu près une tasse par personne, faites attention car ils
| prendront un peu de volume quand ils seront trempés, donc si vous ne
| prenez pas garde, ils déborderont du contenant que vous avez choisi
| pour ce faire, faites attention également d'utiliser beaucoup d'eau.
| Mais comme je vous l'ai dit, il en faut à peu près une tasse et
| quand ils sont trempés, vous les faites cuire avec 4 tasses d'eau
| pour une tasse de pois. Laissez les mijoter pendant deux heures,
| ce qui sous-entend que vous mettiez un couvercle et que vous
| chauffiez à peine, et ensuite ajoutez des oignons coupés en dés,
| des tiges de céleri, peut-être une ou deux carottes et un peu de
| jambon. Laissez encore cuire pendant quelques minutes et après
| c'est prêt à être servi.

Une autre façons de décrire la recette :

| Ingrédients par personne : une tasse de petits pois, un oignon
| coupé en morceaux, une demie carotte, une tige de céleri et
| éventuellement du jambon.
|
| Faites tremper les pois une nuit, faites les mijoter pendant deux
| heures dans 4 tasses d'eau (par personne), ajoutez les légumes et
| le jambon, faites cuire pendant dix minutes supplémentaires.

C'est plus court, mais si vous ne savez pas comment faire tremper les pois,
vous raterez sûrement et les ferez tremper dans trop peu d'eau. Mais on peut
rechercher comment tremper les pois, et c'est ça la clé. Si vous partez du
principe que le public a des connaissances de base, vous pouvez recourir à
un langage pour mentionner des concepts plus larges et vous exprimez d'une
manière plus concise et plus claire. C'est plus ou moins ce que l'on veut
dire quand on parle d'abstraction.

En quoi est-ce que cette recette tirée par les cheveux a un lien avec
la programmation ? Et bien, évidemment, la recette est un programme. De
surcroît, la connaissance minimale que le cuisinier est supposé avoir
correspond aux fonctions et autres concepts qui sont accessibles aux
codeurs. Si vous vous rappelez de l'introduction à ce livre, des choses
telles que |while| rendent la construction de boucles plus faciles. Dans le
\\cdata, nous avons écrit des fonctions simples afin d'avoir des fonctions
plus courtes et plus directes. De tels outils, dont certains sont fournis par
le langage lui-même et d'autres conçus par le programmeur, sont utilisés
de manière à réduire le nombre de détails inutiles dans le reste du
programme. Ce qui rend le programme plus abordable pour travailler dessus.

---

La _programmation fonctionnelle_, qui est le sujet qui nous intéresse dans
ce chapitre, produit des abstractions en combinant de manière astucieuse
des fonctions. Un codeur équipé d'un répertoire de fonctions fondamentales
et, plus important, maîtrisant les manières de les utiliser est bien plus
efficace que quelqu'un qui commence à partir de zéro. Malheureusement, un
environnement JavaScript de base ne fournit que peu de fonctions essentielles,
donc nous devons les écrire nous mêmes, ou, ce qui est souvent préférable,
utiliser le code de quelqu'un d'autre (plus de détails dans le \\cmodularity).

Il y a d'autres approches plus populaires de l'abstraction, particulièrement
la programmation orientée objet, qui est le sujet du \\coo.

Il y a un détail fâcheux, si vous avez un peu de goût, qui doit commencer à
vous embêter, c'est la répétition incessante de boucles |for| dans certaines
matrices : |for (var i = 0; i < something.length; i++) ...|. Est-ce qu'on
peut en faire une abstraction ?

Le problème, c'est que si beaucoup de fonctions prennent juste des valeurs,
les combinent et donnent un résultat, une telle boucle contient un bout
de code qu'elle doit exécuter. Il est facile d'écrire une fonction qui
s'occupe d'une matrice et affiche chaque élément :

> function printArray(array) {
>   for (var i = 0; i < array.length; i++)
>     print(array[i]);
> }

Mais qu'est-ce qu'on fait si on veut faire autre chose qu'afficher ? Puisque
« faire quelque chose » peut être représenté par une fonction, et que
les fonctions sont aussi des valeurs, on peut fournir notre action comme
une valeur de type fonction :

> function forEach(array, action) {
>   for (var i = 0; i < array.length; i++)
>     action(array[i]);
> }
>
> forEach(["Wampeter", "Foma", "Granfalloon"], print);

Et en utilisant une fonction anonyme, quelque chose comme une boucle |for|
peut être écrite avec moins de détails inutiles.

> function sum(numbers) {
>   var total = 0;
>   forEach(numbers, function (number) {
>      total += number;
>   });
>   return total;
> }
> show(sum([1, 10, 100]));

Remarquez que la variable |total| est visible à l'intérieur de la fonction
anonyme, à cause des règles de portée des variables. Remarquez également
que cette version n'est pas vraiment plus courte que celle avec une boucle
|for| et nécessite l'écriture peu commode |});| à sa fin : l'accolade
ferme le corps de la fonction anonyme, la parenthèse ferme l'appel à la
fonction _|forEach|_ et le point virgule est nécessaire car cet appel est
une instruction.

Vous obtenez une variable liée à l'élément en cours dans le tableau,
|number|, aussi vous n'avez plus besoin d'utiliser |numbers[i]|. Et quand ce
tableau est créé par l'évaluation d'une expression quelconque, il n'y a
pas besoin de le stocker dans une variable car cette expression peut être
passé à |forEach| directement.

Le programme sur les chats dans le \\cdata contient le morceau de code suivant:

!> var paragraphs = mailArchive[mail].split("\n");
!> for (var i = 0; i < paragraphs.length; i++)
!>   handleParagraph(paragraphs[i]);

Il peut maintenant être écrit de la façon suivante :

!>  forEach(mailArchive[mail].split("\n"), handleParagraph);

Au final, une construction plus abstraite (ou « de plus haut niveau »)
correspond à plus d'informations et à moins de bruits parasites : Le
code dans la fonction |sum| se lit « *pour chaque nombre dans la liste
des nombres, ajouter ce nombre au total* », plutôt que : « *il y a une
variable qui commence à 0, et elle compte un par un jusqu'à atteindre le
nombre d'élément d'un tableau de nombres et à chaque valeur de cette
variable, nous examinons l'élément correspondant dans ce tableau et
l'ajoutons au total* ».

---

Ce que fait |forEach| est de prendre un algorithme, ici « parcourir un
tableau » et de rendre celui-ci abstrait. Les « trous » dans cet algorithme
(ici : que faire pour chacun des éléments du tableau), sont comblés
par des fonctions passées à la fonction algorithme.

Les fonctions qui opèrent sur d'autres fonctions sont appelées _fonctions
d'ordre supérieur_. En opérant sur d'autres fonctions, elles peuvent décrire
des actions à un niveau supérieur. La fonction |makeAddFunction| dans le
\\cfunctions est aussi une fonction d'ordre supérieur. Au lieu de prendre
une valeur de fonction comme argument, elle construit une nouvelle fonction.

Les fonctions d'ordre supérieur peuvent être utilisées pour généraliser
de nombreux algorithmes que des fonctions classiques ne peuvent pas facilement
décrire. Quand vous avez à votre disposition de telles fonctions, elles
peuvent vous aider à concevoir votre code avec une plus grande clarté :
au lieu d'une combinaison complexe de variables et de boucles, vous pouvez
décomposer les algorithmes en algorithmes plus fondamentaux, qui sont
appelés par leur nom et ne doivent pas être ré-écrits sans cesse.

Etre en mesure d'écrire *ce que* nous voulons faire au lieu de *comment*
nous le faisons, c'est travailler à un niveau d'abstraction supérieur. En
pratique, cela implique un code plus concis, plus clair et plus agréable
à lire.

---

Une autre catégorie utile de fonctions d'ordre supérieur *modifie* la
fonction qui lui est fournie :

> function negate(func) {
>   return function(x) {
>     return !func(x);
>   };
> }
> var isNotNaN = negate(isNaN);
> show(isNotNaN(NaN));

La fonction renvoyée par la fonction |negate| reçoit un argument qu'elle
fournit à la fonction initiale |func| et inverse son résultat. Mais si la
fonction que vous voulez inverser reçoit plus d'un argument ? Vous pouvez
accéder à n'importe quels arguments passés à une fonction à l'aide du
tableau |arguments|, mais comment appeler une fonction quand vous ne savez
pas combien d'arguments vous avez ?

Les fonctions ont une méthode nommée _|apply|_, utilisée dans les situations
de ce type. Elle prend deux arguments. Le rôle du premier argument sera
détaillé dans le \\coo, pour le moment nous utiliserons |null| pour cet
argument. Le second argument est un tableau qui contient tous les arguments
devant s'appliquer à la fonction.

> show(Math.min.apply(null, [5, 6]));
>
> function negate(func) {
>   return function() {
>     return !func.apply(null, arguments);
>   };
> }

Malheureusement, dans le navigateur Internet Explorer, différentes
fonctions comme |alert|, ne sont pas *vraiment* des fonctions... ni quoi
que ce soit. Elles indiquent un type |"object"| quand s'appliquent sur elles
l'opérateur |typeof| et n'ont pas de méthode |apply|. Vos propres fonctions
n'ont pas cet inconvénient, ce sont toujours de vraies fonctions.

---

Jetons un œil maintenant à quelques algorithmes plus simples qui sont
reliés aux tableaux. La fonction |sum| est en fait une variante d'un
algorithme qui est habituellement appelé _|reduce|_ ou |fold| :

> function reduce(combine, base, array) {
>   forEach(array, function (element) {
>     base = combine(base, element);
>   });
>   return base;
> }
>
> function add(a, b) {
>   return a + b;
> }
>
> function sum(numbers) {
>   return reduce(add, 0, numbers);
> }

|reduce| convertit un tableau en une seule valeur en ayant recours de
manière répétée à une fonction qui combine un élément du tableau
avec une valeur de base. C'est exactement ce que fait la fonction |sum|,
donc elle peut être raccourcie par l'utilisation de |reduce|... sauf que
l'addition est un opérateur et non une fonction dans JavaScript, donc on
doit d'abord la mettre dans une fonction.

La raison pour laquelle |reduce| accepte cette fonction comme premier
argument et non comme dernier (comme dans |forEach|) c'est en partie par
tradition (d'autres langages ont ce fonctionnement) et en partie parce que
cela permet une astuce particulière, dont on discutera plus tard à la fin
de ce chapitre. Cela veut dire que lorsque l'on appelle |reduce|, écrire la
fonction de réduction comme une fonction anonyme semble un peu bizarre. Car
maintenant les arguments viennent après la fonction et on perd totalement
la ressemblance avec un bloc |for| normal.

***

Écrivez une fonction |countZeroes| qui prend un tableau de nombres en argument
et qui renvoie le nombre de zéro qui sont rencontrés. Utilisez |reduce|.

Puis, écrivez une fonction |count| de plus haut niveau qui accepte un tableau
et une fonction de tests en tant qu'arguments, et qui donne en retour le
nombre d'éléments dans le tableau pour lesquels la fonction de test a
renvoyé |true|.
Intégrez de nouveau |countZeroes| en utilisant cette fonction.

///

> function countZeroes(array) {
>   function counter(total, element) {
>     return total + (element === 0 ? 1 : 0);
>   }
>   return reduce(counter, 0, array);
> }

@_|?:|_ La partie bizarre, celle avec le point d'interrogation et les
deux points, utilise un nouvel opérateur. Dans le \\cbasics, nous avons
vu les opérateurs unaires et binaires. Celui-ci est ternaire : il agit
sur trois valeurs. Son fonctionnement ressemble à celui de |if|/|else|,
sauf que là où |if| exécute de manière conditionnelle des instructions,
celui-ci choisit ses expressions en fonction d'une condition. La première
partie avant le point d'interrogation est la condition. Si cette condition
est |true|, l'expression après le point d'interrogation est choisie, ici
|1|. Si c'est |false|, la partie après la virgule, ici |0|, est choisie.

L'utilisation de cet opérateur peut raccourcir efficacement des portions de
code. Quand les expressions à l'intérieur deviennent vraiment énormes, ou
que vous devez prendre plus de décisions à l'intérieur des portions pour
les conditions, la simple utilisation de |if| et |else| est habituellement
plus lisible.

Voici la solution qui utilise une fonction |count|, avec une fonction qui
inclut des tests d'égalité afin d'avoir au final une fonction |countZeroes|
encore plus courte.

> function count(test, array) {
>   return reduce(function(total, element) {
>     return total + (test(element) ? 1 : 0);
>   }, 0, array);
> }
>
> function equals(x) {
>   return function(element) {return x === element;};
> }
>
> function countZeroes(array) {
>   return count(equals(0), array);
> }

---

Un autre « algorithme fondamental » généralement utile en lien avec
les tableaux porte le nom de _|map|_. Il balaye un tableau, en exécutant une
fonction sur chaque élément, tout comme |forEach|. Mais au lieu de rejeter
les valeurs de retour de la fonction, il construit un nouveau tableau pour
chacune de ses valeurs.

> function map(func, array) {
>   var result = [];
>   forEach(array, function (element) {
>     result.push(func(element));
>   });
>   return result;
> }
>
> show(map(Math.round, [0.01, 2, 9.89, Math.PI]));

On remarque que le premier argument est appelé |func|, pas |function|. En
effet, |function| est un mot-clé et n'est par conséquent pas un nom de
variable recevable.

---

Il était une fois un ermite vivant dans les forêts reculées des montagnes
de Transylvanie. La plupart du temps, il ne faisait que se promener autour
de sa montagne pour parler aux arbres et rigoler avec les oiseaux. Mais de
temps en temps, quand la pluie torrentielle s'abattait sur sa petite hutte
et que le vent rugissant le faisait sentir intolérablement trop petit,
l'ermite ressentait le besoin pressant d'écrire quelque chose, il voulait
coucher ses pensées sur du papier, là où elles pourraient peut-être
devenir beaucoup plus grandes que lui.

Après avoir échoué misérablement dans ses tentatives d'écrire de la
poésie, de la fiction, de la philosophie, l'ermite décida finalement
d'écrire un livre technique. Dans sa jeunesse, il avait fait de la
programmation et il pensa que s'il pouvait juste écrire un bon livre sur
ce sujet, la célébrité et la reconnaissance arriveraient sans doute après.

Donc il écrivit. D'abord il utilisa des morceaux d'écorce d'arbre, mais
il s'avéra que ce n'était pas pratique. Il descendit au village le plus
proche, et s'acheta un ordinateur portable. Après quelques chapitres,
il réalisa qu'il voulait convertir son livre au format HTML, afin de le
télécharger vers sa page personnelle en ligne...

---

Est-ce que vous connaissez le HTML ? C'est la méthode utilisée pour ajouter
du formattage sur les pages des sites web et on l'utilisera de temps en temps
dans ce livre, donc ce serait bien si vous saviez comment cela fonctionne,
au moins de manière générale. Si vous êtes un bon étudiant, vous
pourriez rechercher sur internet une introduction au HTML maintenant et
revenir quand vous l'aurez lu. La plupart d'entre vous sont sans doute des
étudiants médiocres, donc je vais juste donner une petite explication et
j'espère que ce sera suffisant.

_HTML_ veut dire « HyperText Mark-up Language » (Langage à Balise
Hyper Texte). Un document HTML est entièrement en texte. Parce qu'il doit
être capable d'exprimer la structure de ce texte et de spécifier quelle
donnée du texte est un titre, quelle partie du texte est en violet et
ainsi de suite, quelques caractères ont un sens spécial, un peu comme les
antislash (\) dans les chaînes Javascript. Les signes « inférieur »
et « supérieur » sont utilisés pour créer des « _balise_s »
(NdT: ou tags). Une balise apporte de l'information supplémentaire sur le
document. Elle peut fonctionner de manière autonome par exemple pour indiquer
où doit apparaître une image sur la page, ou elle peut contenir du texte et
d'autres balises, par exemple pour marquer le début et la fin des paragraphes.

Certaines balises sont obligatoires, un document HTML intégral doit toujours
tenir entre deux balises |html|. Voici un example d'un document HTML :

] <html>
]   <head>
]     <title>Une citation</title>
]   </head>
]   <body>
]     <h1>Une citation</h1>
]     <blockquote>
]       <p>La connexion entre le langage dans lequel nous
] pensons/programmons et les problèmes et solutions que nous pouvons
] imaginer est très proche. Pour cette raison, restreindre les
] capacités du langage dans l'intention d'éliminer les erreurs des
] programmeurs est au mieux dangereuse.</p>
]       <p>-- Bjarne Stroustrup</p>
]     </blockquote>
]     <p>M. Stroustrup est l'inventeur du langage de programmation
] C++, mais il est malgré tout une personne des plus perspicaces.</p>
]     <p>Aussi, voici une photo d'une autruche:</p>
]     <img src="img/autruche.png"/>
]   </body>
] </html>

Des éléments qui contiennent du texte ou d'autres balises sont
d'abord ouverts avec |<tagname>|, et après ils sont terminés par
|</tagname>|. L'élément |html| contient toujours deux enfants : |head|
et |body|. Le premier contient des informations *sur* le document, le second
contient le document en lui-même.

La plupart des noms de balise sont des abbréviations cryptiques. |h1| veut
dire « heading 1 » (titre 1), le plus gros titre qu'il y ait. Il y a
aussi |h2| jusqu'à |h6| pour des titres de plus en plus petits. |p| veut
dire « paragraphe », et |img| veut dire « image ». L'élément
|img| ne contient pas de texte ou de balise, mais il contient une
information supplémentaire (|src="img/autruche.png"|) qui est appelée
un « _attribut_ ». Dans ce cas, il contient une information sur le
fichier image qui devrait être affichée ici.

Parce que |<| et |>| ont un sens spécial dans les documents HTML,
ils ne peuvent être écrits directement dans le texte du document. Si
vous voulez dire « 5 < 10 » dans un document HTML, vous devez
écrire « |5 &lt; 10| », où « |lt| » veut dire « moins
que ». « |&gt;| » est utilisé pour « |>| » et parce que ces
codes donnent aussi à l'esperluette un sens spécial, un simple « |&| »
est écrit « |&amp;| ».

Maintenant, ce ne sont que les bases de l'HTML, mais elles devraient être
suffisantes pour pouvoir suivre les explications dans ce chapitre, ainsi que
les chapitres suivants qui traitent des documents HTML, sans trop se perdre
en chemin.

---

La console JavaScript a une fonction |viewHTML| qui peut être utilisée
pour voir des documents HTML. J'ai stocké le document de l'exemple ci-dessus
dans |stroustrupQuote|, on peut donc le voir en exécutant ce code :

> viewHTML(stroustrupQuote);

Si vous avez un genre de bloqueur de fenêtres pop-up installé ou intégré
dans votre navigateur, il interférera probablement avec |viewHTML|, qui
essayera de montrer le document HTML dans une nouvelle fenêtre ou un nouvel
onglet. Essayez de configurer votre bloqueur pour autoriser les pop-ups de
ce site.

---

Donc, pour en revenir à notre histoire, l'ermite voulait avoir son livre au
format HTML. D'abord il a juste écrit toutes les balises directement dans
le manuscrit, mais taper tous ces signes inférieur et supérieur lui ont
donné mal aux doigts à la fin et il oubliait sans arrêt d'écrire |&amp;|
quand il avait besoin d'un |&|. Celui lui donna mal à la tête. Ensuite il
essaya d'écrire son livre dans Microsoft Word et de le sauver en HTML. Mais
le HTML qui était produit était quinze fois plus gros et plus compliqué
que ce qu'il devait être. Et en plus Microsoft Word lui donnait mal au crâne.

La solution sur laquelle il s'arrêta était finalement celle-ci : il
écrirait ce livre en texte simple, en suivant quelques règles simples
pour la façon dont les paragraphes devraient être séparés et l'aspect
que devrait avoir les titres. Puis il écrirait un programme pour convertir
le texte en HTML précisément comme il le souhaitait.

Les règles sont celles-ci :

 1. Les paragraphes sont séparés par des lignes vides.
 2. Un paragraphe qui commence par le symbole « % » est un titre. Plus il y a de symboles « % », plus le titre est petit.
 3. À l'intérieur des paragraphes, des morceaux de texte peuvent être mis en emphase en les encadrant par des astérisques.
 4. Les notes de bas de page sont entre accolades.

---

Après qu'il ait lutté durement avec son livre pendant six mois, l'ermite
avait seulement finit quelques paragraphes. À ce moment là, sa cabane fut
frappée par un éclair, le tuant et mettant fin à jamais à ses ambitions
d'écrivain. Dans les débris carbonisés de son ordinateur portable, j'ai
pu récupérer le fichier suivant :

] % Le livre de programmation
]
] %% Les deux points de vue
]
] Sous la surface de la machine, le programme évolue. Sans effort, il
] prend de l'ampleur et se contracte. Avec beaucoup d'harmonie, les
] électrons se dispersent et se regroupent. Les formes sur le moniteur
] ne sont que l'écume de la vague.
]
] Quand les créateurs ont construit la machine, ils y ont mis un
] processeur et de la mémoire. À partir de là surgissent les deux
] points de vue sur le programme.
]
] Du côté du processeur, l'élément actif est appelé Contrôle. Du côté
] de la mémoire, l'élément passif est appelé Données.
]
] Les données sont faites de simples bits, et pourtant elles prennent
] des formes complexes. Le contrôle consiste en de simples instructions
] et pourtant il exécute des tâches difficiles, de la plus petite et la
] plus triviale, à la plus grande et la plus compliquée.
]
] Le programme source est la donnée. Le Contrôle y naît. Le Contrôle va
] ensuite s'employer à créer de nouvelles données. L'un naît de
] l'autre, l'un ne sert à rien sans l'existence de l'autre. C'est le
] cycle harmonieux des Données et du Contrôle.
]
] Par nature, les Données et le Contrôle sont sans structure. Les
] programmeurs de la vieille école mijotaient leurs programmes à partir
] de cette soupe primitive. Le temps passant, les Données amorphes se
] sont cristallisées en de nouveaux types de données et le Contrôle
] chaotique a été restreint aux structures de contrôle et aux
] fonctions.
]
] %% Petits proverbes
]
] Quand un étudiant a questionné Fu-Tzu sur la nature du cycle des
] Données et du Contrôle, Fu-Tzu répondit « Pensez à un
] compileur en train d'essayer de se compiler. »
]
] Un étudiant demanda : « Les programmeurs de la vieille école
] utilisaient des machines simples et pas de langages de programmation
] et pourtant ils concevaient de beaux programmes. Pourquoi
] utilisons-nous des machines compliquées et des langages de
] programmation ? » Fu-Tzu répondit : « Les bâtisseurs d'autrefois
] utilisaient seulement des bâtons et de l'argile et pourtant ils
] faisaient des cabanes magnifiques. »
]
] Un ermite passa dix ans à écrire un programme. « Mon programme peut
] calculer le mouvement des étoiles sur un ordinateur 286 qui fait
] tourner MS DOS » annonça t-il fièrement. « Personne ne possède un
] ordinateur 286 ou ne l'utilise aujourd'hui » répondit-il.
]
] Fu-Tzu avait écrit un petit programme qui était plein de variables
] globales et de raccourcis douteux. En le lisant, un étudiant demanda
] « Vous nous avez mis en garde contre ces techniques, et pourtant je
] les ai trouvées dans ce programme. Comment cela se fait-il ? » Fu-Tzu
] répondit : « Il n'y a pas besoin d'aller chercher un tuyau d'arrosage
] quand la maison n'est pas en feu. » {Cela ne doit pas se lire comme
] un encouragement à faire du code de mauvaise qualité, mais comme un
] avertissement contre une adhésion servile à la règle d'or.}
]
] %% Sagesse
]
] Un étudiant se plaignait des valeurs numériques. « Quand je prend
] la racine de deux et que je veux de nouveau son carré, le résultat est
] inexact ! ».
] En entendant cela, Fu-Tzu rit. « Voici une feuille de papier.
] Écrivez-moi la valeur précise de la racine de deux. »
]
] Fu-Tzu dit : « Quand vous sciez du bois contre le fil, beaucoup
] d'huile de coude est nécessaire. Quand vous programmez contre le
] sens, beaucoup de code est nécessaire. »
]
] Tzu-li et Tzu-ssu se vantaient de la taille de leur programmes.
] « Deux cents mille lignes », dit Tzu-li, « sans compter les
] commentaires ! ». « Psah », dit Tzu-ssu, « le mien fait presque
] un *million* de lignes déjà. » Fu-tzu dit « Mon meilleur
] programme fait cinq cents lignes. » En entendant cela, Tzu-li
] et Tzu-ssu furent éclairés.
]
] Un étudiant était resté assis immobile derrière son ordinateur
] pendant des heures, en ruminant furieusement. Il était en train
] d'essayer de concevoir une solution élégante en réponse à un
] problème difficile, mais il ne pouvait pas trouver le bon moyen
] de le faire. Fu-tzu le frappa sur l'arrière de la tête, et cria
] « tape quelque chose ! » L'étudiant se mit à écrire un code
] dégueulasse. Quand il eut terminé, il comprit tout à coup quelle
] était la solution simple.
]
] %% Progression
]
] Un programmeur débutant écrit un programme à la manière d'une
] fourmis qui construit sa fourmilière, sans même penser à la
] structure finale. Ses programmes seront comme des grains de
] sable fin. Ils peuvent tenir un moment, mais en devenant plus
] gros ils tombent {en référence aux dangers d'une
] incompatibilité interne et aux structures dupliquées dans un
] code en désordre.}.
]
] En prenant conscience de ce problème, le codeur commencera à
] passer plus de temps à réfléchir à la structure. Ses programmes
] seront structurés rigidement, à la manière
] de sculptures de pierre. Ils sont solides, mais quand ils doivent
] changer, on doit leur faire violence {en référence au fait
] que la structure a tendance à brider l'évolution du
] programme.}.
]
] Le programmeur expérimenté sait quand la structure est
] importante, et quand il doit laisser les choses telles quel.
] Ses programmes sont comme de l'argile, à la fois solide et
] malléable.
]
] %% Langage
]
] Quand un langage de programmation est créé, on lui donne une
] syntaxe et des règles sémantiques. La syntaxe décrit la
] forme du programme, la sémantique décrit la fonction. Quand
] la syntaxe est belle et que les règles sont claires, le
] programme sera un arbre majestueux. Quand la syntaxe est
] maladroite et que les règles sont confuses, le programme
] sera comme un tas de ronces.
]
] On demanda à Tzu-ssu d'écrire un programme dans un langage
] appelé Java qui adopte une approche vraiment primitive avec
] les fonctions. Tous les matins, au moment où il s'asseyait
] en face de son ordinateur, il commençait à se plaindre.
] Toute la journée il jurait, accusant le langage pour tout
] ce qui se passait mal. Fu-tzu écouta pendant un moment,
] puis lui fit des reproches en lui disant « Chaque langage
] a sa philosophie. Suis son dessein, n'essaye pas de coder
] comme si tu  utilisais un autre langage de programmation.»

---

Afin d'honorer la mémoire de notre vénérable ermite, j'aimerais finir son
programme de génération HTML pour lui. Une bonne approche à ce problème
ressemble à ce qui suit :

 1. Découper le fichier en paragraphes en le découpant à chaque fin de ligne.
 2. Supprimer les caractères « % » des paragraphes d'entête et marquer ceux-ci comme entête.
 3. Traiter le texte des paragraphes proprement dit, les découper en corps de texte, textes en emphase et notes de bas de page.
 4. Déplacer les notes de bas de page en fin de document, mettre des numéros## à leur place.
 5. Entourer chaque élément d'une balise HTML adéquate.
 6. Regrouper le tout en un unique document HTML.

## Comme ceci

Cette approche ne permet pas les notes de bas de page à l'intérieur des
textes en emphase et inversement. C'est un choix arbitraire mais il permet de
rester sur un exemple assez simple. Si, à la fin du chapitre, vous voulez
vous lancer un défi, essayer de modifier le programme pour qu'il prenne en
charge les marquages « imbriqués ».

Le manuscrit complet, sous forme de chaine, est disponible sur cette page
en appelant la fonction |recluseFile|.

---

La première étape de cet algorithme est triviale. Une ligne blanche est le
résultat de deux retours-chariots consécutifs et, si vous vous rappelez
que les chaînes disposent d'une méthode |split|, comme vu dans \\cdata,
vous comprendrez que cela fera l'affaire :

> var paragraphes = recluseFile().split("\n\n");
> print("Trouvé ", paragraphes.length, " paragraphes.");

***

Ecrire une fonction |transformeParagraphe| qui, recevant un paragraphe sous
forme de chaîne en argument, détermine si ce paragraphe est un entête. S'il
l'est, enlever les caractères « % » et les compter. Cette fonction renvoie
un objet doté de 2 propriétés, |content| contenant le texte du paragraphe,
et |type|, qui contient le tag qui devra entourer le paragraphe, |"p"| pour
des paragraphes proprement dit, |"h1"| pour les entêtes avec un seul « %
», et |"hX"| pour les entêtes avec |X| « % » caractères.

Rappelez-vous que les chaînes possèdent une méthode |charAt| permettant
de rechercher un caractère précis dans les caractères qui la composent.

///

> function transformeParagraphe(paragraphe) {
>   var entete = 0;
>   while (paragraphe.charAt(0) == "%") {
>     paragraphe = paragraphe.slice(1);
>     entete++;
>   }
>
>   return {type: (entete == 0 ? "p" : "h" + entete),
>           content: paragraphe};
> }
>
> show(transformeParagraphe(paragraphes[0]));

---

C'est là que nous pouvons essayer la fonction |map| citée précédemment.

> var paragraphes = map(transformeParagraphe,
>                      recluseFile().split("\n\n"));

Et *boum*, nous avons un tableau de paragraphes proprement triés. Nous
sommes allés un peu vite, nous avons oublié l'étape 3 de l'algorithme:

| Traiter le texte des paragraphes proprement dit, séparer en texte normal,
texte en emphase, notes de bas de page.

Ce qui se décompose en :

 1. Si le paragraphe commence par un astérisque, retirer la partie mise en emphase et la stocker.
 2. Si le paragraphe commence par une accolade ouvrante, retirer la note de page et la stocker.
 3. Dans les autres cas, retirer le morceau de texte jusqu'à la première mise en exergue, mise en bas de page, sinon jusqu'à la fin de la chaîne, et l'enregistrer comme texte normal.
 4. S'il reste encore quelque chose dans le paragraphe, reprendre à nouveau en 1.

***

Écrire une fonction |decoupeParagraphe| qui, recevant une chaîne de
caractères représentant un paragraphe, renvoie un tableau de morceaux du
texte. Réfléchir à la façon de bien représenter les morceaux du texte.

La méthode |indexOf|, qui recherche un caractère ou une sous-chaîne de
caractères dans une chaîne de caractères et renvoie sa position, ou |-1|
si elle ne trouve pas, sera utile ici.

C'est un algorithme astucieux, et il y a différentes façons approximatives
ou trop longues pour l'expliquer. En cas de difficulté, n'y passer qu'une
minute. Essayer d'écrire des sous-fonctions qui effectuent une partie des
actions qui composent l'algorithme.

///

Voici une solution possible :

> function decoupeParagraphe(texte) {
>   function indexOuFin(caractere) {
>     var index = texte.indexOf(caractere);
>     return index == -1 ? texte.length : index;
>   }
>
>   function extraitTexteNormal() {
>     var fin = reduce(Math.min, texte.length,
>                      map(indexOuFin, ["*", "{"]));
>     var extraction = texte.slice(0, fin);
>     texte = texte.slice(fin);
>     return extraction;
>   }
>
>   function extraitJusquA(caractere) {
>     var fin = texte.indexOf(caractere, 1);
>     if (fin == -1)
>       throw new Error("Manque '" + caractere + "' fermant");
>     var extraction = texte.slice(1, fin);
>     texte = texte.slice(fin + 1);
>     return extraction;
>   }
>
>   var fragments = [];
>
>   while (texte != "") {
>     if (texte.charAt(0) == "*")
>       fragments.push({type: "enEmphase",
>                       contenu: extraitJusquA("*")});
>     else if (texte.charAt(0) == "{")
>       fragments.push({type: "noteBasDePage",
>                       contenu: extraitJusquA("}")});
>     else
>       fragments.push({type: "normal",
>                       contenu: extraitTexteNormal()});
>   }
>   return fragments;
> }

Remarquez l'utilisation abrupte de |map| et |reduce| dans la fonction
|extraitTexteNormal|. Ceci est un chapitre sur la programmation fonctionnelle,
donc c'est de la programmation fonctionnelle que nous ferons !
Voyez-vous comment cela fonctionne ? La fonction |map| renvoie un tableau des
positions où les caractères indiqués ont été trouvés, ou bien renvoie
la fin de la chaîne si aucun n'a été trouvé, et la fonction |reduce|
prend le minimum de ces positions, qui est la prochain position dans la
chaîne où nous allons regarder.

Si vous voulez écrire cela sans |map| et |reduce|, vous obtiendrez à peu
près ceci :

!> var prochainAsterisque = texte.indexOf("*");
!> var prochaineAccolade = texte.indexOf("{");
!> var fin = texte.length;
!> if (prochainAsterisque != -1)
!>   fin = prochainAsterisque;
!> if (prochaineAccolade != -1 && prochaineAccolade < fin)
!>   fin = prochaineAccolade;

Ce qui est encore plus moche. La plupart du temps, quand il faut prendre une
décision basée sur plusieurs critères, ne serait-ce que deux, l'écrire
sous forme d'une opération dans un tableau est plus lisible que de décrire
chaque critère dans une instruction |if|. (Heureusement, dans le \\cregexp,
il y a une description simple de la façon de déterminer la première
occurrence de 'ceci ou cela' dans une chaîne).

Si vous avez écrit une fonction |decoupeParagraphe| qui enregistre les
morceaux de texte d'une façon différente de la solution ci-dessus, vous
devriez la modifier, car les fonctions du reste de ce chapitre supposent
que les morceaux de texte sont des objets dotés des propriétés |type|
et |contenu|.

---

Nous pouvons maintenant faire le lien avec |transformeParagraphe| pour
découper également le texte à l'intérieur des paragraphes, ma version
peut être modifiée de la façon suivante :

> function transformeParagraphe(paragraphe) {
>   var entete = 0;
>   while (paragraphe.charAt(0) == "%") {
>     paragraphe = paragraphe.slice(1);
>     entete++;
>   }
>
>   return {type: (entete == 0 ? "p" : "h" + entete),
>           contenu: decoupeParagraphe(paragraphe)};
> }

L'exécution de cette fonction sur le tableau des objets paragraphes nous
renvoie un nouveau tableau d'objets paragraphe, qui contiennent des tableaux
d'objet. Chacun de ces objets contient une fraction de paragraphe.
La chose à faire ensuite est d'extraire les notes de bas de page, et mettre
des références vers celles-ci à leur place. Comme ceci :

> function extraitNotesBasDePage(paragraphes) {
>   var notesBasDePage = [];
>   var noteEnCours = 0;
>
>   function remplaceNoteBasDePage(fragment) {
>     if (fragment.type == "noteBasDePage") {
>       noteEnCours++;
>       notesBasDePage.push(fragment);
>       fragment.numero = noteEnCours;
>       return {type: "reference", numero: noteEnCours};
>     }
>     else {
>       return fragment;
>     }
>   }
>
>   forEach(paragraphes, function(paragraphe) {
>     paragraphe.contenu = map(remplaceNoteBasDePage,
>                             paragraphe.contenu);
>   });
>
>   return notesBasDePage;
> }

La fonction |remplaceNoteBasDePage| est appelée sur chaque morceau. Quand
elle reçoit un morceau qui doit rester où il est, elle ne fait que renvoyer
ce morceau, mais si elle reçoit une note de bas de page, elle stocke celui-ci
dans le tableau |notesBasDePage|, et renvoie une référence vers celui-ci à
la place. Dans le même temps, chaque note de bas de page et sa référence
sont numérotées.

---

Nous avons suffisamment d'outils pour extraire les informations du fichier. Il
nous reste à générer un fichier HTML correct.

De nombreuses personnes pensent que la concaténation de chaînes de caractère
est un bon moyen de construire du HTML. Quand elles veulent, par exemple,
un lien vers un site où l'on peut jouer au jeu de Go, elles font ceci :

> var url = "http://www.gokgs.com/";
> var texte = "Jouer au Go!";
> var texteLien = "<a href=\"" + url + "\">" + texte + "</a>";
> print(texteLien);

(Où |a| est la balise utilisée pour créer des liens dans les documents
HTML)… Ceci est non seulement maladroit, mais, quand la chaîne |texte|
se trouve contenir un chevron (caractère '<' ou '>') ou une esperluette
(caractère '&'), cela provoque une erreur. Des choses bizarres vont se
passer sur votre site web, et vous passerez pour un amateur. Nous ne voulons
pas que cela se produise. Il est facile d'écrire quelques fonctions simples
de génération de HTML. Alors, écrivons-les.

---

Le secret d'une génération HTML réussie est de traiter votre document
comme une structure de données plutôt qu'un simple texte plat.
Les objets en JavaScript permettent de modéliser cela facilement :

> var objetLien= {nom: "a",
>                   attributs: {href: "http://www.gokgs.com/"},
>                   contenu: ["Jouer au Go!"]};

Chaque élément HTML possède une propriété |nom|, contenant le nom de la
balise qu'il représente. Quand il a des attributs, il possède également
une propriété |attributs|, qui est un objet contenant ces attributs. Quand
il a un contenu, il possède une propriété |contenu| contenant un tableau
des autres éléments qu'il englobe. Des chaînes de caractères contiennent
les portions de texte de notre document HTML, ainsi, le tableau |["Jouer
au Go!"]| signifie que ce lien n'a qu'un élément englobé, cet élément
étant un simple morceau de texte.

Taper tout ces objets à la main serait pénible, mais nous n'allons pas
faire comme ça. Une fonction utilitaire fera cela pour nous:

> function tag(nom, contenu, attributs) {
>   return {nom: nom, attributs: attributs, contenu: contenu};
> }

Remarquez que du fait que nous autorisons que les propriétés |attributs|
et |contenu| d'un élément soient indéfinis s'il ne s'appliquent pas,
le second et troisième élément de cette fonction peuvent être ignorés
s'il ne sont pas nécessaires.

La fonction |tag| est cependant assez simpliste, c'est pourquoi nous écrivons
quelques fonctions utilitaires pour des éléments fréquemment utilisés,
comme les liens, ou la structure générale d'un document simple :

> function lien(cible, texte) {
>   return tag("a", [texte], {href: cible});
> }
>
> function documentHtml(titre, contenu) {
>   return tag("html", [tag("head", [tag("title", [titre])]),
>                       tag("body", contenu)]);
> }

***

En reprenant, si nécessaire, l'exemple de document HTML donné précédemment,
écrire une fonction |image| qui, recevant un fichier d'image, créé un
élément HTML |img|.

///

> function image(src) {
>   return tag("img", [], {src: src});
> }

---

Quand nous aurons créé un document, il devra être mis à plat sous forme
de chaîne. Mais construire cette chaîne a partir des structures de données
que nous aurons construites sera facile. L'aspect important dont il faut se
souvenir est de transformer les caractères spéciaux de notre document…

> function echappeHTML(texte) {
>   var remplacements = [[/&/g, "&amp;"], [/"/g, "&quot;"],
>                       [/</g, "&lt;"], [/>/g, "&gt;"]];
>   forEach(remplacements, function(remplacement) {
>     texte = texte.replace(remplacement[0], remplacement[1]);
>   });
>   return texte;
> }

La méthode |replace| des objets chaînes créé une nouvelle chaîne dans
laquelle toutes les occurrences du motif passé en premier en premier argument
sont remplacées par le second argument, ainsi |"Borobudur".replace(/r/g,
"k")| donne |"Bokobuduk"|. Ne vous souciez pas ici de la syntaxe des motifs,
cela sera vu au \\cregexp. La fonction |echappeHTML| stocke les différents
motifs à remplacer dans un tableau, aussi, il suffit d'énumérer à l'aide
d'une boucle chacun de ces motifs pour les appliquer un par un.

Les guillemets sont également remplacés, car nous utiliserons cette fonction
pour le texte à l'intérieur des attributs des balises HTML. Ces attributs
seront encadrés par des guillements, et par conséquent ne pourront en
contenir eux-mêmes.

Appeler quatre fois la méthode replace signifie que l'ordinateur devra
balayer quatre fois la totalité de la chaîne à convertir. Ce n'est pas très
efficace. Avec plus de soin, nous pourrions écrire une version plus complexe
de cette fonction, qui ressemblerait à la fonction |decoupeParagraphe| vue
précédemment, pour ne parcourir cette chaîne qu'une seule fois. Pour le
moment, nous sommes trop paresseux pour cela. De toute façon, nous verrons
au \\cregexp une bien meilleure façon de faire tout cela.

---

Pour transformer un élément HTML en une chaîne, nous pouvons utiliser
une fonction récursive comme celle-ci :

> function renduHTML(element) {
>   var pieces = [];
>
>   function renduAttributs(attributs) {
>     var resultat = [];
>     if (attributs) {
>       for (var nom in attributs)
>         resultat.push(" " + nom + "=\"" +
>                     echappeHTML(attributs[nom]) + "\"");
>     }
>     return resultat.join("");
>   }
>
>   function rendu(element) {
>     // Element texte
>     if (typeof element == "string") {
>       pieces.push(echappeHTML(element));
>     }
>     // Balise vide
>     else if (!element.contenu || element.contenu.length == 0) {
>       pieces.push("<" + element.nom +
>                   renduAttributs(element.attributs) + "/>");
>     }
>     // Balise avec du contenu
>     else {
>       pieces.push("<" + element.nom +
>                   renduAttributs(element.attributs) + ">");
>       forEach(element.contenu, rendu);
>       pieces.push("</" + element.nom + ">");
>     }
>   }
>
>   rendu(element);
>   return pieces.join("");
> }

Remarquez la boucle avec |in| qui extrait les propriétés d'un objet
JavaScript dans le but de créer les attributs d'une balise HTML en se basant
sur ces propriétés. Remarquez également qu'à deux reprises, des tableaux
sont utilisés pour stocker des chaînes, qui sont finalement regroupées
pour ne former qu'une seule chaîne. Pourquoi n'avons-nous pas simplement
commencé avec une chaîne vide à laquelle nous aurions ajouté d'autres
chaînes, à l'aide de l'opérateur |+=| ?

Il se trouve que la création des chaînes, en particulier quand elles sont de
grande taille, représente un certain travail. Rappelez-vous que le contenu des
chaînes JavaScript est immuable. Si vous concaténez une chaîne à une autre,
une nouvelle chaîne est créée, les deux premières ne changeant pas. Si
nous construisons une très grande chaîne en concaténant de nombreuses
chaînes, une nouvelle chaîne doit être créée à chacun des ajouts,
et sera supprimée après l'ajout suivant.
Si, d'un autre côté, nous stockons toutes les chaînes dans un tableau
pour les rassembler à la fin, une seule grande chaîne sera créée.

---

Ainsi, essayons notre outil de génération de HTML...

> print(renduHTML(lien("http://www.nedroid.com", "Dessins !")));

Cela semble fonctionner.

> var corps = [tag("h1", ["Le Test"]),
>             tag("p", ["Voici un paragraphe, et une image..."]),
>             image("img/sheep.png")];
> var doc = documentHtml("Le Test", corps);
> viewHTML(renduHTML(doc));

Je devrais maintenant vous prévenir que cette approche n'est pas
parfaite. Ce qu'elle génère est en fait du _XML_, qui est proche du HTML,
mais plus structuré. Dans les cas les plus simple, cela n'engendre pas de
problème. Cependant, il existe des séquences correctes en XML, qui ne sont
pas correctes en HTML, et peuvent embrouiller un navigateur lorsqu'il va
vouloir afficher notre document. Si par exemple vous avez un jeu de balises
|script| vides (on les utilise pour insérer du JavaScript dans une page)
dans votre document, les navigateurs ne vont pas s'en apercevoir et penser
que tout ce qui suit est du JavaScript (dans ce cas, le problème peut être
réglé en mettant une espace unique entre les balises ouvrante et fermante
pour que la balise ne soit pas vide, et ainsi avoir une balise fermante).

***

Écrivez une fonction |renduFragment|, et utilisez-la pour implémenter
une autre fonction, |renduParagraphe|, qui prend un objet paragraphe (en
ne tenant pas compte des notes de bas de page) et produit l'élement HTML
correct (qui peut être un paragraphe ou un en-tête, en fonction du |type|
de l'objet paragraphe).

Cette fonction pourrait s'avérer utile pour produire les liens vers les
références de bas de page :

> function basDePage(numero) {
>   return tag("sup", [lien("#note" + numero,
>                           String(numero))]);
> }

Une balise |sup| affiche son contenu en « exposant », ce qui signifie
que ce contenu sera plus petit et un peu plus haut sur la ligne que le reste
du texte. La cible du lien prendra une forme telle que |"#note1"|. Les liens
contenant un caractère « # » font référence aux « ancres »
à l'intérieur d'une page, et ici nous les utiliserons pour renvoyer le
lecteur à la fin de la page, où seront les notes de bas de page.

La balise pour générer des parties mises en emphase est |em| ; un texte
normal peut être fourni avec n'importe quelle balise supplémentaire.

///

> function renduParagraphe(paragraphe) {
>   return tag(paragraphe.type, map(renduFragment,
>                                  paragraphe.contenu));
> }
>
> function renduFragment(fragment) {
>   if (fragment.type == "reference")
>     return basDePage(fragment.numero);
>   else if (fragment.type == "enEmphase")
>     return tag("em", [fragment.contenu]);
>   else if (fragment.type == "normal")
>     return fragment.contenu;
> }

---

Nous y sommes presque. Le dernier élément pour lequel nous ne disposons
pas de fonction de génération HTML sont les notes de bas de page. Pour
que les liens |"#note1"| fonctionnent, une ancre doit être incluse dans
chaque note de bas de page. En HTML, les ancres sont décrites à l'aide
d'une balise |a|, également utilisé pour les liens. Dans ce cas, la balise
prend un attribut |name| au lieu de |href|.

> function renduNoteBasDePage(noteBasDePage) {
>   var ancre = tag("a", [], {name: "note" + noteBasDePage.numero});
>   var numero = "[" + noteBasDePage.numero + "] ";
>   return tag("p", [tag("small", [ancre, numero,
>                                  noteBasDePage.contenu])]);
> }

Enfin, voici une fonction qui, recevant un fichier correctement formaté et
un titre de document, renvoie un document HTML.

> function renduFichier(fichier, titre) {
>   var paragraphes = map(transformeParagraphe, fichier.split("\n\n"));
>   var notesBasDePage = map(renduNoteBasDePage,
>                       extraitNotesBasDePage(paragraphes));
>   var corps = map(renduParagraphe, paragraphes).concat(notesBasDePage);
>   return renduHTML(documentHtml(titre, corps));
> }
>
> viewHTML(renduFichier(recluseFile(), "The Book of Programming"));

La méthode _|concat|_ des objets de type tableau sert à concaténer un
tableau avec un autre, tout comme l'opérateur |+| le fait avec les chaînes
de caractère.

---

Dans les chapitres suivant, les fonctions élémentaires d'ordre supérieur
comme |map| et |reduce| seront toujours disponibles et utilisées dans les
exemples. Ici et là, on leur ajoutera d'autres outils qui nous sembleront
utiles. Dans le \\cmodularity, nous verrons une approche plus structurée
pour gérer ce jeu de fonctions de base.

---

Lorsqu'on utilise des fonctions d'ordre supérieur, il est souvent agaçant
que les opérateurs ne soient pas des fonctions en JavaScript. Nous avons
eu besoin des fonctions |add| ou |equals| à différents endroits. Les
réécrire à chaque fois est fastidieux, n'est-ce pas ? Aussi, à partir de
maintenant, nous supposons l'existence d'un objet nommé |op|, qui contient
ces fonctions :

> var op = {
>   "+": function(a, b){return a + b;},
>   "==": function(a, b){return a == b;},
>   "===": function(a, b){return a === b;},
>   "!": function(a){return !a;}
>   /* and so on */
> };

Nous pouvons donc écrire |reduce(op["+"], 0, [1, 2, 3, 4, 5])| pour faire la
somme d'un tableau. Mais que se passe-t-il si nous avons besoin de quelque
chose comme |equals| ou |makeAddFunction|, dans lequel un des arguments a
déjà cette valeur ? Dans ce cas nous voilà revenus à l'écriture d'une
nouvelle fonction.

Dans les cas comme ceux-là, l'utilisation d'une « _application partielle_ »
est intéressante. Vous voulez créer une nouvelle fonction qui connaît déjà
un certain nombre de ces arguments et traite des arguments supplémentaires
passés après ces arguments fixes. Vous pourrez le faire en utilisant de
façon créative la méthode |apply| d'une fonction :

> function asArray(quasiArray, start) {
>   var result = [];
>   for (var i = (start || 0); i < quasiArray.length; i++)
>     result.push(quasiArray[i]);
>   return result;
> }
>
> function partial(func) {
>   var fixedArgs = asArray(arguments, 1);
>   return function(){
>     return func.apply(null, fixedArgs.concat(asArray(arguments)));
>   };
> }

Nous voulons autoriser la combinaison de plusieurs arguments en même temps,
donc la fonction |asArray| est nécessaire pour constituer des tableaux
normaux avec les objets |arguments|. Elle copie leur contenu dans un vrai
tableau, si bien que la méthode |concat| peut lui être appliquée. Elle
peut prendre aussi un deuxième argument facultatif, permettant d'ignorer
le ou les premiers arguments.

Notez également qu'il faut stocker les |arguments| de la fonction externe
(|partial|) dans une variable avec un autre nom, sinon la fonction interne
ne peut pas les voir (elle a sa propre variable |arguments|, qui masque
celle de la fonction externe).

Maintenant |equals(10)| peut s'écrire |partial(op["=="], 10)|.

> show(map(partial(op["+"], 1), [0, 2, 4, 6, 8, 10]));

La raison pour laquelle |map| prend son argument de fonction avant
l'organisation du tableau est qu'il est souvent utile d'appliquer partiellement
map en lui attribuant une fonction. Ce qui donne à la fonction davantage
de puissance, elle n'opère plus sur une seule valeur mais sur un tableau
de valeurs. Par exemple, si vous avez un tableau de tableau de nombres,
et que vous voulez les mettre tous au carré, vous procédez ainsi :

> function square(x) {return x * x;}
>
> show(map(partial(map, square), [[10, 100], [12, 16], [0, 1]]));

---

Une dernière astuce qui peut être utile quand vous voulez combiner des
fonctions est la _composition de fonctions_. Au début de ce chapitre j'ai
montré une fonction |negate|, qui applique l'opérateur booléen *not*
au résultat de l'appel d'une fonction :

> function negate(func) {
>   return function() {
>     return !func.apply(null, arguments);
>   };
> }

C'est un cas particulier d'une structure plus générale : appeler la
fonction A, puis appliquer la fonction B au résultat. La composition est
un concept usuel en mathématiques.  @_|compose|_Elle peut être utilisée
dans une fonction de haut niveau de la façon suivante :

> function compose(func1, func2) {
>   return function() {
>     return func1(func2.apply(null, arguments));
>   };
> }
>
> var isUndefined = partial(op["==="], undefined);
> var isDefined = compose(op["!"], isUndefined);
> show(isDefined(Math.PI));
> show(isDefined(Math.PIE));

Nous voilà en train de définir de nouvelles fonctions sans utiliser du
tout le mot-clé |function|. Cela peut être utile si vous avez besoin de
créer une fonction simple à passer, par exemple, à |map| ou |reduce|
. Toutefois, quand une fonction devient plus complexe que ces exemples,
il est généralement plus rapide (sans parler du gain en efficacité)
de l'écrire avec |function|.

==================
Recherche / search
==================

Ce chapitre n'introduit pas de nouveaux concepts spécifiques à JavaScript. À
la place, nous allons étudier les solutions de deux problèmes, et discuter
de techniques et d'algorithmes intéressants tout au long du chapitre. Si
cela ne vous semble pas intéressant, il est possible de sauter ce chapitre.

---

Laissez-moi introduire notre premier problème. Jetez un coup d'œil à ce
plan. Il montre Hiva Oa, une petite île tropicale de l'océan Pacifique.

[[Hiva Oa.png]]

Les lignes grises sont des routes, et les nombres à côté représentent
la longueur de ces routes. Imaginez que l'on ait besoin de connaître le
chemin le plus court pour relier deux endroits sur Hiva Oa. Quelle approche
pourrait-on adopter ?

Non, vraiment, ne lisez pas le paragraphe  en diagonale. Essayez de réfléchir
sérieusement aux manières de le faire, et réfléchissez aux problèmes que
vous pourriez rencontrer. Quand vous lisez un livre technique, il est bien trop
facile de parcourir le texte très rapidement, d'acquiescer solennellement
et de s'empresser d'oublier ce que l'on a lu. Si vous faites sérieusement
un effort pour résoudre un problème, il devient votre problème, et sa
solution aura vraiment sens.

---

Le premier aspect de ce problème est, de nouveau, de représenter nos
informations. Les informations contenues dans l'image n'ont pas beaucoup
de sens pour l'ordinateur. On pourrait essayer de coder un programme qui
étudierait l'image et en extrairait des informations… Mais cela pourrait
devenir compliqué. Si on avait vingt milles cartes à interpréter, ce serait
une bonne idée. En l’occurrence, on se chargera de faire l'interprétation
nous-mêmes, et on convertira les données du plan pour qu'elles soient
exploitables en langage informatique.

Que doit savoir notre programme ? Il doit être capable de trouver quel lieux
sont connectés, et quelle distance font les routes qui les relient. Les
lieux et les routes sur l'île forment un _graphe_, comme les mathématiciens
l'appellent. Il y a plusieurs possibilités pour enregistrer les graphes. Une
solution simple consiste à enregistrer dans un tableau des objets de type
route, chacun étant doté de propriétés désignant ses deux extrémités
et sa longueur.

> var routes = [{point1: "Point Kiukiu", point2: "Hanaiapa", length: 19},
>              {point1: "Point Kiukiu", point2: "Mt Feani", length: 15}
>              /* and so on */];

Cependant, il s'avère que lorsque le programme essaiera de déterminer
une route, il aura très souvent besoin de consulter une liste de tous les
routes commençant à un point donné, tout comme une personne qui se situe
à un carrefour aura besoin de regarder les panneaux de direction et lire «
Hanaiapa : 19 km, Mont Feani : 15 km ». Ce serait sympa si c'était
facile (et rapide) à faire.

Avec la représentation donnée au-dessus, nous devons éplucher tous les
noms de route en gardant ceux qui sont utiles chaque fois que nous voulons
ces panneaux de direction. Une meilleure technique serait d'enregistrer cette
liste directement. Par exemple, utiliser un objet qui associe les noms de
lieux avec la liste des panneaux :

> var routes = {"Point Kiukiu": [{to: "Hanaiapa", distance: 19},
>                               {to: "Mt Feani", distance: 15},
>                               {to: "Taaoa", distance: 15}],
>              "Taaoa": [/* et cetera */]};

Quand  nous avons cet objet, obtenir les routes qui partent du « Point
Kiukiu » revient juste à jeter un œil à |routes["Point Kiukiu"]|.

---

Toutefois, cette nouvelle représentation contient des données dupliquées :
la route reliant A à B est listée à la fois dans A et dans B. La première
représentation demandait déjà beaucoup de travail pour rentrer les données,
avec celle-là c'est encore pire.

Heureusement, nous avons à notre disposition le talent de notre ordinateur
pour la répétition des tâches. On peut indiquer les routes une fois, et
faire générer par l'ordinateur la bonne structure de données. D'abord,
définissez un objet initial vide appelé |routes|, et écrivez une fonction
|ajouterRoute| :

> var routes = {};
> function creerRoute(depart, arrivee, distance) {
>   function ajouterRoute(depart, arrivee) {
>     if (!(depart in routes))
>       routes[depart] = [];
>     routes[depart].push({arrivee: arrivee, distance: distance});
>   }
>   ajouterRoute(depart, arrivee);
>   ajouterRoute(arrivee, depart);
> }

Sympa, n'est-ce pas ? Remarquez comment la fonction interne (|ajouterRoute|)
utilise les mêmes noms (|depart| et |arrivee|) pour ses paramètres que
ceux de la fonction externe.
Ils ne vont pas interférer : à l'intérieur de |ajouterRoute|, ils
corresdpondent aux paramètre de |ajouterRoute|, et à l'extérieur, ils
correspondent aux paramètres de |creerRoute|.

L'instruction |if| dans |ajouterRoute| s'assure qu'il y a un tableau de
destinations associées avec le lieu nommé par |depart|, et s'il n'y en a pas
encore, il ajoute une entrée vide. De cette façon, à la ligne suivante il
peut supposer que le tableau existe déjà et entrer la nouvelle route dedans.

Maintenant, les informations de la carte ressemblent à ceci :

> creerRoute("Point Kiukiu", "Hanaiapa", 19);
> creerRoute("Point Kiukiu", "Mt Feani", 15);
> creerRoute("Point Kiukiu", "Taaoa", 15);
> // ...

***

Dans la description ci-dessus, on a encore trois fois l’occurrence de la
chaîne de caractères |"Point Kiukiu"| à la suite. Nous pourrions générer
une description encore plus succincte en permettant à des routes multiples
d'être définies sur une seule ligne.

Écrivez une fonction |creerRoutes| qui accepte un nombre variable
d'arguments. Le premier argument est toujours le point de départ des routes,
et chaque paire d'arguments qui suit donne le point d'arrivée et une distance.

Ne dupliquez pas la fonctionnalité de |creerRoute|, mais demandez à
|creerRoutes| d'appeler |creerRoute| pour réaliser la véritable création
de route.

///

> function creerRoutes(depart) {
>   for (var i = 1; i < arguments.length; i += 2)
>     creerRoute(depart, arguments[i], arguments[i + 1]);
> }

Cette fonction utilise un paramètre nommé, |depart|, et récupère les
autres paramètres dans le (presque-) tableau |arguments| . |i| démarre à
|1| car il doit ignorer le premier paramètre. |i += 2| est la simplification
de l'équation |i = i + 2|,  comme vous vous rappelez sans doute.

> var routes = {};
> creerRoutes("Point Kiukiu", "Hanaiapa", 19,
>           "Mt Feani", 15, "Taaoa", 15);
> creerRoutes("Airport", "Hanaiapa", 6, "Mt Feani", 5,
>           "Atuona", 4, "Mt Ootua", 11);
> creerRoutes("Mt Temetiu", "Mt Feani", 8, "Taaoa", 4);
> creerRoutes("Atuona", "Taaoa", 3, "Hanakee pearl lodge", 1);
> creerRoutes("Cemetery", "Hanakee pearl lodge", 6, "Mt Ootua", 5);
> creerRoutes("Hanapaoa", "Mt Ootua", 3);
> creerRoutes("Puamua", "Mt Ootua", 13, "Point Teohotepapapa", 14);
>
> show(routes["Airport"]);

---

Nous avons réussi à réduire considérablement notre description des
informations sur les routes en définissant quelques opérations pratiques. On
pourrait dire que nous avons exprimé l'information de façon plus succincte
en élargissant notre vocabulaire. @_domain-specific language_Définir un
'petit langage' comme ceci est une technique très puissante — quand, à
tout moment, vous vous retrouvez à écrire du code répétitif et inutile,
arrêtez-vous et essayez de réduire ce code avec du vocabulaire qui le
raccourcira et le condensera.

Le code redondant est non seulement ennuyeux à écrire mais aussi
potentiellement générateur d'erreurs. Les gens font moins attention quand
ils font des choses qui ne requiert pas de la réflexion de leur part. En plus
de cela, le code répétitif est dur à modifier, parce qu'une structure, qui
répète le même motif un millier de fois, doit également être modifiée
un millier de fois si elle s'avère incorrecte ou suboptimale.

---

Si vous exécutez tous les morceaux de code ci-dessus, vous devriez avoir
une variable nommée |routes| qui contient toutes les routes de l'île. Quand
nous avons besoin de la liste des routes qui partent d'un certain lieu, nous
pouvons juste faire |routes[lieu]|. Mais alors, si quelqu'un fait une coquille
dans le nom d'un endroit, ce qui est fort probable avec des noms pareils,
il récupèrera un |undefined| à la place du tableau qu'il attendait, et
des erreurs étranges peuvent survenir. À la place, nous allons utiliser
une fonction qui permet de récupérer les tableaux de routes et qui nous
hurle dessus si nous lui donnons un nom de lieu inconnu :

> function routesDepuis(lieu) {
>   var trouve = routes[lieu];
>   if (trouve == undefined)
>     throw new Error("Auncun lieu nommé '" + lieu + "' n'a été trouvé.");
>   else
>     return trouve;
> }
>
> show(routesDepuis("Puamua"));

---

Voici un premier jet pour un algorithme de recherche de chemin, la méthode
du joueur :

> function routeDuJoueur(depart, arrivee) {
>   function entierAuHasard(seuil) {
>     return Math.floor(Math.random() * seuil);
>   }
>   function directionAuHasard(depart) {
>     var options = routesDepuis(depart);
>     return options[entierAuHasard(options.length)].arrivee;
>   }
>
>   var chemin = [];
>   while (true) {
>     chemin.push(depart);
>     if (depart == arrivee)
>       break;
>     depart = directionAuHasard(depart);
>   }
>   return chemin;
> }
>
> show(routeDuJoueur("Hanaiapa", "Mt Feani"));

À chaque branche de la route, le joueur lance son dé pour décider quelle
route il va prendre. Si le dé le renvoie à son lieu de départ, ainsi
soit-il. Tôt ou tard, il arrivera à destination, du moment que tous les
endroits de l'île sont connectés par des routes.

La ligne la plus déroutante est surement celle contenant
_|Math.random|_. Cette fonction renvoie un nombre pseudo-aléatoire## entre 0
et 1. Essayez de l'appeler un certain nombre de fois à la console, vous verrez
qu'il vous donnera (fort probablement)  un nombre différent à chaque fois. La
fonction |randomInteger| multiplie ce nombre par l'argument qui lui est donné
et arrondie le résultat au chiffre inférieur avec |Math.floor|. Ainsi par
exemple, |entierAuHasard(3)| renverra les chiffres |0[, |1| ou |2|.

## Les ordinateurs sont des machines déterministes : elles réagissent
tout le temps de la même manière aux données qu'elles reçoivent, et ne
peuvent pas produire de réelles valeurs aléatoires. Par conséquent, nous
devons nous accommoder d'une série de nombres qui semblent aléatoires,
mais qui dans les faits sont le résultat de quelques calculs complexes
et déterministes.

---

La méthode du joueur est la manière de faire pour ceux qui abhorrent
la structuration et la planification, qui cherchent désespéremment
l'aventure. Nous avons décidé d'écrire un programme qui peut trouver le
chemin *le plus court* pour aller d'un point à un autre, il nous faut donc
utiliser une autre méthode.

Une approche très simple est de résoudre un tel problème par la méthode
dite « _générer et tester_' ». Il faut :

 1. Générer toutes les routes possibles.
 2. Dans cet ensemble, trouver le plus court chemin qui connecte le point de départ au point d'arrivée.

L'étape 2 n'est pas difficile. L'étape 1 est un peu plus problématique. Si
vous acceptez des routes avec des boucles, il existe une infinité de
routes. Bien sûr, il est peu probable que les routes avec des boucles
soient les chemins les plus courts pour aller d'un point à un autre, et
les routes qui ne commencent pas au point de départ ne doivent pas non plus
être prises en compte. Pour un petit graphe telle que Hiva Oa, il devrait
être possible de générer des routes non cycliques (exemptes de boucles)
démarrant d'un lieu donné.

---

Mais d'abord, nous avons besoin de nouveaux outils. Le premier est une fonction
nommée |member|, qui est utilisée pour déterminer si un élément est
présent dans un tableau. L'itinéraire (que l'on appellera également route
par la suite) sera conservé comme un tableau de noms, et quand le voyageur
arrivera à un nouveau lieu, l'algorithme appellera |member| pour vérifier si
le voyageur est déjà passé par cet endroit. Cela peut ressembler à ça :

> function member(array, value) {
>   var found = false;
>   forEach(array, function(element) {
>     if (element === value)
>       found = true;
>   });
>   return found;
> }
>
> print(member([6, 7, "Bordeaux"], 7));

Toutefois, ceci va parcourir la totalité du tableau, même si la valeur
est trouvée immédiatement en première position. Quel gâchis. Quand vous
utilisez une boucle |for|, vous pouvez en sortir avec l'instruction |break|,
mais dans une structure |forEach| ceci ne fonctionnera pas, parce que le
cœur de la boucle est une fonction et l'instruction |break| n'interrompt
pas une fonction. Une solution pour être d'adapter |forEach| pour qu'il
reconnaissse certains types d'exceptions comme une un signal pour un arrêt
(similaire à |break| dans les boucles |for|)

> var Break = {toString: function() {return "Break";}};
>
> function forEach(array, action) {
>   try {
>     for (var i = 0; i < array.length; i++)
>       action(array[i]);
>   }
>   catch (exception) {
>     if (exception != Break)
>       throw exception;
>   }
> }

---

Maintenant, si la fonction |action| lance un |Break|, |forEach| absorbera
l'exception et interrompra la boucle. L'objet stocké dans la variable |Break|
est utilisé exclusivement comme un élément de comparaison.  La seule raison
pour laquelle je lui ai donné une propriété |toString| est qu'il pourrait
être très utile de trouver à quelle étrange valeur vous avez à faire si
vous finissez par récupérer une exception |Break| en-dehors d'un |forEach|.

---

Disposer d'un moyen de sortir de boucles |forEach| peut être très utile, mais
dans le cas de la fonction |member| le résultat demeure assez moche, parce
que vous avez besoin de stocker ce résultat particulier et de le retourner
plus tard. Nous pourrions encore ajouter une autre sorte d'exception, |Return|,
à  laquelle on peut attribuer une propriété |value|, et faire en sorte que
|forEach| renvoie cette valeur lorsqu'une exception de ce genre est lancée,
mais ce serait vraiment spécifique à notre problème et plutôt confus. Ce
dont nous avons vraiment besoin c'est d'une nouvelle fonction de haut niveau,
appelée _|any|_ (ou quelquefois |some|). Elle ressemble à ceci :

> function any(test, array) {
>   for (var i = 0; i < array.length; i++) {
>     var found = test(array[i]);
>     if (found)
>       return found;
>   }
>   return false;
> }
>
> function member(array, value) {
>   return any(partial(op["==="], value), array);
> }
>
> print(member(["Peur", "Répugnance"], "Rejet"));

|any| parcourt tous les éléments d'un tableau, de gauche à droite,
et les soumet à une fonction de test. La première fois qu'elle renvoie
une valeur comme |true|, cette valeur est renvoyée. Sinon, elle retourne
|false|. Appeler |any(test, array)| est plus ou moins équivalent à
|test(array[0]) || test(array[1]) || …| etc.

---

Tout comme |&&| est le pendant de ||||, |any| a son pendant, appelé _|every|_:

> function every(test, array) {
>   for (var i = 0; i < array.length; i++) {
>     var found = test(array[i]);
>     if (!found)
>       return found;
>   }
>   return true;
> }
>
> show(every(partial(op["!="], 0), [1, 2, -1]));

---

Une autre fonction dont nous aurons besoin est |flatten|. Cette fonction
prend un tableau de tableaux et met les éléments des tableaux dans un
unique grand tableau.

>   function flatten(arrays) {
>     var result = [];
>     forEach(arrays, function (array) {
>       forEach(array, function (element){result.push(element);});
>     });
>     return result;
>   }

La même chose pourrait être faite en utilisant la méthode |concat| et un
genre de |reduce|, mais ceci serait moins efficace. De la même manière,
concaténer ensemble des chaînes de caractères à de nombreuses reprises
est plus lent que les mettre dans un tableau puis appeler la méthode
|join|. Concaténer ensemble des tableaux  de maniére répétée produit
beaucoup de tableaux intermédiaires et inutiles.

***

Avant de commencer à générer des routes, nous avons besoin d'une fonction
d'ordre supérieur supplémentaire. Celle-ci est appelée _|filter|_. Tout
comme |map|, elle prend une fonction et un tableau en arguments, et produit
un nouveau tableau, mais au lieu de placer le résultat de la fonction
appelée dans le nouveau tableau, elle produit un tableau avec seulement les
valeurs de l'ancien tableau pour lequel la fonction donnée retourne |true|
(ou une valeur considérée équivalente a |true|). Écrivez cette fonction.

///

> function filter(test, array) {
>   var result = [];
>   forEach(array, function (element) {
>     if (test(element))
>       result.push(element);
>   });
>   return result;
> }
>
> show(filter(partial(op[">"], 5), [0, 4, 8, 12]));

(Si le résultat de cette utilisation de |filter| vous surprend, souvenez-vous
que l'argument donné à |partial| est utilisé comme le *premier* argument
de la fonction, de manière à ce qu'il finisse à la gauche de |>|.)

---

Imaginez à quoi un algorithme permettant de générer des itinéraires
pourrait ressembler — il commence au point de départ et génére un
itinéraire pour chaque route qui quitte ce lieu. À la fin de chaque route,
il continue à générer des itinéraires supplémentaires. Il ne parcourt
pas un simple itinéraire, il se ramifie. À cause de cela, la _récursion_
est une manière normale de modéliser ce phénomène.

> function itinerairesPossibles(depart, arrivee) {
>   function chercheItineraires(itineraire) {
>     function pasParcouru(route) {
>       return !member(itineraire.lieux, route.arrivee);
>     }
>     function continueItineraire(route) {
>       return chercheItineraires({lieux: itineraire.lieux.concat([route.arrivee]),
>                          length: itineraire.length + route.distance});
>     }
>
>     var fin = itineraire.lieux[itineraire.lieux.length - 1];
>     if (fin == arrivee)
>       return [itineraire];
>     else
>       return flatten(map(continueItineraire, filter(pasParcouru,
>                                                routesDepuis(fin))));
>   }
>   return chercheItineraires({lieux: [depart], length: 0});
> }
>
> show(itinerairesPossibles("Point Teohotepapapa", "Point Kiukiu").length);
> show(itinerairesPossibles("Hanapaoa", "Mt Ootua"));

La fonction renvoie un tableau d'objets itinéraire, chacun
contenant un tableau de lieux parcourus par l'itinéraire et une
longueur. |chercheItineraires| continue un itinéraire récursivement,
renvoyant un tableau avec toutes les extensions possibles de cette
route. Quand la fin de l'intinéraire est le lieu défini comme lieu de
fin, il retourne juste l'itinéraire, sachant que continuer l'itinéraire
serait absurde. Si c'est un autre lieu, il faut donc continuer. La
ligne contenant |flatten|/|map|/|filter| est probablement la plus dure à
appréhender. Voilà ce qu'elle dit : « Prend toutes les routes partant
de ce lieu, en te débarassant de celles qui vont à des endroits que nous
avons déjà visités. Continue chacune de ces routes, ce qui donnera pour
chacune d'entre elles un tableau d'itinéraires finis, puis met toutes ces
routes dans un grand tableau renvoyé en résultat ».

Cette ligne fait beaucoup de choses. C'est pourquoi une bonne abstraction
de la chose peut aider : elle vous permet de dire des choses compliquées
sans taper un écran entier de code.

Ceci ne risque-t-il pas de se répéter indéfiniment, en continuant à
s'appeler lui-même (via |continueItineraire|) ? Non, à un certain moment,
toutes les routes iront à des lieux déjà traversés par l'itinéraire, et
le résultat de |filter| sera un tableau vide. Cartographier un tableau vide
renvoie un tableau vide, l'écraser renvoie également un tableau vide. Donc
appeler |chercheItineraires| dans une impasse entraîne un tableau vide,
qui signifie « il n'y a aucun moyen de continuer cet itinéraire ».

Veuillez noter que les lieux sont ajoutés à des itinéraires en utilisant
_|concat|_ et non _|push|_. La méthode |concat| crée un nouveau tableau,
alors que |push| modifie le tableau existant. Parce que cette fonction risque
de faire bifurquer divers itinéraires à partir d'une seule portion de route,
il ne faut pas modifier le tableau qui représente l'itinéraire original,
parce qu'il doit être utilisé plusieurs fois.

***

Maintenant que nous avons toutes les itinéraires possibles, essayons de
trouver le plus court. Écrivez une fonction |itineraireLePlusCourt| qui,
tout comme |itinerairesPossibles|, prend les noms des lieux de début et de
fin en arguments. Elle retournera un simple objet itinéraire, du même type
que ce que |itinerairesPossibles| produit.

///

> function itineraireLePlusCourt(depart, arrivee) {
>   var itineraireLePlusCourtTrouve = null;
>   forEach(itinerairesPossibles(depart, arrivee), function(itineraire) {
>     if (!itineraireLePlusCourtTrouve || itineraireLePlusCourtTrouve.length > itineraire.length)
>       itineraireLePlusCourtTrouve = itineraire;
>   });
>   return itineraireLePlusCourtTrouve;
> }

Le point épineux quand on « minimise » ou « maximise » des algorithmes
est qu'il ne faut pas tout massacrer quand un tableau vide est renvoyé comme
résultat. Dans notre cas, on sait qu'il y aura au moins une route entre 2
lieux donnés, donc nous pouvons simplement ignorer ce problème. Mais ce
raisonnement est un peu léger. Que faire si la route entre Puamua et le Mont
Ootua, qui est escarpée et boueuse, est emportée par une pluie torrentielle
? Ce serait dommage que cela engendre une erreur dans notre fonction, donc
il faut que la fonction renvoie une valeur |null| quand aucun itinéraire
n'est trouvé.

Voici donc la méthode très fonctionnelle et qui abstrait tout ce que l'on peut :

> function minimise(func, array) {
>   var minScore = null;
>   var found = null;
>   forEach(array, function(element) {
>     var score = func(element);
>     if (minScore == null || score < minScore) {
>       minScore = score;
>       found = element;
>     }
>   });
>   return found;
> }
>
> function getProperty(propName) {
>   return function(object) {
>     return object[propName];
>   };
> }
>
> function itineraireLePlusCourt(depart, arrivee) {
>   return minimise(getProperty("length"), itinerairesPossibles(depart, arrivee));
> }

Malheureusement, cette version est trois fois plus longue que l'autre. Dans
les programmes où vous voulez minimiser un certain nombre de choses, il peut
être intéressant d'écrire un algorithme générique comme celui-ci, que vous
pourrez réutiliser. Dans la plupart des cas, la première version suffira.

Notez toutefois la fonction _|getProperty|_, elle est souvent utile quand
on fait de la programmation fonctionnelle avec des objets.

---

Voyons à quel trajet aboutit notre algorithme entre la pointe Kiukiu et la
pointe Teohotepapapa…

> show(itineraireLePlusCourt("Point Kiukiu", "Point Teohotepapapa").lieux);

---

Sur une petite île comme Hiva Oa, ce n'est pas une tâche insurmontable
de générer tous les itinéraires possibles. Si vous essayez de faire ça
sur une carte raisonnablement détaillée de la Belgique, par exemple,
cela va prendre un temps ridiculement long, sans parler d'une quantité
de mémoire démentielle. Pourtant, vous avez sans doute déjà vu de tels
planificateurs d'itinéraires en ligne. Ils vous indiquent un trajet plus
ou moins idéal parmi un énorme labyrinthe de routes possibles en quelques
secondes à peine. Comment font-ils ça ?

Si vous êtes attentif, vous avez peut-être remarqué qu'il n'est pas
nécessaire de générer tous les itinéraires jusqu'au bout. Si nous
comparons les itinéraires *pendant* que nous les élaborons, nous pouvons
cesser le calcul de ces itinéraires et dès que nous avons trouvé un
premier itinéraire pour notre destination, nous pouvons cesser l'extension
des autres itinéraires plus longs que celui-ci.

---

Pour essayer, nous utiliserons une grille de 20 sur 20 en guise de carte :
[[height.png]]

Ce que vous voyez là est une carte en relief d'un terrain montagneux. Les
points jaunes représentent les pics, et les zones bleues, les vallées. La
zone est divisée en carrés de 100 mètres de côté. Nous disposons d'une
fonction |heightAt|, qui peut nous donner l'altitude en mètres, de n'importe
quel carré de cette carte, dans laquelle les carrés sont représentés
par des objets avec des propriétés |x| et |y|.

> print(heightAt({x: 0, y: 0}));
> print(heightAt({x: 11, y: 18}));

---

Nous voulons traverser ce territoire à pied, en partant en haut à gauche
pour arriver en bas à droite. Une grille peut être assimilée à un
graphe. Chaque carré est un nœud connecté aux carrés qui l'entourent.

Nous n'aimons pas gaspiller l'énergie, donc nous préférons prendre le
chemin le plus facile. Monter est plus pénible que descendre, et descendre
plus pénible que marcher sur un terrain plat##. Cette fonction calcule le
« dénivelé » entre deux carrés adjacents, qui représente l'intensité
de la fatique que vous éprouvez à marcher ou grimper de l'un à l'autre. On
considère que monter est deux fois plus pénible que descendre.

## Si si, je vous assure.

> function distancePonderee(pointA, pointB) {
>   var differenceHauteur = heightAt(pointB) - heightAt(pointA);
>   var facteurElevation = (differenceHauteur < 0 ? 1 : 2);
>   var distanceaPlat = (pointA.x == pointB.x || pointA.y == pointB.y ? 100 : 141);
>   return distanceaPlat + facteurElevation * Math.abs(differenceHauteur);
> }

Notez le calcul de |distanceaPlat|. Si les deux points sont sur la même
ligne ou colonne, ils sont contigus, et la distance qui les sépare est
cent mètres. Sinon, on considère qu'ils sont adjacents en diagonale, et
la distance en diagonale entre deux carrés de cette taille est cent fois
la racine carrée de deux, ce qui fait à peu près |141|. Cette fonction
n'est pas autorisée à être appelée pour des carrés qui sont éloignés
de plus d'une unité (elle pourrait faire une double vérification … mais
elle est trop paresseuse).

---

Les points sur la carte sont représentés par des objets contenant des
propriétés |x| et |y|. Ces trois fonctions sont utiles quand on travaille
sur de tels objets :

> function point(x, y) {
>   return {x: x, y: y};
> }
>
> function ajoutePoints(a, b) {
>   return point(a.x + b.x, a.y + b.y);
> }
>
> function pointsIdentiques(a, b) {
>   return a.x == b.x && a.y == b.y;
> }
>
> show(pointsIdentiques(ajoutePoints(point(10, 10), point(4, -2)),
>                point(14, 8)));

***

Si nous nous mettons à chercher des trajets sur cette carte, nous
aurons encore besoin de créer des « panneaux », des listes de
directions que l'on peut prendre à un point donné. Écrivez une fonction
|directionsPossible| qui prend un objet point comme argument et renvoie un
tableau des points qui l'environnent. Nous pouvons nous déplacer seulement
vers des points adjacents, à la fois en ligne droite et en diagonale, si
bien que les carrés ont au maximum huit carrés voisins. Prenez garde à
ne pas renvoyer des carrés qui se trouveraient en-dehors de la carte. Pour
autant qu'on sache, le bord de la carte pourrait bien être le bord du monde.

///

> function directionsPossible(depart) {
>   var dimensionCarte = 20;
>   function dansLaCarte(point) {
>     return point.x >= 0 && point.x < dimensionCarte &&
>            point.y >= 0 && point.y < dimensionCarte;
>   }
>
>   var directions = [point(-1, 0), point(1, 0), point(0, -1),
>                     point(0, 1), point(-1, -1), point(-1, 1),
>                     point(1, 1), point(1, -1)];
>   return filter(dansLaCarte, map(partial(ajoutePoints, depart),
>                                directions));
> }
>
> show(directionsPossible(point(0, 0)));

J'ai créé une variable |dimensionCarte|, dans le seul but de ne pas avoir
à écrire deux fois |20|. Si, à un autre moment, nous voulons utiliser la
même fonction pour une autre carte, ce serait laborieux avec un code farci
de |20|, qu'il faudrait tous remplacer un à un. Nous pourrions même aller
jusqu'à utiliser |dimensionCarte| comme argument de |directionsPossible|, pour
pouvoir utiliser la fonction pour différentes cartes sans les modifier. J'ai
estimé que ce n'était pas nécessaire dans ce cas, de telles choses peuvent
toujours être modifiées quand le besoin s'en fait sentir.

Alors, pourquoi n'ai-je pas ajouté une variable pour stocker |0|, qui
apparaît également à plusieurs reprises ? J'ai fait comme si les cartes
commençaient toujours à |0|, donc il est peu probable que cela change,
et utiliser une variable pour cela ne fait qu'ajouter du bruit.

---

Pour trouver une route sur cette carte sans que notre navigateur n'interrompe
le programme parce qu'il prend trop de temps à se terminer, nous devons
arrêter de faire de l'amateurisme et mettre en œuvre un algorithme
sérieux. Beaucoup de travail a été consacré à de tels problèmes dans
le passé, et beaucoup de solutions ont été conçues (certaines brillantes,
d'autres inutiles). Une solution très populaire et efficace est nommé _A*_
(prononcé A étoile). Nous allons consacrer le reste de ce chapitre à
intégrer une fonction de recherche d'itinéraire A* pour notre carte.

Avant que je me penche sur l'algorithme en lui-même, laissez-moi vous en dire
un peu plus sur le problème qu'il résout. Le problème avec la recherche
de routes par l'intermédiaire de graphes, c'est que dans les grands graphes,
il y a énormément de routes. Notre chercheur de route Hiva Oa nous a montré
que quand le graphe est petit, tout ce que l'on avait besoin de faire c'était
de s'assurer que nos itinéraires ne repassaient pas par des points où ils
étaient déjà passés. Sur notre nouvelle carte, ceci ne suffit plus.

Le problème fondamental, c'est qu'il y a trop de possibilités pour aller
dans la mauvaise direction. À moins de savoir comment nous diriger vers la
destination pendant l'exploration des chemins, un choix que nous faisons pour
poursuivre une route donnée va plus probablement nous faire emprunter le
mauvais chemin que le bon. Si vous continuez à générer des itinéraires
de cette façon, et même si l'un d'entre eux atteint la cible de manière
accidentelle, vous ne savez pas si c'est le chemin le plus court.

Donc ce que vous voulez faire, c'est explorer les directions susceptibles de
vous amener à la destination finale en premier. Sur une grille comme sur
une carte, vous pouvez avoir une petite estimation de l'optimisation d'un
tracé en vérifiant sa longueur et la proximité de sa destination avec la
cible. En ajoutant la longueur et l'estimation de la distance restante, vous
pouvez vous faire une bonne idée des itinéraires qui sont prometteurs. Si
vous prolongez les itinéraires prometteurs en premier, vous avez moins de
risques de perdre du temps avec ceux qui sont inutiles.

---

Mais cela ne suffit pas encore. Si notre carte était celle d'un monde
parfaitement plat, le chemin qui semble prometteur serait presque toujours
le meilleur, et nous pourrions utiliser la méthode ci-dessus pour nous
rendre directement au but. Mais nous avons des vallées et des collines sur
notre chemin, donc il est difficile de prédire à l'avance quel itinéraire
sera le plus direct. À cause de cela, nous finissons toujours pas explorer
beaucoup trop de possibilités différentes.

Pour y remédier, nous pouvons tirer parti du fait que nous recherchons sans
arrêt l'itinéraire le plus prometteur. Une fois que l'on a déterminé
que le chemin A est le meilleur moyen de se rendre au point X, nous pouvons
nous en souvenir. Quand plus tard le chemin B se rend aussi au point X,
nous savons que ce n'est pas la meilleure route, donc nous n'avons pas à
faire plus de recherches dessus. Ceci peut éviter à notre programme de
tracer beaucoup d'itinéraires inutiles.

---

Donc, l'algorithme ressemble à quelque chose comme ça :

Il y a deux ensembles de données pour garder un historique. Le premier est
appelé la liste ouverte, elle contient des itinéraires partiels qui doivent
toujours être explorés. Chaque chemin a une note, qui est calculée en
additionnant sa longueur à la distance estimée qui sépare du but. Cette
estimation doit toujours être optimiste, elle ne doit jamais exagérer la
longueur. Le second est un ensemble de nœuds que nous avons parcouru, avec
l'itinéraire partiel qui nous y a amené. Celui-ci, nous l'appellerons la
liste des nœuds atteints. On commence en ajoutant à la liste ouverte un
itinéraire qui contient uniquement le nœud de départ et on l'enregistre
dans la liste des nœuds atteints.

Puis, tant qu'il y a des nœuds dans la liste ouverte, nous prenons celui qui
a le plus petit score (donc le meilleur), et nous trouvons les directions
dans lesquels il peut continuer (en appelant |directionsPossible|). Pour
chaque nœud obtenu en retour, nous créons un nouveau chemin en le
rattachant à notre route initiale et en ajustant la longueur du chemin
par l'intermédiaire de |distancePonderee|. L'extrémité de chacun de ces
itinéraires est ensuite recherchée dans la liste des nœuds atteints.

Si le nœud n'est pas dans la liste des nœuds atteints, cela veut dire que
nous ne l'avons pas encore rencontré avant, nous ajoutons le nouveau chemin à
la liste ouverte, et nous l'enregistrons dans la liste des nœuds parcourus. Si
nous l'*avons* vu avant, nous comparons la note du nouvel itinéraire aux notes
des autres itinéraires de la liste des nœuds parcourus. Si le nouveau chemin
est plus court, on remplace la route existante avec la nouvelle. Autrement,
on se débarrasse du nouvel itinéraire puisque on a déjà une manière
plus rapide de se rendre à ce point.

On continue ainsi jusqu'à ce que l'itinéraire que nous sortons de la liste
des nœuds parcourus atteigne le nœud correspondant au but ultime, auquel
cas nous avons trouvé notre itinéraire, ou jusqu'à ce que la liste des
nœuds parcourus soit vide, auquel cas nous nous sommes rendus compte qu'il
n'y a pas de route. Dans notre cas, la carte ne contient pas d'obstacles
insurmontables, donc il y a toujours un chemin.

Comment savons-nous que le premier itinéraire complet que nous obtenons de
la liste des nœuds parcourus est le plus direct ? C'est la conséquence
du fait que nous nous intéressons seulement à un chemin quand il fait
le score le plus bas. Le score d'un itinéraire est sa longueur actuelle
additionnée d'un estimation *optimiste* de sa longueur restante. Cela
veut dire que si un itinéraire obtient la note la plus basse dans la liste
ouverte, c'est toujours le chemin le plus direct vers sa destination finale,
c'est impossible pour un autre itinéraire de trouver plus tard une meilleure
route vers ce point, car si elle était meilleure, son score serait plus bas.

---

Essayez de ne pas vous énerver lorsque les subtilités de ce fonctionnement
vous échappent. Quand on réfléchit à des algorithmes tels que ceux là,
avoir vu avant « quelque chose qui y ressemble »  aide beaucoup, cela
vous donne un point de repère pour comparer les approches. Les programmeurs
débutants doivent faire sans de tels points de repères, ce qui peut les
amener facilement à s'égarer. Ayez simplement conscience que ce travail est
d'un niveau assez avancé, faites une lecture globale du reste du chapitre,
et revenez-y plus tard quand vous vous sentirez de taille à relever le défi.

---

Je suis désolé de vous l'annoncer, mais pour une partie de l'algorithme,
je vais encore devoir invoquer la magie. La liste ouverte nécessite de
pouvoir disposer d'une grande quantité de routes, et de trouver rapidement
celle qui fait le plus petit score. Les enregistrer dans un tableau normal et
parcourir ce tableau chaque fois est beaucoup trop lent, je vous donne donc
une structure de données appelée _tas binaire_. Vous les créez avec |new|,
tout comme les objets |Date|, en leur donnant une fonction qui est utilisée
pour « donner un score » aux éléments passés en argument. L'objet
résultant possède les méthodes |push| et |pop|, tout comme un tableau,
mais |pop| donne toujours l'élément avec le plus petit score, au lieu de
donner celui qui a été ajouté (avec la méthode |push|) en dernier.

> function identity(x) {
>   return x;
> }
>
> var heap = new BinaryHeap(identity);
> forEach([2, 4, 5, 1, 6, 3], function(number) {
>   heap.push(number);
> });
> while (heap.size() > 0)
>   show(heap.pop());

L'\\cbinaryheap traite de l'implémentation de la structure de données, ce
qui est assez intéressant. Après avoir lu le \\coo, vous pourriez vouloir
jeter un œil dessus.

---

Les nécessités de l'optimisation peut avoir un autre effet. L'algorithme
d'Hiva Oa utilisait des tableaux de destination pour enregistrer les
routes, et copiait celles-ci avec la méthode |concat| quand il allongeait
ces routes. Cette fois, nous ne pouvons pas nous permettre de copier des
tableaux puisque nous explorerons des tonnes de chemins. À la place, nous
allons utiliser une « chaîne » d'objets pour stocker une route. Chaque
objet dans la chaîne possède des propriétés, notamment la position sur la
carte et la longueur de la route déjà effectuée, mais garde également en
mémoire une propriété qui pointe vers l'objet précédent de la chaîne. Ça
donne quelque chose comme ça :

[[objectchain.png]]

Les cercles couleur cyan sont les objet utiles, et les lignes sont les
propriétés. L'objet |A| est le debut de la route ici. L'objet |B| est
utilisé pour construire un nouveau tracé qui se prolonge après |A|. Quand on
doit plus tard reconstruire une route, on peut se reposer sur ces propriétés
pour trouver tous les points par où la route est passée. On remarque que
l'objet |B| appartient à deux routes, une qui se termine en |D|, et une
autre qui se termine en |E|. Quand il y a beaucoup de routes, cela peut
nous sauver beaucoup d'espace mémoire, chaque nouvelle route nécessite
seulement un nouvel objet pour elle même, le reste est partagé avec les
autres routes qui ont commencé de la même manière.

***

Écrivez une fonction |distanceEstimee| qui donne une estimation optimiste
de la distance séparant deux emplacements. Elle n'a pas besoin de
s'intéresser aux données d'altitude, mais peut supposer que le terrain est
plat. Rappelez-vous que l'on se déplace seulement tout droit et en diagonale,
et que l'on compte les déplacements en diagonale entre deux carrés comme
valant |141|.

///

> function distanceEstimee(pointA, pointB) {
>   var dx = Math.abs(pointA.x - pointB.x),
>       dy = Math.abs(pointA.y - pointB.y);
>   if (dx > dy)
>     return (dx - dy) * 100 + dy * 141;
>   else
>     return (dy - dx) * 100 + dx * 141;
> }

Ces formules étranges sont utilisées pour décomposer le trajet en une
partie rectiligne et une partie en diagonale. Si vous avec un trajet tel
que celui-là :

[[diagonalpath.png]]

... le chemin fait |8| cases de larges et |4| de haut, donc vous avez |8 -
4 = 4| déplacements rectilignes et |4| déplacements en diagonales.

Si vous écriviez une fonction qui calcule la distance « pythagoricienne
» directe entre ces points, cela fonctionnerait aussi. Ce dont nous avons
besoin est d'une estimation optimiste, et supposer que nous pouvons aller
tout droit vers notre but est certainement optimiste. Quoi qu'il en soit,
plus notre estimation est correcte, moins notre programme essaiera des
itinéraires inutiles.

***

Nous allons utiliser un tas binaire pour stocker la liste ouverte. Quelle
structure serait la bonne pour la liste des nœuds atteints ? Cette
liste sera utilisée pour chercher des routes, en lui passant un
couple |x|, |y| de coordonnées. Rapidement de préférence. Ecrivez
trois fonctions |creeListePointsAtteints|, |enregistrePointAtteint|, et
|cherchePointAtteint|. La première crée la structure de données ; la
seconde, étant donnée une liste de nœuds atteints, un point, et une route,
stocke cette route; la dernière, étant donné une liste de nœuds atteints
et un point, retourne une route ou |undefined| pour indiquer qu'aucune route
n'a été trouvée pour ce point.

///

Une idée raisonnable serait d'utiliser un objet avec des objets à
l'intérieur. Une des coordonnées des points, par exemple |x|, est utilisé
comme nom de propriété pour l'objet extérieur, et l'autre, |y|, pour l'objet
intérieur. Cela va nécessiter un peu de tenue de compte pour gérer le fait
que, parfois, l'objet intérieur que nous recherchons n'existe pas (encore).

> function creeListePointsAtteints() {
>   return {};
> }
>
> function enregistrePointAtteint(liste, point, itineraire) {
>   var listeInterne = liste[point.x];
>   if (listeInterne == undefined) {
>     listeInterne = {};
>     liste[point.x] = listeInterne;
>   }
>   listeInterne[point.y] = itineraire;
> }
>
> function cherchePointAtteint(liste, point) {
>   var listeInterne = liste[point.x];
>   if (listeInterne == undefined)
>     return undefined;
>   else
>     return listeInterne[point.y];
> }

Une autre possiblité est de fusionner les |x| et |y| du point en un nom
unique de propriété, et de l'utiliser pour stocker les itinéraires dans
un objet unique.

> function pointID(point) {
>   return point.x + "-" + point.y;
> }
>
> function creeListePointsAtteints() {
>   return {};
> }
>
> function enregistrePointAtteint(liste, point, itineraire) {
>   liste[pointID(point)] = itineraire;
> }
>
> function cherchePointAtteint(liste, point) {
>   return liste[pointID(point)];
> }

---

@_encapsulation_ Définir un type de structure données en fournissant un
ensemble de fonctions pour créer et manipuler de telles structures est une
technique utile. Cela permet « d'isoler » le code qui utilise la structure,
des détails de la structure elle-même. Remarquez que, peu importe laquelle
des deux implémentations ci-dessus est utilisée, le code qui a besoin d'une
liste des nœuds atteints fonctionne exactement de la même façon. Il ne
se préoccupe pas du type d'objet utilisé, tant qu'il reçoit le résultat
qu'il attend.

On discutera plus en détail de cela au \\coo, où nous apprendrons à
faire des types d'objet comme |BinaryHeap| (tas binaire), qui sont créés
en utilisant |new| et qui ont des méthodes pour les manipuler.

---

Nous avons donc enfin notre vrai fonction de recherche de chemin :

> function chercheItineraire(depart, arrivee) {
>   var listeOuverte = new BinaryHeap(scoreItineraire);
>   var pointsAtteints = creeListePointsAtteints();
>
>   function scoreItineraire(itineraire) {
>     if (itineraire.score == undefined)
>       itineraire.score = distanceEstimee(itineraire.point, arrivee) +
>                     itineraire.longueur;
>     return itineraire.score;
>   }
>   function ajouteItineraireOuvert(itineraire) {
>     listeOuverte.push(itineraire);
>     enregistrePointAtteint(pointsAtteints, itineraire.point, itineraire);
>   }
>   ajouteItineraireOuvert({point: depart, longueur: 0});
>
>   while (listeOuverte.size() > 0) {
>     var itineraire = listeOuverte.pop();
>     if (pointsIdentiques(itineraire.point, arrivee))
>       return itineraire;
>
>     forEach(directionsPossible(itineraire.point), function(direction) {
>       var itineraireConnu = cherchePointAtteint(pointsAtteints, direction);
>       var nouvelleLongueur = itineraire.longueur +
>                       distancePonderee(itineraire.point, direction);
>       if (!itineraireConnu || itineraireConnu.longueur > nouvelleLongueur){
>         if (itineraireConnu)
>           listeOuverte.remove(itineraireConnu);
>         ajouteItineraireOuvert({point: direction,
>                       from: itineraire,
>                       longueur: nouvelleLongueur});
>       }
>     });
>   }
>   return null;
> }

Premièrement, il crée les structures de données dont il a besoin :
une liste ouverte et une liste des nœuds atteints. |scoreItineraire|  est
la fonction de calcul de score passée au tas binaire. Remarquez comment
il stocke ses résultats dans l'objet route, pour éviter d'avoir à le
recalculer plusieurs fois.

|ajouteItineraireOuvert| est une fonction commode pour ajouter une nouvelle
route à la fois à la liste ouverte et à la liste des nœuds atteints. On
l'utilise immédiatement pour ajouter le début de la route. Remarquez que
les objets route ont roujours une propriétés |point|, qui stocke le point
d'arrivée de la route, et |longueur|, qui stocke la longueur courante de
la route. Les routes qui ont plus d'une case de longueur, ont aussi une
propriété |depart|, qui pointe sur leurs prédécesseurs.

La boucle |while|, comme décrit dans l'algorithme, prend constamment la route
de plus faible score dans la liste ouverte et vérifie si cela nous mène
au but. Si ce n'est pas le cas, on doit continuer en l'étendant. C'est ce
dont s'occupe |forEach|. Il cherche si ce nouveau point est dans la liste
des nœuds atteints. S'il ne le trouve pas, ou si le nœud trouvé a une
route plus longue que la nouvelle route, un nouveau objet route est créé
et ajouté à la liste ouverte et la liste des nœuds atteints, et la route
existante (s'il y en a une) est supprimée de la liste ouverte.

Que se passe-t-il si la  route dans |itineraireConnu| n'est pas dans la
liste ouverte ? Cela peut arriver, car les routes ne sont supprimés de
la liste ouverte que lorsqu'on a déterminé qu'elles étaient la route
optimale pour atteindre leur destination. Si  nous essayons de supprimer
du tas binaire, une valeur qui n'y ait pas, cela va lever une exception,
donc si mon raisonnement est faux, nous verrons probablement un exception
au moment d'exécuter la fonction.

Quand le code devient suffisamment complexe pour vous faire douter de certaines
choses à son propos, c'est une bonne idée d'ajouter quelques vérifications
qui lèvent une exception quand quelque chose se passe mal. De cette façon,
vous savez qu'il ne se passe rien de bizarre « silencieusement »,
et quand vous cassez quelque chose, vous saurez immédiatement ce que vous
avez cassé.

---

Remarquez que cette algorithme n'utilise pas la récursion, mais réussit quand
même à explorer toutes les branches. La liste ouverte remplace plus ou moins
le rôle qu'avait la pile d'appel de fonction dans la solution récursive
du problème Hiva Oa : il garde une trace des chemins qui doivent encore
être parcourus. Chaque algorithme récursif peut être réécrit d'une
façon non-récursive et utilisant une structure de données qui stocke les
« choses encore à faire ».

---

Bien, essayons notre recherche de route :

> var route = chercheItineraire(point(0, 0), point(19, 19));

Si vous avez exécuter tout le code depuis le début du chapitre, et que
vous n'avez pas introduit d'erreurs, cet appel, même si cela peut prendre
quelques secondes à s'exécuter, devrait vous donner un objet route. Cet
objet est plutôt difficile à lire. On peut le faire en utilisant la fonction
|showRoute| qui, si votre console est assez grande, vous montrera une route
sur une carte.

> showRoute(route);

Vous pouvez également passer plusieurs routes à |showRoute|, ce qui peut
être utile si, par exemple, vous voulez planifier un itinéraire touristique,
qui doit inclure le magnifique point de vue en |11|, |17|.

> showRoute(chercheItineraire(point(0, 0), point(11, 17)),
>           chercheItineraire(point(11, 17), point(19, 19)));

---

Les variations sur le thème @_recherche_chercher un itinéraire optimal dans
un graphe peut être appliqué à de nombreux problèmes, dont beaucoup
ne sont pas liés au fait de trouver un chemin physique. Par exemple,
un programme qui résout le problème de faire rentrer un nombre donné de
blocs dans un espace limité, peut être résolu en explorant les différents
'chemins' possibles qu'il obtient en essayant de positionner un certain bloc
à une certaine place. Les chemins se terminant avec un manque de place pour
les derniers blocs sont des culs-de-sac, et le chemin qui permet de faire
rentrer tous les blocs dans l'espace est la solution.

=================================
Programmation orientée objet / oo
=================================

Au début des années 90, une chose appelée _programmation orientée objet_
souffla un vent nouveau sur l'industrie du logiciel. La plupart des idées
derrière ce concept n'étaient pas vraiment nouvelles, mais elles avaient
enfin suffisamment d'élan pour décoller, et devenir « à la mode ». Des
livres furent écrits sur le sujet, des cours furent organisés, des langages
de programmation développés. Tout d'un coup, tout le monde se mit à vanter
les mérites de la programmation orientée objet, appliquant ses recettes
à tous les problèmes avec enthousiasme, se convainquant qu'on avait enfin
trouvé *la bonne façon d'écrire des programmes*.

Ces choses arrivent souvent. Quand un problème est compliqué. Les gens
cherchent toujours une solution magique.
Quand arrive quelque chose qui ressemble à cette solution, ils sont prêts
à s'y jeter corps et âme. Pour de nombreux programmeurs, encore aujourd'hui,
l'orientation objet (ou du moins la vision qu'ils en ont) est la panacée. Si
un programme n'est pas « en pur objet », quel que soit le sens de cette
expression, il est considéré comme résolument inférieur.

Toutefois, peu d'engouements ont duré si longtemps. La longévité de la
programmation orientée objet peut sûrement s'expliquer par le fait que les
idées centrales de concept sont utiles et simples. Dans ce chapitre, nous
allons parler de ces idées et de leur application, plutôt excentrique, au
JavaScript. Les paragraphes précédents n'étaient absolument pas destinés
à discréditer ces idées. Mon objectif était juste d'éviter qu'on ne
jure plus que par elles.

---

Comme son nom l'indique, la programmation orientée objet est centrée sur
la notion d'objet. Depuis le début, nous avons utilisé les objets comme
des espèces de fourre-tout plein de valeurs, où l'on ajoute ou modifie des
propriétés à notre guise. En fait, dans une approche orientée objet, les
objets sont vus comme des microcosmes indépendants, qui ne communiquent avec
l'extérieur qu'à travers un nombre limité d'_interface_s, un ensemble de
méthodes et propriétés spécifiques. La « liste des nœuds atteints »
utilisée à la fin du \\csearch en est un exemple : nous avons utilisé
trois fonctions, |makeReachedList|, |storeReached| et |findReached| pour
interagir avec. Ces trois fonctions forment une interface pour ces objets.

Les objets |Date|, |Error| et |BinaryHeap| que nous avons vus fonctionnent
également comme cela. Au lieu de fournir des fonctions classiques pour
travailler avec ces objets, ils fournissent une manière d'être créés,
via le mot-clé |new|, et un certain nombre de méthodes et propriétés
qui forment le reste de l'interface.

---

Pour faire une méthode d'objet, il suffit de définir une variable qui
contiendra une fonction.

> var lapin = {};
> lapin.parler = function(tirade) {
>   print("Le lapin dit '", tirade, "'");
> };
>
> lapin.parler("Eh bien, maintenant c'est vous qui me le demandez.");

Dans la plupart des cas, la méthode aura besoin de savoir sur *qui*
elle doit s'appliquer. Par exemple, s'il y a plusieurs lapins, la méthode
|parler| doit pouvoir indiquer quel est le lapin qui parle. Pour ce faire,
il y a une variable spéciale appelée _|this|_, qui est toujours définie
à l'intérieur d'une fonction et qui pointe vers l'objet sur lequel la
fonction s'applique. Une fonction est appelée une méthode quand elle est
définie en tant que propriété d'un objet, et appelée directement comme
dans |objet.methode()|.

> function parler(tirade) {
>   print("Le ", this.adjectif, " lapin dit « ", tirade, " »");
> }
> var lapinBlanc = {adjectif: "blanc", parler: parler};
> var grosLapin = {adjectif: "gros", parler: parler};
>
> lapinBlanc.parler("Par ma moustache et mes oreilles, comme il se fait tard !");
> grosLapin.parler("J'ai bien envie d'une carotte, maintenant.");

---

Je peux maintenant clarifier la présence du mystérieux premier argument
de la méthode _|apply|_, pour lequel nous avons toujours mis |null| dans le
\\cfp. Cet argument peut être utilisé pour spécifier un objet sur lequel
la fonction s'appliquera, qui prendra donc le rôle de |this|. Toutefois,
pour les fonctions qui ne sont pas des méthodes, cela n'a pas de sens,
d'où le |null|.

> parler.apply(grosLapin, ["Miam."]);

Les fonctions ont également une méthode _|call|_, qui se comporte comme
|apply|, à l'exception du fait que les arguments peuvent être fournis
séparéments, et non dans un tableau :

> parler.call(grosLapin, "Rot.");

---

Le mot-clé _|new|_ fournit un bon moyen de créer de nouveaux objets. Quand
une fonction est appelée avec le mot |new| devant, sa variable _|this|_
pointe sur un *nouvel* objet, qui sera automatiquement retourné (à moins que
la fonction ne retourne explicitement autre chose). Les fonctions utilisées
pour créer de nouveaux objets comme ça sont appelées des _constructeur_s. En
voici un pour les lapins :

> function Lapin(adjectif) {
>   this.adjectif = adjectif;
>   this.parler = function(tirade) {
>     print("Le ", this.adjectif, " lapin dit '", tirade, "'");
>   };
> }
>
> var lapinTueur = new Lapin("tueur");
> lapinTueur.parler("GRAAAAAAAAAH!");

Il y a une convention, parmis les programmeurs JavaScript, qui consiste
à faire débuter les noms de constructeurs par une lettre majuscule. Cela
permet de mieux les reconnaîtres au milieu des autres fonctions.

Mais pourquoi le mot clés |new| est-il nécessaire ? Après tout, nous
aurions pu écrire simplement :

> function creerLapin(adjectif) {
>   return {
>     adjectif: adjectif,
>     parler: function(tirade) {/*etc*/}
>   };
> }
>
> var lapinNoir = creerLapin("noir");

Mais ce n'est pas exactement la même chose. |new| en fait discrètement
plus. En fait, notre fonction |lapinTueur| a une propriété
appelée _|constructor|_, qui pointe vers la fonction |Lapin| l'ayant
créée. |lapinNoir| a également cette propriété, mais elle pointe vers
la fonction _|Object|_.

> show(lapinTueur.constructor);
> show(lapinNoir.constructor);

---

D'où vient la propriété |constructor| ? Elle fait partie du _prototype_
d'un lapin. Les prototypes sont une partie importante du fonctionnement
des objets en JavaScript. Chaque objet est basé sur un prototype, qui
lui confère un ensemble de propriétés. Les objets simples que nous
avons utilisés jusque là sont tous basés sur le plus élémentaires des
prototypes, celui associé au constructeur |Object|. En fait, taper |{}|
est équivalent à taper |new Object()|.

> var objetSimple = {};
> show(objetSimple.constructor);
> show(objetSimple.toString);

_|toString|_ est une méthode qui fait partie du prototype |Object|. Ça
signifie que tous les objets de base ont une méthode |toString|, qui les
converti en chaîne de caractères. Nos objets lapin sont basés sur le
prototype associé au constructeur |Lapin|. Il est possible d'utiliser
la propriété |prototype| d'un constructeur pour accèder à… leur
prototype :

> show(Lapin.prototype);
> show(Lapin.prototype.constructor);

Chaque fonction est automatiquement munie d'une propriété |prototype|,
dont la propriété |constructor| renvoie à la fonction. Puisque que le
prototype « lapin » est lui-même un objet, il est basé sur le prototype
|Object|, et partage sa méthode |toString|.

> show(lapinTueur.toString == objetSimple.toString);

---

Même si les objets semblent partager des propriétés avec leur prototype, ce
partage n'est qu'à sens unique. Les propriétés des prototypes influencent
les objets basés dessus, mais les propriétés de cet objet ne changent
jamais le prototype.

Les règles sont précisément les suivantes : pour trouver la valeur d'une
propriété, JavaScript cherche d'abord parmis les propriétés de l'objet
*lui-même*. S'il y a une propriété qui porte le nom de l'on recherche,
c'est sa valeur que l'on obtient. S'il n'y en a pas, la recherche se poursuit
à travers le prototype de l'objet, et ensuite à travers le prototype du
prototype, et ainsi de suite. Si aucune propriété n'est trouvée, c'est
la valeur |undefined| qui est renvoyée. À l'inverse, lorsqu'on *défini*
la valeur d'une propriété, JavaScript ne remonte jamais au prototype,
il attribue directement la valeur à une propriété de l'objet lui-même.

> Lapin.prototype.dents = "petites";
> show(lapinTueur.dents);
> lapinTueur.dents = "longues, pointues et sanglantes";
> show(lapinTueur.dents);
> show(Lapin.prototype.dents);

Cela signifie que le prototype peut être utilisé pour ajouter des
propriétés et des méthodes à tous les objets basés dessus. Par exemple,
il se peut que nos lapins aient soudainement besoin de danser.

> Lapin.prototype.danser = function() {
>   print("Le ", this.adjectif, " lapin danse une jigue.");
> };
>
> lapinTueur.danser();

Et, comme vous vous en doutez, le prototype de lapin est le meilleur
endroit où ajouter des éléments communs à tous les lapins, comme la
méthode |parler|. Voici donc une nouvelle approche pour notre constructeur
de |Rabbit| :

> function Lapin(adjectif) {
>   this.adjectif = adjectif;
> }
> Lapin.prototype.parler = function(tirade) {
>   print("Le ", this.adjectif, " lapin dit '", tirade, "'");
> };
>
> var noisetteLeLapin = new Lapin("noisette");
> noisetteLeLapin.parler("Good Frith!");

---

Le fait que tous les objets aient leur prototype et reçoivent des propriétés
de ce prototype peut apporter quelques complications. Ça signifie qu'utiliser
un objet pour stocker des trucs, comme les chats du \\cdata, peut mal se
passer. Par exemple, si nous nous étions demandé s'il y a un chat nommé
« |constructor| », nous aurions implémenté le test suivant :

> var pasUnSeulChat = {};
> if ("constructor" in pasUnSeulChat)
>   print("Oui, il y a sans aucun doute un chat appelé « constructor ».");

C'est problématique. Un autre problème tiens au fait qu'il est souvent
pratique d'étendre les prototypes des constructeurs standards comme |Object|
ou |Array| avec de nouvelles fonctions. Par exemple, nous pouvons donner à
tous les objets une méthode nommée |properties|, qui retourne un tableau
contenant le nom des propriétés (non cachées) d'un objet.

> Object.prototype.properties = function() {
>   var result = [];
>   for (var property in this)
>     result.push(property);
>   return result;
> };
>
> var test = {x: 10, y: 3};
> show(test.properties());

Et cela met tout de suite le problème en évidence. Maintenant que le
prototype |Object| a une propriété appelée |properties|, parcourir les
propriétés de n'importe quel objet, en utilisant |for| et _|in|_, renverra
également cette propriété partagée, ce qui n'est généralement pas ce
que nous souhaitons. Nous sommes seulement intéressés par les propriétés
que l'objet a lui-même.

Heureusement, il y a un moyen de trouver si une propriété appartient à un
objet lui-même, ou à l'un de ses prototypes. Malheureusement, cela complique
un peu le parcours des propriétés d'un objet. Tout objet a une méthode
appelée _|hasOwnProperty|_, qui nous indique si l'objet a une propriété
de ce nom. En se basant sur ce mécanisme, nous pouvons ré-écrire notre
méthode |properties| de la manière suivante :

> Object.prototype.properties = function() {
>   var result = [];
>   for (var property in this) {
>     if (this.hasOwnProperty(property))
>       result.push(property);
>   }
>   return result;
> };
>
> var test = {"Gros Igor": true, "Boule de feu": true};
> show(test.properties());

@_|forEachIn|_Et bien sûr, nous pouvons abstraire cela dans une fonction
de haut niveau. Notez que la fonction |action| est appelée avec à la fois
le nom de la propriété et la valeur qu'elle a dans l'objet.

> function forEachIn(objet, action) {
>   for (var property in objet) {
>     if (objet.hasOwnProperty(property))
>       action(property, objet[property]);
>   }
> }
>
> var chimere = {visage: "lion", corps: "chèvre", derrière: "serpent"};
> forEachIn(chimere, function(name, value) {
>   print("Un ", name, " de ", value, ".");
> });

Mais, que se passe-t-il si on rencontre un chat nommé |hasOwnProperty|
? (on ne sait jamais.)
Il sera stocké dans l'objet, et la tentative suivante de parcourir la
collection de chats, utilisant |objet.hasOwnProperty|, sera un échec, car
cette propriété ne pointera plus vers la fonction. Une façon d'éviter
ce problème est d'agir encore plus salement :

> function forEachIn(objet, action) {
>    for (var property in objet) {
>        if (Object.prototype.hasOwnProperty.call(objet, property))
>            action(property, objet[property]);
>    }
> }
>
> var test = {name: "Mardochée", hasOwnProperty: "Oh-oh"};
> forEachIn(test, function (name, value) {
>    print ("Property ", name, " = ", value);
> });

(Note : Cet exemple ne fonctionne pas pour l'instant correctement dans
Internet Explorer 8, qui a semble-t-il des problèmes avec la redéfinition
des propriétés intégrées.)

Ici, au lieu d'utiliser la méthode trouvée dans l'objet lui-même, nous
prenons la méthode fournie par le prototype |Object|, et l'appliquons en
utilisant |call| sur le bon objet. À moins que quelqu'un n'ait joué avec
la méthode de |Object.prototype| (et ne faîtes pas ça), le programme
devrait fonctionner correctement.

---

|hasOwnProperty| peut également être utilisée dans les situations où l'on
utilise l'opérateur _|in|_ pour savoir si un objet contient une propriété
particulière. Mais il y a encore une subtilité. Nous avons vu dans le
\\cdata que certaines propriétés, comme |toString|, sont 'hidden' (NdT:
cachées), et ne sont donc pas considérées lors du parcours des éléments
d'un objet via une instruction |for|/|in|. Il s'avère que les navigateurs
de la famille Gecko (Firefox principalement) donnent à chaque objet une
propriété cachée nommée |__proto__|, qui pointe vers le prototype
de cet objet. |hasOwnProperty| retourne |true| (NdT: vrai), pour cette
propriété, même si le programme ne l'a pas explicitement ajoutée. Avoir
accès au prototype d'un objet peut être très pratique, mais en faire
une propriété comme ça n'était pas une très bonne idée. Toutefois,
Firefox est un navigateur web très utilisé, et il convient de faire
attention à cela quand vous écrivez des programmes pour le web. Il y a
une méthode _|propertyIsEnumerable|_, qui retourne |false| (NdT: faux),
pour les propriétés cachées, et peut donc être utilisé pour filtrer
les étrangetés comme |__proto__|. Pour contourner ce problème de manière
fiable, on peut utiliser une expression comme :

> var objet = {foo: "bar"};
> show (Object.prototype.hasOwnProperty.call(objet, "foo") &&
>    Object.prototype.propertyIsEnumerable.call(objet, "foo"));

Simple et agréable n'est-ce pas ? C'est l'un des aspects de JavaScript qui ne
sont pas-si-bien-conçus-que-ça. Les objets jouent à la fois le role de «
valeurs avec méthodes », qui fonctionnent très bien avec les prototypes,
et « d'ensemble de propriétés », pour lesquels les prototypes ne font
que déranger.

---

Écrire l'expression ci-dessus à chaque fois qu'on a besoin de vérifier la
présence d'une propriété dans un objet n'est pas viable. Nous pourrions
le mettre dans une fonction, mais une meilleur approche est encore d'écrire
un constructeur et un prototype dédié aux situations où nous voulons
utiliser un objet simplement comme un ensemble propriétés. Puisqu'il est
prévu pour pouvoir y chercher des choses par leurs noms, nous l'appellerons
un _|Dictionnaire|_.

> function Dictionary(startValues) {
>   this.values = startValues || {};
> }
> Dictionary.prototype.store = function(name, value) {
>   this.values[name] = value;
> };
> Dictionary.prototype.lookup = function(name) {
>   return this.values[name];
> };
> Dictionary.prototype.contains = function(name) {
>   return Object.prototype.hasOwnProperty.call(this.values, name) &&
>     Object.prototype.propertyIsEnumerable.call(this.values, name);
> };
> Dictionary.prototype.each = function(action) {
>   forEachIn(this.values, action);
> };
>
> var couleurs = new Dictionary({Grover: "bleu",
>                               Elmo: "orange",
>                               Bart: "jaune"});
> show(couleurs.contains("Grover"));
> show(couleurs.contains("constructor"));
> couleurs.each(function(name, couleur) {
>   print(name, " est ", couleur);
> });

Désormais, tous les inconvénients de l'utilisation des objets en tant
qu'ensemble de propriétés sont « cachés » derrière une interface
pratique : un constructeur et quatre méthodes. Notez que la propriété
|valeurs| d'un objet |Dictionary| ne fait pas partie de son interface, ce
n'est qu'un détail interne, et quand vous utilisez des objets |Dictionary|,
vous n'avez pas besoin de l'utiliser directement.

Chaque fois que vous écrivez une interface, il est utile d'y ajouter un
commentaire retraçant rapidement ce qu'elle fait et comment l'utiliser. De
cette manière, quand quelqu'un (éventuellement vous dans trois mois),
souhaite travailler avec cette interface, ils peuvent se faire rapidement
une idée de comment l'utiliser, et n'ont alors pas besoin d'étudier tout
le programme.

La plupart du temps, quand vous concevez une nouvelle interface, vous êtes
rapidement confrontés à des problèmes et des limitations, quelque soit
votre sujet, et changez donc votre interface. Pour éviter de perdre du
temps, il est conseillé de ne documenter vos interfaces *qu'après* les
avoir expérimentées un certain temps sur des cas concrets, et qu'elles
se soient révélées efficaces. -- Biensûr, cela pourrait augmenter la
tentation de ne pas documenter du tout. Mais personnellement, je considère
la documentation comme une « touche finale », à ajouter au système. Quand
ça donne l'impression d'être prêt, c'est qu'il est temps d'écrire un peu
sur le sujet, et de voir si ça sonne aussi bien en français (ou n'importe
quelle autre langage vivante), qu'en JavaScript (où n'importe quel autre
langage de programmation).

---

La distinction entre l'interface d'un objet et ses détails de fonctionnement
internes est importante pour deux raisons. D'abord, avoir une petite interface
bien décrite rend un objet plus facile à utiliser. Il suffit de garder
l'interface en tête, sans plus se préoccuper du reste, à moins d'avoir
à changer l'objet lui-même.

Ensuite, il arrive régulièrement d'avoir à changer quelque chose dans le
fonctionnement interne d'un type## d'objet, pour le rendre plus efficace par
exemple, ou pour corriger un problème. Si le code extérieur a accès à
toutes les propriétés d'un objet, il est difficile de changer le moindre
détail sans avoir à mettre à jour tout le reste du code. Si le code
extérieur utilise une petite interface, vous pouvez changer le fonctionnement
interne de l'objet comme bon vous semble, tant que l'interface ne change pas.

## Ces types sont souvent appelés des « classes » dans d'autres langages
de programmation.

Certaines personnes vont assez loin avec ce concept. Ils n'incluent, par
exemple, aucune propriété dans l'interface d'un objet, et n'y autorisent que
des méthodes -- si leur type d'objet a une longueur, elle sera accessible
via une méthode |getLength|, et pas directement comme une propriété
|length|. De cette manière, si jamais ils décident de modifier leur objet
de telle manière qu'il n'a plus de propriété |length|, par exemple parce
que la longueur à retourner devient celle d'un tableau, ils peuvent mettre
la fonction à jour, sans changer l'interface.

Mon expérience sur le sujet est que dans la plupart des cas ça n'en vaut
pas la peine. Ajouter une méthode |getLength| qui ne contient que |return
this.length;| ne fait qu'ajouter du code inutile, qui, dans la plupart des
cas ajoute plein de problèmes alors que j'ai rarement l'occasion de changer
l'interface de mes objets.

---

Ajouter de nouvelles méthodes à des prototypes existants peut être très
utile. En particulier les prototypes de |Array| et |String| en JavaScript
peuvent recevoir quelques méthodes basiques supplémentaires. Nous pouvons,
par exemple, remplacer |forEach| et |map| par des méthodes sur les tableaux,
et transformer la fonction |startsWith| que nous avons écrite au \\cdata
en méthode sur les chaînes de caractère.

De plus, si votre programme doit fonctionner sur la même page web qu'un autre
programme (qu'il soit de vous ou non) qui utilise naïvement |for|/|in| --
comme nous l'avons vu jusque là -- alors ajouter des choses aux prototypes,
et précisément à ceux d'|Object| et |Array| aura toutes les chances de
casser quelque chose, vu que ces boucles vont d'un coup se mettre à inclure
les nouvelles propriétés. Du coup, certaines personnes préfèrent ne pas
toucher du tout à ces prototypes. Mais bien sûr, si vous êtes prudent,
et qu'il n'y a aucune raison que votre code cohabite avec un code mal écrit,
ajouter des méthodes aux prototypes standards est une très bonne technique.

---

Dans ce chapitre, nous allons fabriquer un terrarium virtuel, une boîte
en verre avec des insectes vivant dedans. Ça impliquera de jouer avec des
objets (ce qui tombe assez bien vu le nom du chapitre). Nous allons adopter
une approche assez simple, en modélisant le terrarium par une grille à
deux dimensions, comme la deuxième carte du \\csearch. Sur cette grille,
il y a un certain nombre de bestioles. Quand le terrarium est actif, toutes
les bébêtes ont une opportunité d'agir (comme d'effectuer un déplacement)
toutes les demi-secondes.

Du coup, on découpe l'espace et le temps en unités de taille fixe -- des
cases pour l'espace et des demi-secondes pour le temps. Ça rend généralement
les choses plus simple à modéliser dans un programme, mais ça a bien sûr
l'inconvénient d'être largement imprécis. Heureusement, ce simulateur de
terrarium n'a pas besoin d'être précis et nous pouvons donc faire avec.

---

Un terrarium peut être représenté comme un « plan », défini comme
étant un tableau de chaînes de caractères. Nous aurions pu n'utiliser
qu'une seule chaîne de caractères, mais comme les chaînes de caractères
JavaScript ne doivent comporter qu'une seule ligne, ça aurait été beaucoup
plus compliqué à taper.

> var lePlan =
>   ["############################",
>    "#      #    #      o      ##",
>    "#                          #",
>    "#          #####           #",
>    "##         #   #    ##     #",
>    "###           ##     #     #",
>    "#           ###      #     #",
>    "#   ####                   #",
>    "#   ##       o             #",
>    "# o  #         o       ### #",
>    "#    #                     #",
>    "############################"];

Les caractères |"#"| sont utilisés pour représenter les murs du terrarium
(et les éléments de décors, comme les rochers au sol), les |"o"|
représentent les bêtes et les espaces, comme vous vous en êtes sûrement
doutés, représentent les espaces vides.

Un plan-tableau de ce type est approprié pour représenter un objet
terrarium. Cet objet garde trace de la forme et du contenu du terrarium, et
permet aux insectes à l'intérieur de bouger. Il a quatre méthodes : tout
d'abord |toString|, qui converti le terrarium en une chaîne de caractères
affichable, permettant d'avoir un aperçu de ce qui se passe dedans. Ensuite,
il y a |step|, qui permet à toutes les bêtes du terrarium de se déplacer
d'une case si elles le veulent. Et enfin il y a |start| et |stop|, qui
contrôlent l'activité du terrarium. Lorsqu'il fonctionne, |step| est appelé
automatiquement toutes les demi-secondes, et donc les insectes se déplacent.

***

@_|Point|_Les points sur la grille représenteront également des objets. Dans
le \\csearch nous avons utilisé trois fonctions : |point|, |ajoutePoints|
et |pointsIdentiques| pour travailler avec les points. Cette fois, nous
utiliserons un constructeur et deux méthodes. Écrire le constructeur
|Point|, qui prend deux arguments, les coordonnées x et y du point, et
produit un objet avec des propriétés |x| et |y|. Ajoutez au prototype de
ce constructeur une méthode |ajoute|, qui prends un autre point en argument
et retourne un *nouveau* point dont les |x| et |y| sont la somme des |x|
et |y| des deux points donnés. Ajoutez également une méthode |estEgalA|,
qui prend un point et renvoit un booléen, indicant si le point local (|this|)
a les mêmes coordonnées que le point donné.

En dehors des deux méthodes, les propriétés |x| et |y| font également
partie de l'interface de ce type d'objets : le code utilisant des objets
de type point pourra lire et modifier librement les |x| et |y|.

///

> function Point(x, y) {
>   this.x = x;
>   this.y = y;
> }
> Point.prototype.ajoute = function(autre) {
>   return new Point(this.x + autre.x, this.y + autre.y);
> };
> Point.prototype.estEgalA = function(autre) {
>   return this.x == autre.x && this.y == autre.y;
> };
>
> show((new Point(3, 1)).ajoute(new Point(2, 4)));

Assurez-vous que votre version de |ajoute| laisse le point local (|this|)
intact et produise bien un nouvel objet Point. Une méthode qui change le
point courant serait similaire à l'opérateur |+=|, alors qu'on le veut
équivalent à l'opérateur |+|.

---

Quand on écrit des objets pour développer un programme, on ne sait
pas toujours quelle fonctionnalité va où. Certaines choses sont mieux
implémentées sous forme de méthodes de l'objet, d'autres mieux rangées
dans des fonctions et d'autres encore mieux modélisées par de nouveaux
types d'objets. Pour garder l'organisation limpide, il est important de
garder le nombre de méthodes et de responsabilités des objets aussi petit
que possible. Quand un objet en fait trop, il devient un gros bazar de
fonctionnalités et une formidable source de confusions.

J'ai dit plus haut que l'objet terrarium serait responsable du stockage de
son contenu et de permettre aux insectes de bouger. Tout d'abord, précisons
qu'il ne fait que *permettre* aux insectes de bouger. Les bébêtes seront
elles-mêmes des objets, et ces objets seront responsables de leur propres
décisions. Le terrarium ne fournit en gros que l'infrastructure qui leur
demande quoi faire chaque demi-seconde. Et s'il décident de bouger, il
s'assure que ça se fasse.

Stocker la grille sur laquelle le contenu du terrarium prend place peut vite
se compliquer. Il faut définir une représentation, des moyens d'accéder
à cette représentation, d'initialiser la grille depuis le « plan »
(fourni sous forme de tableau) et de restituer le contenu de la grille
sous la forme d'une chaîne de caractères pour la méthode |toString|,
sans oublier le mouvement des insectes sur la grille.

---

Lorsque vous vous retrouvez à mélanger représentations de données
et code spécifique à un problème donné dans un seul objet, c'est une
bonne idée d'essayer de mettre la représentation des données dans un type
d'objet séparé. Dans ce cas, nous avons besoin de représenter une grille
de valeurs, j'ai donc écrit un type |Grille|, qui supporte les opérations
dont ce terrarium aura besoin.

Pour stocker les valeurs de la grille, il y a deux options. L'une peut
utiliser un tableau de tableaux :

> var grille = [["0,0", "1,0", "2,0"],
>              ["0,1", "1,1", "2,1"]];
> show(grille[1][2]);

Ou alors les valeurs peuvent toutes être mises dans un seul tableau. Dans ce
cas, on retrouve l'élément |x|/|y| en cherchant dans le tableau l'élément
en position |x + y * largeur|, où |largeur| est la largeur de la grille.

> var grille = ["0,0", "1,0", "2,0",
>               "0,1", "1,1", "2,1"];
> show(grille[2 + 1 * 3]);

@_|Array|_J'ai choisi la seconde représentation, car elle simplifie
l'initialisation du tableau. |new Array(x)| produit un nouveau tableau de
longueur |x|, rempli de valeurs |undefined| (indéfinies).

> function Grille(largeur, hauteur) {
>   this.largeur = largeur;
>   this.hauteur = hauteur;
>   this.cellules = new Array(largeur * hauteur);
> }
> Grille.prototype.valeurEn = function(point) {
>   return this.cellules[point.y * this.largeur + point.x];
> };
> Grille.prototype.ecritValeurEn = function(point, valeur) {
>   this.cellules[point.y * this.largeur + point.x] = valeur;
> };
> Grille.prototype.estDedans = function(point) {
>   return point.x >= 0 && point.y >= 0 &&
>          point.x < this.largeur && point.y < this.hauteur;
> };
> Grille.prototype.deplaceElement = function(depuis, vers) {
>   this.ecritValeurEn(vers, this.valeurEn(depuis));
>   this.ecritValeurEn(depuis, undefined);
> };

***

Nous allons également avoir besoin de parcourir tous les éléments de
la grille, pour trouver les insectes qui ont besoin de bouger, ou pour
convertir l'ensemble en une chaîne de caractères. Pour simplifier la chose,
nous pouvons utiliser une fonction de haut niveau qui prend une action en
argument. Ajouter une méthode |each| au prototype de |Grille|, qui prend
en argument une fonction à deux arguments. Elle appelle cette fonction pour
chaque point de la grille, lui donnant l'objet point comment premier argument,
et la valeur du point sur la grille comme deuxième argument.

Parcourir les points depuis |0|, |0|, une ligne à la fois, de manière
à ce que le point |1|, |0| soit parcouru avant |0|, |1|. Cela simplifiera
l'écriture de la fonction |toString| du terrarium après. (Indice : mettre
une boucle |for| pour la coordonnée |x| à l'intérieur de la boucle for
de la coordonnée |y|.)

Il est conseillé de ne pas mettre son nez directement dans la propriété
|cellules| de la grille, mais d'utiliser |valeurEn|, pour récupérer ces
valeurs. De cette manière, si nous décidons (pour une raison ou pour une
autre) d'utiliser une méthode différente pour pour stocker les valeurs,
nous n'aurons qu'à ré-écrire la fonction |valeurEn| et |ecritValeurEn|,
et les autres méthodes resterons intactes.

///

> Grille.prototype.each = function(action) {
>   for (var y = 0; y < this.hauteur; y++) {
>     for (var x = 0; x < this.largeur; x++) {
>       var point = new Point(x, y);
>       action(point, this.valeurEn(point));
>     }
>   }
> };

---

Enfin, pour tester l'objet grille :

> var testGrille = new Grille(3, 2);
> testGrille.ecritValeurEn(new Point(1, 0), "#");
> testGrille.ecritValeurEn(new Point(1, 1), "o");
> testGrille.each(function(point, valeur) {
>   print(point.x, ",", point.y, ": ", valeur);
> });

---

Avant d'écrire un nouveau constructeur |Terrarium|, nous devons être
plus précis à propos de ces « objets insectes » qui évolueront à
l'intérieur. Précédemment, j'ai dit que le terrarium demandera aux
insectes quelle action ils veulent effectuer. Cela fonctionnera de la fonction
suivante : chaque insecte aura une méthode |agit| qui, appellée, renverra
une « action ». Une action est un objet doté d'une propriété |type|,
nommant le type d'action que l'insecte souhaitera effectuer. Par exemple
|"déplacement"|. La plupart des actions porteront d'autres informations,
par exemple la direction souhaitée par l'insecte qui voudra se déplacer.

Les insectes sont terriblement myopes, ils ne peuvent voir que les cases à
côté d'eux sur la grille. Mais ils peuvent s'en servir pour déterminer
leurs actions. Quand la méthode |agit| est appelée, il lui est fourni un
objet avec des informations sur l'environnement de l'insecte en question. Il
porte une propriété pour chacune des huit directions autour de l'insecte. La
propriété indiquant ce qu'il y a au-dessus de l'insecte est appellé |"n"|,
pour Nord, pour ce qu'il y a au-dessus à gauche |"ne"| pour Nord-Est,
et ainsi de suite.
Pour savoir quelle direction explorer selon le nom de la direction, l'objet
dictionnaire suivant sera utile :

> var directions = new Dictionary(
>   {"n":  new Point( 0, -1),
>    "ne": new Point( 1, -1),
>    "e":  new Point( 1,  0),
>    "se": new Point( 1,  1),
>    "s":  new Point( 0,  1),
>    "sw": new Point(-1,  1),
>    "w":  new Point(-1,  0),
>    "nw": new Point(-1, -1)});
>
> show(new Point(4, 4).ajoute(directions.lookup("se")));

Quand un insecte décide de se déplacer, il indique dans quelle direction il
veut aller en renvoyant un objet action dont la propriété |direction| nomme
laquelle de ces directions. Nous pouvons programmer un insecte primitif et
idiot qui va toujours vers le sud, « vers la lumière », comme ceci :

> function InsecteStupide() {};
> InsecteStupide.prototype.agit = function(alentours) {
>   return {type: "déplacement", direction: "s"};
> };

---

Nous pouvons maintenir construire le type d'objet |Terrarium|
lui-même. Commençons par son constructeur, qui reçoit un plan (un tableau
de chaîne) comme argument, et initialise son objet grille.

> var mur = {};
>
> function Terrarium(plan) {
>   var grille = new Grille(plan[0].length, plan.length);
>   for (var y = 0; y < plan.length; y++) {
>     var ligne = plan[y];
>     for (var x = 0; x < ligne.length; x++) {
>       grille.ecritValeurEn(new Point(x, y),
>                       elementdApresCaractere(ligne.charAt(x)));
>     }
>   }
>   this. grille= grille;
> }
>
> function elementdApresCaractere(caractere) {
>   if (caractere == " ")
>     return undefined;
>   else if (caractere == "#")
>     return mur;
>   else if (caractere == "o")
>     return new InsecteStupide();
> }

|mur| est un objet utilisé pour repérer la position des murs sur la
grille. Comme un vrai mur, il ne fait pas grand-chose, juste être quelque
part et occuper une partie de l'espace.

---

La  méthode la plus évidente de l'objet terrarium est |toString|,
qui  transforme un terrarium en chaîne de caractères. Pour faciliter
cette  tâche, nous donnons à |mur| et au prototype de |InsecteStupide|
une propriété |caractere|, contenant la réprésentation sous forme de
caractère de ceux-ci.

> mur.caractere = "#";
> InsecteStupide.prototype.caractere = "o";
>
> function caracteredApresElement(element) {
>   if (element == undefined)
>     return " ";
>   else
>     return element.caractere;
> }
>
> show(caracteredApresElement(mur));

***

Maintenant, nous pouvons utiliser la méthode |each| de l'objet |Grille|
pour construire une chaîne de caractères. Pour que le résultat soit
lisible, il est préférable d'avoir un retour chariot à chaque ligne. La
coordonnée |x| de chaque case de la grille sera utilisé pour déterminer
si la fin d'une ligne est atteinte.
En ajoutant une méthode |toString| qui ne prend pas d'argument et renvoie
une chaîne de caractères, et en passant cette chaîne à |print|, nous
obtenons une vue bi-dimensionnelle convenable du terrarium.

///

> Terrarium.prototype.toString = function() {
>   var caracteres = [];
>   var finDeLigne = this.grille.largeur - 1;
>   this.grille.each(function(point, valeur) {
>     caracteres.push(caracteredApresElement(valeur));
>     if (point.x == finDeLigne)
>       caracteres.push("\n");
>   });
>   return caracteres.join("");
> };

Et pour l'essayer ...

> var terrarium = new Terrarium(lePlan);
> print(terrarium.toString());

---

Il est possible qu'en essayant de résoudre l'exercice précédent, vous
ayez voulu accéder à |this.grille| dans le corps de la fonction passé en
argument de la méthode |each| de l'objet grille. Cela ne peut pas fonctionner,
car l'appel à une fonction a pour conséquence qu'à l'intérieur de cette
fonction, |this| prend une nouvelle valeur, même si elle n'est pas utilisée
en tant que méthode. Ainsi, aucune variable |this| à l'extérieur d'une
fonction ne peut être visible.

Parfois, il est nécessaire de contourner ceci en stockant les informations
dont on a besoin dans une variable, par exemple |finDeLigne|, qui elle *est*
visible dans la fonction imbriquée. Si vous avez besoin d'accéder à la
variable |this| d'un objet, vous pouvez la stocker dans une autre variable. Le
nom |self| (ou |that|) est souvent utilisée pour une telle variable.

Mais l'utilisation de ces variables en plus peut être source de confusion. Une
autre bonne solution est d'utiliser une fonction proche de |partial| décrite
dans le \\cfp. Au lieu d'ajouter un argument à la fonction, celle-ci passe
l'objet |this|, par l'intermédiaire du premier argument de la méthode
|apply| dont disposent toutes les fonctions :

> function bind(func, object) {
>   return function(){
>     return func.apply(object, arguments);
>   };
> }
>
> var tableauTest = [];
> var ajouteDansTest = bind(tableauTest.push, tableauTest);
> ajouteDansTest("A");
> ajouteDansTest("B");
> show(tableauTest);

De cette façon, vous pouvez lier la variable |this| d'une fonction
imbriquée à la variable |this| de la fonction appelante, les deux |this|
seront identiques.

***

Dans l'expression |bind(tableauTest.push, tableauTest)| le nom |tableauTest|
est encore utilisé deux fois. Pouvez-vous concevoir une fonction _|method|_,
qui permet de lier un objet à une de ses méthodes *sans* nommer deux fois
l'objet ?

///

Il est possible de passer à un objet une chaîne de caractères contenant
le nom d'une de ses méthodes. De cette façon, la fonction |method| peut
connaître le nom de la fonction à appliquer à l'objet.

> function method(object, name) {
>   return function() {
>     object[name].apply(object, arguments);
>   };
> }
>
> var ajouteDansTest = method(tableauTest, "push");

---

Nous aurons besoin de |bind| (ou |method|) quand nous écrirons la méthode
|step| de l'objet terrarium. Cette méthode devra parcourir tous les insectes
de la grille, en leur demandant quelle action ils veulent effectuer, et en
effectuant pour eux cette action.
Vous pourriez être tenté d'utiliser |each| sur l'objet grille, et traiter
les insectes un par un au fur et à mesure que vous les rencontriez. Mais
ce faisant, si un insecte se déplaçait vers le sud ou l'est, vous le
rencontriez à nouveau dans le même tour, et il serait à nouveau déplacé.

A la place, nous allons extraire tous les insectes vers un tableau, et
partant de là, les traiter un par un.
La méthode ci-dessous extrait les insectes, et même tout objet qui possède
une méthode |agit|, et enregistre ces objets, et leurs positions respectives
avant déplacement, dans un tableau d'objets.

> Terrarium.prototype.listeCreaturesEnAction = function() {
>   var trouves = [];
>   this.grille.each(function(point, valeur) {
>     if (valeur != undefined && valeur.agit)
>       trouves.push({object: valeur, point: point});
>   });
>   return trouves;
> };

***

Lorsque l'on demande à un insecte quel déplacement veut-il faire, il faut
lui passer un objet lui décrivant les cases alentours. Cet objet utilisera
les noms de direction que nous avons vu précédemment (|"n"|, |"ne"|,
et cætera) comme noms de propriétés. Chaque propriété contiendra une
chaîne d'un caractère tel que renvoyé par |caracteredApresElement|,
indiquant ce que peut voir l'insecte dans cette direction.

Ajouter une méthode |listeAlentours| au prototype de |Terrarium|. Elle
prend un argument, le point où l'insecte se trouve, et renvoie un objet
décrivant l'entourage de ce point. Quand un point se trouve à une bordure
de la grille, utiliser |"#"| pour les directions qui débordent de la grille,
ainsi l'insecte ne pourra s'y rendre.

Conseil : ne pas décrire chacune des directions, mais utiliser la méthode
|each| sur le dictionnaire |directions|.

///

> Terrarium.prototype.listeAlentours = function(centre) {
>   var resultat = {};
>   var grille = this.grille;
>   directions.each(function(nom, direction) {
>     var place = centre.ajoute(direction);
>     if (grille.estDedans(place))
>       resultat[nom] = caracteredApresElement(grille.valeurEn(place));
>     else
>       resultat[nom] = "#";
>   });
>   return resultat;
> };

Remarquez l'utilisation de la variable |grille| pour passer outre les
difficultés liées à l'usage de |this|.

---

Les deux méthodes ci-dessus ne font pas partie de l'interface externe de
l'objet |Terrarium|, mais sont des détails internes à l'objet. Certains
langages de programmation permettent de déclarer explicitement certaines
méthodes et propriétés comme 'privées', et provoquent une erreur si on
accède à celles-ci en dehors de l'objet.
Ce n'est pas le cas de JavaScript, c'est pourquoi vous pourriez utiliser
des commentaires pour décrire l'interface d'un objet.
Parfois il est utile d'utiliser des conventions de nommage pour distinguer les
propriétés externes et internes, par exemple en préfixant les propriétés
internes avec un caractère souligné ('_').
Cela permet de répérer plus facilement les utilisations accidentelles des
propriétés qui ne font pas partie de l'interface des objets.

---

Voici encore une méthode interne, celle qui va demander à un insecte ce
qu'il veut faire, et l'effectuer. Elle prend en argument un objet avec les
propriétés |object| et |point|, comme le renvoie |listeCreaturesEnAction|.
Pour le moment, elle ne reconnait que l'action |"déplacement"| :

> Terrarium.prototype.actionnerUneCreature = function(creature) {
>   var alentours = this.listeAlentours(creature.point);
>   var action = creature.object.agit(alentours);
>   if (action.type == "déplacement" && directions.contains(action.direction)) {
>     var to = creature.point.ajoute(directions.lookup(action.direction));
>     if (this.grille.estDedans(to) && this.grille.valeurEn(to) == undefined)
>       this.grille.deplaceElement(creature.point, to);
>   }
>   else {
>     throw new Error("Action invalide : " + action.type);
>   }
> };

Remarquez que la méthode vérifie si la direction choisie amène bien à
une case vide, dans le cas contraire, la méthode ignore le déplacement. De
cette façon, les insectes peuvent bien demander tout ce qu'ils veulent --
l'action ne sera effectuée que si elle est possible.
Ce mécanisme agit comme une couche d'isolation entre les insectes et le
terrarium, et nous autorise quelques approximations dans l'écriture des
méthodes |agit| des insectes -- par exemple |InsecteStupide| ne se déplace
que vers le sud, sans se demander si un mur se trouve sur son chemin.

---

Ces trois méthodes internes vont nous permettre enfin d'écrire la méthode
|step|, qui permettra aux insectes de faire quelque chose (et même tout
élément doté d'une méthode |agit| -- nous pourrions tout aussi bien
donner une telle méthode à l'objet |mur| et les murs se déplaceraient).

> Terrarium.prototype.step = function() {
>   forEach(this.listeCreaturesEnAction(),
>           bind(this.actionnerUneCreature, this));
> };

Maintenant, construisons un terrarium et voyons les insectes se déplacer.

> var terrarium = new Terrarium(lePlan);
> print(terrarium);
> terrarium.step();
> print(terrarium);

---

Examinons un instant l'instruction ci-dessus |print(terrarium)|, comment
fait-elle pour renvoyer le contenu de notre méthode _|toString|_ ? |print|
transfome les arguments qui lui sont passés en chaîne de caractère,
en utilisant la fonction |String|. Les objets sont transformés en chaîne
de caractères par l'appel de leur méthode |toString|, aussi, écrire une
méthode |toString| dans nos propres objets est un bon moyen de les rendre
lisible lors de l'appel de |print|.

> Point.prototype.toString = function() {
>   return "(" + this.x + "," + this.y + ")";
> };
> print(new Point(5, 5));

---

Comme prévu, l'objet |Terrarium| sera doté de méthode |start| et |stop| pour
démarrer et arrêter la simulation. Pour cela, nous utiliserons deux fonctions
fournies par le navigateur web, appelées _|setInterval|_ et _|clearInterval|_.
La première est utilisé dans le but que son premier argument (une fonction
ou une chaîne de caractères contenant du code JavaScript) soit exécuté
périodiquement. Son deuxième argument est la durée en millisecondes
(1/1000 de seconde) entre les exécutions.
La fonction renvoie une valeur qui pourra servir d'argument à |clearInterval|
pour arrêter les exécutions périodiques.

> var pénible = setInterval(function() {print("Quoi?");}, 400);

Et…

> clearInterval(pénible);

Il existe des fonctions proches pour exécuter une action une seule fois
après un laps de temps. _|setTimeout|_ exécute une fonction ou une chaine
de caractères après un délai exprimé en millisecondes, et _|clearTimeout|_
permet d'annuler une telle action.

---

> Terrarium.prototype.start = function() {
>   if (!this.running)
>     this.running = setInterval(bind(this.step, this), 500);
> };
>
> Terrarium.prototype.stop = function() {
>   if (this.running) {
>     clearInterval(this.running);
>     this.running = null;
>   }
> };

---

A ce stade, nous avons un terrarium avec des insectes très simplistes,
que nous pouvons faire fonctionner. Mais pour voir ce qu'il s'y passe,
il nous faut constamment exécuter |print(terrarium)|. Ce n'est pas très
pratique. Ce serait agréable que le contenu s'affiche automatiquement. Ce
serait encore mieux si, au lieu d'afficher par milliers les images successives
des terraria, nous n'ayons qu'une seule image que nous mettrions à jour.
Pour ce dernier problème, cette page offre une fonction nommé
|inPlacePrinter|. Elle renvoie une fonction comme |print| qui, au lieu
d'effectuer un nouvel affichage, remplace l'affichage précédent.

> var printHere = inPlacePrinter();
> printHere("Actuellement vous voyez ceci.");
> setTimeout(partial(printHere, "Plus maintenant."), 1000);

Pour que le terrarium s'affiche à chaque changement, nous modifions la
méthode |step| comme suit:

> Terrarium.prototype.step = function() {
>   forEach(this.listeCreaturesEnAction(),
>           bind(this.actionnerUneCreature, this));
>   if (this.onStep)
>     this.onStep();
> };

En faisant cela, si une propriété |onStep| est présente dans
l'objet terrarium, elle est appelée à chaque étape.

> var terrarium = new Terrarium(lePlan);
> terrarium.onStep = partial(inPlacePrinter(), terrarium);
> terrarium.start();

Remarquez l'utilisation de |partial| -- cette méthode  |partial| renvoie une
fonction d'affichage appliquée à l'objet terrarium. La fonction d'affichage
ne demandant qu'un seul argument, après application partielle, nous obtenons
une fonction sans argument. C'est exactement ce dont nous avons besoin pour
la propriété |onStep|.

N'oubliez pas d'arrêter la simulation du terrarium, quand il perd de son
intérêt (ce qui ne devrait pas tarder), pour éviter de consommer les
ressources de votre ordinateur inutilement :

> terrarium.stop();

---

Qui voudrait d'une simulation de terrarium avec une seule sorte d'insecte,
stupide qui plus est ? Pas moi. Ce serait judicieux si nous pouvions ajouter
différentes sortes d'insectes. Heureusement, il nous suffit pour cela de
rendre la fonction |elementdApresCaractere| plus générale. Pour le moment,
elle décrit trois possibilités « codés en dur », c'est à dire de
façon linéaire et sans flexibilité :

> function elementdApresCaractere(caractere) {
>   if (caractere == " ")
>     return undefined;
>   else if (caractere == "#")
>     return mur;
>   else if (caractere == "o")
>     return new InsecteStupide();
> }

Les deux premiers cas reste tels quels, le dernier étant trop spécifique. Une
meilleure approche serait de stocker les constructeurs des objets insectes et
les caractères qui leur correspondent dans un dictionnaire, et de rechercher
dans ce dictionnaire ces caractères :

> var typesDeCreature = new Dictionary();
> typesDeCreature.enregistre = function(constructor) {
>   this.store(constructor.prototype.caractere, constructor);
> };
>
> function elementdApresCaractere(caractere) {
>   if (caractere == " ")
>     return undefined;
>   else if (caractere == "#")
>     return mur;
>   else if (typesDeCreature.contains(caractere))
>     return new (typesDeCreature.lookup(caractere))();
>   else
>     throw new Error("Caractère inconnu: " + caractere);
> }

Remarquez qu'une méthode |enregistre| est ajoutée à l'objet
|typesDeCreature| -- celui-ci est de de type dictionnaire, ce qui n'empêche en
rien de lui ajouter une méthode. Cette fonction extrait le caractère associé
au constructeur de l'insecte, et stocke ce caractère dans le dictionnaire.
Cette méthode ne doit être appelée que sur des objets dont le prototype
possède une propriété |caractere|.

La fonction |elementdApresCaractere| est modifiée pour rechercher le
caractère présent dans |typesDeCreature|, et provoque une exception si
elle tombe sur un caractère inconnu.

---

Voici une nouvelle sorte d'insecte, ainsi que les instructions pour enregistrer
son caractère dans |typesDeCreature|:

> function InsecteaRebond() {
>   this.direction = "ne";
> }
> InsecteaRebond.prototype.agit = function(alentours) {
>   if (alentours[this.direction] != " ")
>     this.direction = (this.direction == "ne" ? "sw" : "ne");
>   return {type: "déplacement", direction: this.direction};
> };
> InsecteaRebond.prototype.caractere = "%";
>
> typesDeCreature.enregistre(InsecteaRebond);

Pouvez-vous comprendre ce qu'il fait ?

*** insecteivre

Créer un insecte nommé |InsecteIvre| qui essaie de se déplacer dans une
direction quelconque à chaque tour, peu importe s'il y a un mur en face
de lui.
Rappelez-vous le fonctionnement de |Math.random| dans le \\csearch.

///

Pour déterminer une direction de façon aléatoire, nous avons besoin
d'un tableau avec la liste des directions. Nous pourrions juste écrire un
tableau de cette façon : |["n", "ne", ...]|, mais cela dupliquerait des
informations, et les duplications d'information me rendent nerveux. Nous
pourrions également utiliser la méthode |each| sur le dictionnaire
|directions| pour construire un nouveau tableau, ce serait déjà mieux.

Mais vous devez comprendre qu'il y a, ici, une façon bien plus générale
de procéder.
Récupérer la liste des noms de propriété d'un dictionnaire est un outil
utile, aussi, ajoutons le ou prototype de l'objet |Dictionary|.

> Dictionary.prototype.names = function() {
>   var names = [];
>   this.each(function(name, value) {names.push(name);});
>   return names;
> };
>
> show(directions.names());

Un programmeur vraiment névrosé voudrait immédiatement rétablir la
symétrie en ajoutant une méthode |values| qui retournerait la liste des
valeurs d'un dictionnaire. Mais je suppose que nous pouvons attendre d'en
avoir [vraiment besoin|
http://www.c2.com/cgi/wiki?YouArentGonnaNeedIt].

Voici une façon de prendre un élément d'un tableau au hasard :

> function elementAuHasard(array) {
>   if (array.length == 0)
>     throw new Error("Le tableau est vide.");
>   return array[Math.floor(Math.random() * array.length)];
> }
>
> show(elementAuHasard(["premier", "dernier"]));

Et l'insecte lui-même :

> function InsecteIvre() {};
> InsecteIvre.prototype.agit = function(alentours) {
>   return {type: "déplacement",
>           direction: elementAuHasard(directions.names())};
> };
> InsecteIvre.prototype.caractere = "~";
>
> typesDeCreature.enregistre(InsecteIvre);

---

Essayons maintenant ces nouveaux insectes :

> var nouveauPlan =
>   ["############################",
>    "#                      #####",
>    "#    ##                 ####",
>    "#   ####     ~ ~          ##",
>    "#    ##       ~            #",
>    "#                          #",
>    "#                ###       #",
>    "#               #####      #",
>    "#                ###       #",
>    "# %        ###        %    #",
>    "#        #######           #",
>    "############################"];
>
> var terrarium = new Terrarium(nouveauPlan);
> terrarium.onStep = partial(inPlacePrinter(), terrarium);
> terrarium.start();

Vous voyez comment les insectes à rebond rebondissent sur les insectes en
état d'ébriété ? Dramatique. De toute façon, quand vous en aurez assez
de regarder ce spectacle fascinant, vous
pourrez y mettre fin :

> terrarium.stop();

---

Nous avons maintenant deux sortes d'objets possédant chacun une
méthode |agit| et une propriété |caractere|. Comme ils partagent ces
caractéristiques, le terrarium peut dialoguer avec eux d'une façon
commune. Ceci nous autorise à avoir toutes sortes d'insectes, sans
rien changer au code de l'objet terrarium. Cette technique est appelée
_polymorphisme_, et c'est sûrement l'un des aspects les plus puissants de
la programmation orientée objet.

L'idée de base du polymorphisme est que lorsque qu'un morceau de programme
est écrit pour manipuler des objets ayant une certaine interface, n'importe
quel objet qui présente cette interface pourra être raccordé à ce morceau
de programme, et le tout fonctionne.
Nous avons déjà vu un exemple de cela, à savoir la méthode |toString|
de nombreux objets.
Tous les objets ayant une méthode |toString| pertinente peuvent être
passés à la fonction |print|, ou tout autre fonction qui aura besoin de
convertir un objet en chaîne de caractères, peu importe la façon dont
cette dernière est produite.

De la même façon, |forEach| travaille sur de véritable objets tableau ou
sur des objets similaires aux tableaux, |forEach| recevant cet objet tableau
dans sa variable |arguments|, car tout ce dont cette fonction a besoin,
ce sont des propriétés numérotées [0|, |1|, et ainsi de suite pour tous
les éléments du tableau.

---

Pour rendre la vie dans le terrarium plus réelle, nous allons y ajouter
les concepts de nourriture et de reproduction. Chaque créature vivante du
terrarium reçoit une nouvelle propriété, |énergie|, qui est diminuée
lorsqu'elle effectue une action, et augmentée lorsqu'elle mange quelque
chose. Lorsqu'elle a suffisament d'énergie, un chose vivante peut se
reproduire##, engendrant une nouvelle créature du même type.

## Pour rendre les choses plus simples, les créatures de notre terrarium
se reproduiront de façon assexuée, d'elles-mêmes.

S'il n'y avait que des insectes, les dépenses d'énergie de leurs
déplacements, et le fait qu'ils se mangeraient entre eux, feraient que
notre terrarium succomberait rapidement sous l'effet de l'entropie, serait
à court d'énergie, et deviendrait un lieu abandonné et sans vie.
Pour empêcher que ceci se produise (au moins, que cela ne se produise pas trop
vite), nous ajoutons du lichen au terrarium. Les lichens ne se déplacent pas,
ils utilisent la photosynthèse pour produire de l'énergie et se reproduire.

Pour que cela fonctionne, nous aurons besoin d'un terrarium avec une méthode
|actionnerUneCreature| différente. Nous pourrions simplement changer cette
méthode dans le prototype de |Terrarium|, mais nous sommes très attachés
à la simulation des insectes sauteurs et des insectes en état d'ébriété,
et ne voulons pas casser ce premier terrarium.

Ce que nous pouvons faire est écrire un nouveau constructeur,
|TerrariumPlusVivant|, dont le prototype est basé sur le prototype de
|Terrarium|, mais qui possède une méthode |actionnerUneCreature| différente.

---

Il existe plusieurs façon de faire cela. Nous pourrions énumérer les
propriétés de |Terrarium.prototype|, et les ajouter une à une dans
|TerrariumPlusVivant.prototype|. Ce serait simple à faire, et dans certains
cas la meilleure solution. Mais ici nous avons une façon plus propre de
faire. Si nous faisons du prototype du premier objet terrarium le prototype
du nouveau terrarium (prenez le temps de bien comprendre cette phrase),
ce nouveau Terrarium en aurait toutes les propriétés.

@_|clone|_Malheureusement, JavaScript ne propose pas de moyen direct de
créer un objet dont le prototype est celui d'un autre objet. Il est possible
d'écrire une fonction qui fait cela, en utilisant l'astuce suivante :

> function clone(object) {
>   function ConstructeurNouveauPourChaqueClone(){}
>   ConstructeurNouveauPourChaqueClone.prototype = object;
>   return new ConstructeurNouveauPourChaqueClone();
> }

Cette fonction clone déclare un constructeur nommé
ConstructeurNouveauPourChaqueClone qui est vide et unique, dont le prototype
est l'objet passé en argument.
En appelant |new| sur ce constructeur, un nouvel objet est crée, basé sur
l'objet passé en argument.

> function TerrariumPlusVivant(plan) {
>   Terrarium.call(this, plan);
> }
> TerrariumPlusVivant.prototype = clone(Terrarium.prototype);
> TerrariumPlusVivant.prototype.constructor = TerrariumPlusVivant;

Le nouveau constructeur n'a pas besoin de faire quoi que ce soit de plus que
l'ancien, donc il se contente d'appeler l'ancien sur l'objet |this|. Il nous
faut également restaurer la propriété |constructor| du nouveau prototype,
sinon il clamerait que son constructeur est |Terrarium| (ce qui, bien sûr,
n'est un problème que si on se sert de cette propriété, ce qui n'est pas
notre cas).

---

Il est maintenant possible de remplacer certaines méthodes de l'objet
|TerrariumPlusVivant|, et d'en ajouter d'autres. Nous avons un type d'objet
basé sur un autre, ce qui nous épargne le travail de récrire toutes les
méthodes communes à |Terrarium| et |TerrariumPlusVivant|.
Cette  technique est appelée '_héritage_'. Le nouveau type hérite des
propriétés de l'ancien type. Dans la plupart des cas, cela signifie que le
nouveau type possèdera toujours l'interface de l'ancien, bien qu'il puisse
posséder des méthodes en plus, que l'ancien n'a pas.
De cette façon, les objets du nouveau type pourraient prendre la place
(selon le polymorphisme) des objets de l'ancien type.

Dans les langages de programmation avec un support explicite de l'orientation
objet, l'héritage est une chose très simple à mettre en oeuvre. JavaScript
n'a pas de moyen simple de le faire.
A cause de cela, les programmeurs en JavaScript ont inventé différentes
approches pour le faire. Malheureusement, aucune d'entre elles n'est parfaite.

A la fin de ce chapitre, je vous montrerai d'autres façons de mettre en
œuvre l'héritage, et leurs inconvénients.

---

Voici une nouvelle méthode |actionnerUneCreature|. Elle est volumineuse :

> TerrariumPlusVivant.prototype.actionnerUneCreature = function(creature) {
>   var alentours = this.listeAlentours(creature.point);
>   var action = creature.object.agit(alentours);
>
>   var cible = undefined;
>   var elementDansCible = undefined;
>   if (action.direction && directions.contains(action.direction)) {
>     var direction = directions.lookup(action.direction);
>     var directionSouhaitee = creature.point.ajoute(direction);
>     if (this.grille.estDedans(directionSouhaitee )) {
>       cible = directionSouhaitee ;
>       elementDansCible = this.grille.valeurEn(cible);
>     }
>   }
>
>   if (action.type == "déplacement") {
>     if (cible && !elementDansCible) {
>       this.grille.deplaceElement(creature.point, cible);
>       creature.point = cible;
>       creature.object.energie -= 1;
>     }
>   }
>   else if (action.type == "manger") {
>     if (elementDansCible && elementDansCible.energie) {
>       this.grille.ecritValeurEn(cible, undefined);
>       creature.object.energie += elementDansCible.energie;
>     }
>   }
>   else if (action.type == "photosynthese") {
>     creature.object.energie += 1;
>   }
>   else if (action.type == "reproduction") {
>     if (cible && !elementDansCible) {
>       var espèce = caracteredApresElement(creature.object);
>       var bébé = elementdApresCaractere(espèce);
>       creature.object.energie -= bébé.energie * 2;
>       if (creature.object.energie > 0)
>         this.grille.ecritValeurEn(cible, bébé);
>     }
>   }
>   else if (action.type == "attente") {
>     creature.object.energie -= 0.2;
>   }
>   else {
>     throw new Error("Action invalide : " + action.type);
>   }
>
>   if (creature.object.energie <= 0)
>     this.grille.ecritValeurEn(creature.point, undefined);
> };

La fonction commence toujours par interroger les créatures pour une action.
Ensuite, si l'action possède une propriété |direction|, la fonction
détermine immédiatement à quel endroit de la grille cette direction
amène, et ce qu'il y a à cet endroit. Trois des cinq actions implantées
dans notre simulation ont besoin de savoir cela, et le code serait encore
plus difficile à comprendre si ces calculs étaient faits à part.
Si l'action n'a pas de propriété |direction|, ou si celle-ci est incorrecte,
les variables |cible| et |elementDansCible| restent à leur valeur undefined.

Après cela, toutes les actions sont passées en revue. Certaines actions
demandent des vérifications supplémentaires avant leur exécution, ce qui
est fait en utilisant un |if| distinct pour que si une créature cherche,
par exemple, à passer à travers un mur, une exception |"Action invalide"|
ne soit pas générée.

Remarquez que dans l'action |"reproduction"|, la créature parente perd deux
fois la quantité d'énergie reçue par la nouvelle créature (la procréation
n'est pas une chose facile), et la nouvelle créature n'est placée sur la
grille que si son parent a suffisant d'énergie pour l'engendrer.

Après qu'une action a été effectuée, nous regardons si la créature a
encore de l'énergie. Si elle n'en a plus, elle meurt, et nous la supprimons.

---

Le lichen n'est pas un organisme très complexe. Nous allons utiliser le
caractère |"*"| pour le représenter. Vérifiez que vous avez bien défini
la fonction |elementAuHasard| pour l'\\einsecteivre, car elle sera utilisée
de nouveau ici.

> function Lichen() {
>   this.energie = 5;
> }
> Lichen.prototype.agit = function(alentours) {
>   var espaceVide = chercheDirections(alentours, " ");
>   if (this.energie >= 13 && espaceVide.length > 0)
>     return {type: "reproduction", direction: elementAuHasard(espaceVide)};
>   else if (this.energie < 20)
>     return {type: "photosynthese"};
>   else
>     return {type: "attente"};
> };
> Lichen.prototype.caractere = "*";
>
> typesDeCreature.enregistre(Lichen);
>
> function chercheDirections(alentours, directionSouhaite) {
>   var trouve = [];
>   directions.each(function(name) {
>     if (alentours[name] == directionSouhaite)
>       trouve.push(name);
>   });
>   return trouve;
> }

Les lichens ne grandissent jamais au delà de 20 unités d'énergie, sinon
ils seraient trop imposants, quand, encerclés par d'autre lichens, ils
n'ont plus de place pour se reproduire.

***

Créez une créature dévoreuse de lichens, |MangeuseLichen|. Elle commence
avec |10| unités d'énergie, et agit de la façon suivante :

 * Quand elle a 30 ou plus d'énergie et une case vide près d'elle, elle se reproduit.
 * Sinon, s'il y a du lichen près d'elle, elle en mange un, choisi aléatoirement.
 * Sinon, s'il y a la place de se bouger, elle va vers une cases vides aléatoire.
 * Sinon elle attend.

Utiliser les fonctions |chercheDirections| et |elementAuHasard| pour
déterminer le contenu de l'entourage de la créature, et faire des choix
aléatoires. Donner à cette créature le caractère |"c"| (pour faire penser
à pac-man).

///

> function MangeuseLichen() {
>   this.energie = 10;
> }
> MangeuseLichen.prototype.agit = function(alentours) {
>   var espaceVide = chercheDirections(alentours, " ");
>   var lichen = chercheDirections(alentours, "*");
>
>   if (this.energie >= 30 && espaceVide.length > 0)
>     return {type: "reproduction", direction: elementAuHasard(espaceVide)};
>   else if (lichen.length > 0)
>     return {type: "manger", direction: elementAuHasard(lichen)};
>   else if (espaceVide.length > 0)
>     return {type: "déplacement", direction: elementAuHasard(espaceVide)};
>   else
>     return {type: "attente"};
> };
> MangeuseLichen.prototype.caractere = "c";
>
> typesDeCreature.enregistre(MangeuseLichen);

---

Et pour l'essayer.

> var lichenPlan =
>   ["############################",
>    "#                     ######",
>    "#    ***                **##",
>    "#   *##**         **  c  *##",
>    "#    ***     c    ##**    *#",
>    "#       c         ##***   *#",
>    "#                 ##**    *#",
>    "#   c       #*            *#",
>    "#*          #**       c   *#",
>    "#***        ##**    c    **#",
>    "#*****     ###***       *###",
>    "############################"];
>
> var terrarium = new TerrariumPlusVivant(lichenPlan);
> terrarium.onStep = partial(inPlacePrinter(), terrarium);
> terrarium.start();

La plupart du temps, vous devriez voir le lichen envahir rapidement le
terrarium, cette abondance de nourriture provoquera une abondance de créatures
voraces, si nombreuses qu'elle finiront par épuiser les ressources en lichen,
et enfin s'épuiser elles-mêmes. La nature est si tragique.

> terrarium.stop();

---

Constater que les occupants de votre terrarium disparaissent après quelques
minutes est un peu déprimant. Pour y faire face, nous allons éduquer nos
créatures dévoreuses de lichen au principe de l'agriculture raisonnée. En
faisant qu'elles ne mangent du lichen que si elles sont à proximité de
deux d'entre eux, quel que soit l'état de leur faim, elles ne pourront plus
exterminer le lichen. Cela demande de la discipline, mais le résultat est
un biotope qui ne s'autodétruit pas.
Voici une nouvelle méthode |agit| -- le seul changement est que l'action
de manger ne se fait que si |lichen.length| est au moins égal à 2.

> MangeuseLichen.prototype.agit = function(alentours) {
>   var espaceVide = chercheDirections(alentours, " ");
>   var lichen = chercheDirections(alentours, "*");
>
>   if (this.energie >= 30 && espaceVide.length > 0)
>     return {type: "reproduction", direction: elementAuHasard(espaceVide)};
>   else if (lichen.length > 1)
>     return {type: "manger", direction: elementAuHasard(lichen)};
>   else if (espaceVide.length > 0)
>     return {type: "déplacement", direction: elementAuHasard(espaceVide)};
>   else
>     return {type: "attente"};
> };

Faites fonctionner la simulation du terrarium |lichenPlan| à nouveau
et constatez son évolution. A moins d'être très chanceux, vous allez
probablement constater l'extinction des créatures dévoreuses au bout
d'un certain temps, parce que lorsque survient la famine, ces créatures
se déplacent de façon désordonnée, au lieu de rechercher le lichen qui
n'est pas très loin d'elles.

***

Chercher un moyen de rendre la créature |MangeuseLichen| plus apte à la
survie. Ne trichez pas -- une  instruction |this.energie += 100| serait
de la triche. Si vous ré-écrivez  le constructeur, n'oubliez pas de
l'enregistrer à nouveau dans le  dictionnaire |typesDeCreature|, sinon le
terrarium continuerait d'utiliser  l'ancien constructeur.

///

Une approche serait de restreindre le caractère aléatoire des
déplacements. En choisissant systématiquement une direction aléatoire,
elles reviennent très souvent sur leurs pas, sans rien trouver à manger. En
se rappelant de la direction d'où elles viennent, et en privilégiant
cette direction, elles dépenseraient moins de temps et trouveraient plus
facilement de la nourriture.

> function MangeuseLichenHabile() {
>   this.energie = 10;
>   this.direction = "ne";
> }
> MangeuseLichenHabile.prototype.agit = function(alentours) {
>   var espaceVide = chercheDirections(alentours, " ");
>   var lichen = chercheDirections(alentours, "*");
>
>   if (this.energie >= 30 && espaceVide.length > 0) {
>     return {type: "reproduction",
>             direction: elementAuHasard(espaceVide)};
>   }
>   else if (lichen.length > 1) {
>     return {type: "manger",
>             direction: elementAuHasard(lichen)};
>   }
>   else if (espaceVide.length > 0) {
>     if (alentours[this.direction] != " ")
>       this.direction = elementAuHasard(espaceVide);
>     return {type: "déplacement",
>             direction: this.direction};
>   }
>   else {
>     return {type: "attente"};
>   }
> };
> MangeuseLichenHabile.prototype.caractere = "c";
>
> typesDeCreature.enregistre(MangeuseLichenHabile);

Essayez-la avec le plan de terrarium précédent.

***

Une chaîne alimentaire à un seul maillon est un peu rudimentaire. Pouvez-vous
écrire une nouvelle créature, nommée |MangeuseMangeuseLichen|, (avec
un caractère |"@"|), qui survit en mangeant des dévoreuses de lichens
? Trouver également un moyen pour cette nouvelle créature de s'intégrer dans
l'écosystème sans qu'elles ne s'éteignent trop vite. Modifiez le tableau
|lichenPlan| pour inclure quelques-unes d'entre elles, et essayez le tout.

///

C'est maintenant à vous de jouer, je n'ai pas trouvé de moyen véritablement
efficace d'empêcher ces créatures de s'éteindre immédiatement ou
d'engloutir tous les dévoreuses de lichen, et de s'éteindre ensuite.
L'astuce qui consiste à autoriser une créature à ne manger que lorsque
deux unités de nourriture sont à proximité ne fonctionnent pas très bien
pour elles, car, leur nourriture étant souvent en déplacement, il est rare
d'en trouver deux à proximité l'une de l'autre.
Rendre les dévoreuses de dévoreuses très grasses (avec beaucoup d'énergie)
à quelque efficacité, car elles peuvent survivre lorsque les dévoreuses
de lichen se font rare et se reproduisent doucement, ce qui empêche une
raréfaction trop rapide de leur nourriture.

Les lichens et les créatures qui les mangent sont dans un mouvement
périodique -- parfois les lichens sont abondants, ce qui provoque beaucoup
de naissance de mangeurs de lichen, ce qui provoque ensuite une rareté du
lichen, puis la rareté des mangeurs de lichen, enfin le lichen prospère
à nouveau, et ainsi de suite.
Vous pouvez essayer de faire 'hiberner' les mangeurs de mangeurs de lichen
(utiliser l'action |"attente"| un certain temps), quand ils n'ont rien à
manger pour quelques tours.
Une stratégie serait de trouver la bonne durée d'hibernation, en nombre
de tours, ou de leur donner un moyen de se réveiller lorsqu'ils sentent
beaucoup de nourriture.

---

Ceci termine notre discussion sur les terraria. Le reste de ce chapitre
est dédié à une exploration en profondeur du concept d'héritage, et les
problèmes liés à l'héritage en JavaScript.

---

Maintenant, un peu de théorie. Les étudiants qui abordent la programmation
orientée objet sont souvent confrontés à des discussions longues et
pleines de subtilité sur les façons correctes et incorrectes d'utiliser
l'héritage. Il est important de garder à l'esprit qu'au bout du compte,
l'héritage est un moyen pour des programmeurs paresseux## d'écrire moins de
code. Ainsi, la question de savoir si l'héritage est correctement utilisé se
résume à la question de savoir si le code produit fonctionne correctement
et n'a pas de répétition inutile. Pour autant, les principes discutés
par ces étudiants sont aussi une bonne façon d'aborder l'héritage.

## La paresse, pour un programmeur, n'est pas forcement un péché. Les
personnes qui, laborieusement, font et refont toujours les mêmes choses
tendent à être de bon travailleurs à la chaine et de mauvais programmeurs.

L'héritage est la création de nouveaux types d'objet, les '_sous-types_',
basés sur des types existants, les '_super-types_'. Le sous-type commence
avec la totalité des propriétés et des méthodes du super-type, il hérite
de lui, ensuite, il en modifie quelques uns, éventuellement en ajoute.
L'héritage est mieux utilisé quand les objets décrit par le sous-type
peuvent être considéré comme *étant* également des objets du super-type.

Ainsi, un type |Piano| peut être un sous-type du type |Instrument|, parce
qu'un piano *est* un instrument. Comme un piano a un tableau de touches,
on peut être tenté de faire de |Piano| un sous-type de |Array|, mais un
piano *n'est pas* un tableau de touches, et l'implémenter de cette façon
entrainerait plein de choses idiotes. Par exemple, un piano a aussi des
pédales. Pourquoi |piano[0]| me renvoie la première touche, et pas la
première pédale ?
La situation est que, évidemment, le piano *possède* des touches, il est
donc meilleur de lui donner une propriété |touches|, et éventuellement
une autre propriété |pédales|, ces deux propriétés étant des tableaux.

Il est possible pour un sous-type d'être le super-type d'un autre
sous-type. Certains problèmes sont mieux résolus en construisant un
arbre complexe de types. Prenez garde à ne pas être trop enthousiaste
avec l'héritage. Une utilisation abusive de l'héritage est un bon moyen
de transformer un programme en un bazar monstrueux.

---

Le fonctionnement du mot-clé |new| et la propriété |prototype| d'un
constructeur suggèrent une certaine façon d'utiliser les objets. Pour des
objets simple, comme les créatures du terrarium, cette façon fonctionne bien.
Malheureusement, quand un programme utilise l'héritage de façon plus
développé, cette approche de la programmation objet devient pesante. Ajouter
des fonctions pour prendre en charge les opérations les plus courantes
peut rendre les choses plus fluides. De nombreuses personnes définissent,
par exemple, des méthodes |inherit| et |method| sur les objets.

> Object.prototype.inherit = function(baseConstructor) {
>   this.prototype = clone(baseConstructor.prototype);
>   this.prototype.constructor = this;
> };
> Object.prototype.method = function(name, func) {
>   this.prototype[name] = func;
> };
>
> function TableauEtrange(){}
> TableauEtrange.inherit(Array);
> TableauEtrange.method("push", function(value) {
>   Array.prototype.push.call(this, value);
>   Array.prototype.push.call(this, value);
> });
>
> var strange = new TableauEtrange();
> strange.push(4);
> show(strange);

Si vous chercher sur internet les mots « JavaScript » et
« héritage », vous trouverez de nombreuses variantes de ces fonctions,
certaines sont plus complexes et plus subtiles que celles ci-dessus.

Remarquez comment la méthode |push| écrite ici utilise la méthode |push|
du prototype de son type parent. C'est quelque chose qui se fait fréquemment
lors de l'utilisation de l'héritage -- une méthode du sous-type utilise
en interne une méthode du super-type, mais en la modifiant d'une manière
ou d'une autre.

---

La plus grande difficulté dans cette approche simpliste est la dualité
entre les constructeurs et les prototypes. Les constructeurs ont un rôle
vraiment central, ils sont le moyen par lequel les objets prennent leur nom,
et quand vous avez besoin d'accéder à un prototype, vous devez passer par
le constructeur et sa propriété prototype.

Cela ajoute *beaucoup* de frappes au clavier (|"prototype"| prend 9 lettres),
mais c'est aussi déroutant. Nous avons eu besoin d'écrire un constructeur
vide et inutile pour |TableauEtrange| dans l'exemple précédent. Quelquefois,
il m'est arrivé d'ajouter par erreur des méthodes à un constructeur au lieu
de son prototype, ou d'essayer d'appeler |Array.slice| alors que je voulais
appeler |Array.prototype.slice|. Autant que je sache, le prototype lui-même
est l'aspect le plus important d'un type d'objet, et le constructeur n'est
qu'une extension de cela, une méthode spéciale.

---

En ajoutant quelques méthodes simples d'aide à |Object.prototype|, il devient
possible de créer une approche alternative aux objets et à l'héritage. Dans
cette approche, un type est représenté par son prototype, et nous allons
utiliser des variables en majuscule pour stocker ces prototypes. Quand il faut
faire un peu de travail de « construction », cela est réalisé par une
méthode appelée |construct|. Nous ajoutons une méthode appelée |create|
au prototype |Object|, qui est utilisée à la place du mot-clé |new|. Elle
clone l'objet, et appelle sa méthode |construct|, si une telle méthode
existe, en lui passant en argument ceux qui ont été passés à |create|.

> Object.prototype.create = function() {
>   var object = clone(this);
>   if (typeof object.construct == "function")
>     object.construct.apply(object, arguments);
>   return object;
> };

L'héritage peut être réalisé en clonant un objet prototype et en ajoutant
ou remplaçant certaines de ses propriétés. Nous fournissons également
une aide pratique pour réaliser cela, une méthode |extend|, qui clone
l'objet sur lequel on l'appelle et qui ajoute à ce clone les propriétés
de l'objet qui lui est donné en argument.

> Object.prototype.extend = function(properties) {
>   var result = clone(this);
>   forEachIn(properties, function(name, value) {
>     result[name] = value;
>   });
>   return result;
> };

Dans le cas où il n'est pas prudent de tripoter le prototype |Object|,
cela peut bien évidemment être implémenté avec des fonctions classiques
(pas des méthodes).

---

Voici un exemple, si vous êtes suffisamment vieux, vous avez peut-être
déjà joué à un jeu d'aventure en mode texte, où vous vous déplaciez
dans un monde virtuel en tapant au clavier des commandes, et obteniez des
réponses sous forme de texte décrivant ce qu'il y avait autour de vous et
les actions que vous effectuiez. Ces jeux ont eu leur temps.

Nous pouvons écrire un prototype pour un élément d'un jeu de ce type.

> var Produit = {
>   construct: function(name) {
>     this.name = name;
>   },
>   inspect: function() {
>     print("C'est ", this.name, ".");
>   },
>   kick: function() {
>     print("Blang !");
>   },
>   take: function() {
>     print("Vous ne pouvez pas soulever ", this.name, ".");
>   }
> };
>
> var lantern = Produit.create("La lanterne en laiton");
> lantern.kick();

Héritons de ce type de cette façon…

> var ProduitDetaille = Produit.extend({
>   construct: function(name, details) {
>     Produit.construct.call(this, name);
>     this.details = details;
>   },
>   inspect: function() {
>     print("vous voyez ", this.name, ", ", this.details, ".");
>   }
> });
>
> var paresseuxGeant = ProduitDetaille.create(
>   "le paresseux geant",
>   "il s'accroche tranquillement sur un arbre en grignotant des feuilles");
> paresseuxGeant.inspect();

Laisser de côté la partie obligatoire du |prototype| rend légérment plus
simples les choses comme l'appel à |Produit.construct| depuis le constructeur
de |ProduitDetaille|. Remarquez que ce serait une mauvaise idée d'écrire
simplement |this.name = name| dans |ProduitDetaille.construct|. Cela duplique
une ligne. Bien sûr, dupliquer une ligne est plus court qu'appeler la fonction
|Produit.construct| mais si on se retrouve à ajouter plus tard quelque chose
dans le constructeur, nous devrons l'ajouter à deux endroits différents.

---

La plupart du temps, le constructeur d'un sous-type commencera par appeler le
constructeur du super-type. De cette façon, il démarre avec un objet valide
du super-type, qu'il peut alors étendre. Dans cette nouvelle approche des
prototypes, les types qui n'ont pas besoin de constructeurs peuvent les laisser
tomber. Ils hériteront automatiquement du constructeur de leur super-type.

> var PetitProduit = Produit.extend({
>   kick: function() {
>     print(this.name, " vole à travers la pièce.");
>   },
>   take: function() {
>     // (imaginer ici du code qui déplace l'objet dans votre poche)
>     print("vous avez pris ", this.name, ".");
>   }
> });
>
> var pencil = PetitProduit.create("le stylo rouge");
> pencil.take();

Même si |PetitProduit| ne définit pas son propre constructeur, le créer
avec un argument |name| fonctionne, car il hérite du constructeur du
prototype |Produit|.

---

JavaScript possède un opérateur appelé _|instanceof|_, qui peut être
utilisé pour déterminer si un objet est basé sur un certain prototype. Vous
lui donnez l'objet du côté gauche, et le constructeur du côté droit, et
il renvoie un booléen, |true| si la propriété |prototype| du constructeur
est le prototype direct ou indirect de l'objet, et |false| sinon.

Lorsque vous utilisez des constructeurs normaux, utiliser cet opérateur
devient plutôt maladroit : il attend la fonction constructeur comme
deuxième argument, mais nous avons seulement des prototypes. Une astuce
similaire à la fonction |clone| peut être utilisée pour éviter cela . Nous
utilisons un « faux constructeur », et nous lui appliquons |instanceof|.

> Object.prototype.hasPrototype = function(prototype) {
>   function DummyConstructor() {}
>   DummyConstructor.prototype = prototype;
>   return this instanceof DummyConstructor;
> };
>
> show(pencil.hasPrototype(Produit));
> show(pencil.hasPrototype(ProduitDetaille));

---

Ensuite, nous voulons créer un petit élément qui posséde une description
détaillée. Il semblerait que cet élément devrait hériter à la fois de
|ProduitDetaille| et |PetitProduit|. JavaScript ne permet pas à un objet
d'avoir plusieurs prototypes, et même s'il le permettait, le problème
ne serait pas simple à résoudre. Par exemple, si |PetitProduit| voulait,
pour une raison quelconque, définir aussi une méthode |inspect|, quelle
méthode |inspect| ce nouveau prototype devrait-il utiliser ?

Dériver un type d'objet de plus d'un type parent est appelé _héritage
multiple_. Certains langages se dégonflent et l'interdisent totalement,
d'autres définissent des systèmes compliqués pour le faire marcher d'une
manière pratique et bien définie. Il est possible d'implémenter un framework
de multi-héritage décent en JavaScript. En fait, il y a, comme d'habitude,
de nombreuses bonnes façons pour réaliser cela. Mais elles sont toutes
trop compliquées pour en discuter ici. À la place, je vais vous montrer
une approche très simple qui est suffisante dans la plupart des cas.

---

Un _mix-in_ (que l'on pourrait traduire par mélange en français) est un type
spécifique de prototype qui peut être « incorporé » dans d'autres
prototypes. |PetitProduit| peut être vu comme un de ces prototypes. En
copiant les méthodes |kick| et |take| dans un autre prototype, nous allons
incorporé la petitesse dans ce prototype.

> function mixInto(object, mixIn) {
>   forEachIn(mixIn, function(name, value) {
>     object[name] = value;
>   });
> };
>
> var PetitProduitDetaille = clone(ProduitDetaille);
> mixInto(PetitProduitDetaille, PetitProduit);
>
> var deadMouse = PetitProduitDetaille.create(
>   "Fred la souris",
>   "Il est mort");
> deadMouse.inspect();
> deadMouse.kick();

Rappelez-vous que |forEachIn| parcourt uniquement les *propres* propriétés
de l'objet, il copiera donc |kick| and |take|, mais pas le constructeur que
|PetitProduit| a hérité de |Produit|.

---

Mélanger les prototypes devient plus complexe quand le mix-in a un
constructeur, ou quand certaines de ses méthodes entre en « collision »
avec les méthodes du prototype dans lequel il est incorporé. Parfois, il
est possible de faire un « mélange manuel ». Disons que nous avons
un prototpye |Monstre|, qui a son propre constructeur, et nous voulons le
mélanger avec |ProduitDetaille|.

> var Monstre = Produit.extend({
>   construct: function(name, dangerous) {
>     Produit.construct.call(this, name);
>     this.dangerous = dangerous;
>   },
>   kick: function() {
>     if (this.dangerous)
>       print(this.name, " arrache votre tête avec ses dents.");
>     else
>       print(this.name, " fuit en pleurant.");
>   }
> });
>
> var MonstreDetaille = ProduitDetaille.extend({
>   construct: function(name, description, dangerous) {
>     ProduitDetaille.construct.call(this, name, description);
>     Monstre.construct.call(this, name, dangerous);
>   },
>   kick: Monstre.kick
> });
>
> var paresseuxGeant = MonstreDetaille.create(
>   "le paresseux geant",
>   "il s'accroche tranquillement sur un arbre en grignotant des feuilles",
>   true);
> paresseuxGeant.kick();

Mais remarquez que cela conduit à appeler deux fois le constructeur de
|Produit| lorsqu'on crée un |MonstreDetaille| : une fois à travers le
constructeur de |ProduitDetaille|, et une fois à travers le constructeur
de |Monstre|. Dans ce cas, il n'y a pas trop de dégâts, mais il existe
des situations dans lesquelles cela pourrait poser problème.

---

Mais ne laissez pas ces complications vous décourager d'utiliser
l'héritage. Les héritages multiples, même s'ils sont très utiles dans
certaines situations, peuvent être ignorés sans problème la plupart du
temps. C'est la raison pour laquelle certains langages comme Java s'en sortent
en interdisant les héritages multiples. Et si, à un moment, vous pensez que
vous en avez vraiment besoin, vous pouvez chercher sur Internet, faire quelques
recherches, et trouver une approche qui fonctionne dans votre situation.

Maintenant que j'y pense, JavaScript serait probablement un fabuleux
environnement de développement pour les aventures en mode texte. Cette
capacité à modifier le comportement des objets à volonté, qui est ce que
nous offre l'héritage par prototype, est très bien adapté à cela. Si vous
avez un objet |hedgehog| (hérisson), qui a la capacité unique de rouler
quand on lui tape dedans, vous pouvez simplement changer sa méthode |kick|.

Malheureusement, les aventures en mode texte ont suivi le même chemin que
les disques vinyls, alors qu'ils étaient populaires à une époque, ils
ne sont joués de nos jours que par une petite population d'[enthousiates |
http://groups.google.com/group/rec.arts.int-fiction/topics].

=======================
Modularity / modularity
=======================

This chapter deals with the process of organising programs. In small
programs, organisation rarely becomes a problem. As a program grows,
however, it can reach a size where its structure and interpretation
become hard to keep track of. Easily enough, such a program starts to
look like a bowl of spaghetti, an amorphous mass in which everything
seems to be connected to everything else.

When structuring a program, we do two things. We separate it into
smaller parts, called _module_s, each of which has a specific role,
and we specify the relations between these parts.

In \\coo, while developing a terrarium, we made use of a number of
functions described in \\cfp. The chapter also defined a few new
concepts that had nothing in particular to do with terraria, such as
|clone| and the |Dictionary| type. All these things were haphazardly
added to the environment. One way to split this program into modules
would be:

 * A module |FunctionalTools|, which contains the functions from \\cfp, and depends on nothing.
 * Then |ObjectTools|, which contains things like |clone| and |create|, and depends on |FunctionalTools|.
 * |Dictionary|, containing the dictionary type, and depending on |FunctionalTools|.
 * And finally the |Terrarium| module, which depends on |ObjectTools| and |Dictionary|.

When a module _depend_s on another module, it uses functions or
variables from that module, and will only work when this module is
loaded.

It is a good idea to make sure dependencies never form a circle. Not
only do circular dependencies create a practical problem (if module
|A| and |B| depend on each other, which one should be loaded first?),
it also makes the relation between the modules less straightforward,
and can result in a modularised version of the spaghetti I mentioned
earlier.

---

Most modern programming languages have some kind of module system
built in. Not JavaScript. Once again, we have to invent something
ourselves. The most obvious way to start is to put every module in a
different file. This makes it clear which code belongs to which
module.

@_|script|_Browsers load JavaScript files when they find a |<script>|
tag with an |src| attribute in the HTML of the web-page. The extension
|.js| is usually used for files containing JavaScript code. On the
console, a shortcut for loading files is provided by the |load|
function.

> load("FunctionalTools.js");

---

In some cases, giving load commands in the wrong order will result in
errors. If a module tries to create a |Dictionary| object, but the
|Dictionary| module has not been loaded yet, it will be unable to find
the constructor, and will fail.

One would imagine this to be easy to solve. Just put some calls to
|load| at the top of the file for a module, to load all the modules it
depends on. Unfortunately, because of the way browsers work, calling
|load| does not immediately cause the given file to be loaded. The
file will be loaded *after* the current file has finished executing.
Which is too late, usually.

In most cases, the practical solution is to just manage dependencies
by hand: Put the |script| tags in your HTML documents in the right
order.

---

There are two ways to (partially) automate dependency management. The
first is to keep a separate file with information about the
dependencies between modules. This can be loaded first, and used to
determine the order in which to load the files. The second way is to
not use a |script| tag (|load| internally creates and adds such a
tag), but to fetch the content of the file directly (see \\cxhr), and
then use the |eval| function to execute it. This makes script loading
instantaneous, and thus easier to deal with.

_|eval|_, short for 'evaluate', is an interesting function. You give
it a string value, and it will execute the content of the string as
JavaScript code.

> eval("print(\"I am a string inside a string!\");");

You can imagine that |eval| can be used to do some interesting things.
Code can build new code, and run it. In most cases, however, problems
that can be solved with creative uses of |eval| can also be solved
with creative uses of anonymous functions, and the latter is less
likely to cause strange problems.

When |eval| is called inside a function, all new variables will become
local to that function. Thus, when a variation of the |load| would use
|eval| internally, loading the |Dictionary| module would create a
|Dictionary| constructor inside of the |load| function, which would be
lost as soon as the function returned. There are ways to work around
this, but they are rather clumsy.

---

Let us quickly go over the first variant of dependency management. It
requires a special file for dependency information, which could look
something like this:

> var dependencies =
>   {"ObjectTools.js": ["FunctionalTools.js"],
>    "Dictionary.js":  ["ObjectTools.js"],
>    "TestModule.js":  ["FunctionalTools.js", "Dictionary.js"]};

The |dependencies| object contains a property for each file that
depends on other files. The values of the properties are arrays of
file names. Note that we could not use a |Dictionary| object here,
because we can not be sure that the |Dictionary| module has been
loaded yet. Because all the properties in this object will end in
|".js"|, they are unlikely to interfere with hidden properties like
|__proto__| or |hasOwnProperty|, and a regular object will work fine.

The dependency manager must do two things. Firstly it must make sure
that files are loaded in the correct order, by loading a file's
dependencies before the file itself. And secondly, it must make sure
that no file is loaded twice. Loading the same file twice might cause
problems, and is definitely a waste of time.

> var loadedFiles = {};
>
> function require(file) {
>   if (dependencies[file]) {
>     var files = dependencies[file];
>     for (var i = 0; i < files.length; i++)
>       require(files[i]);
>   }
>   if (!loadedFiles[file]) {
>     loadedFiles[file] = true;
>     load(file);
>   }
> }

The _|require|_ function can now be used to load a file and all its
dependencies. Note how it recursively calls itself to take care of
dependencies (and possible dependencies of that dependency).

> require("TestModule.js");

> test();

---

Building a program as a set of nice, small modules often means the
program will use a lot of different files. When programming for the
web, having lots of small JavaScript files on a page tends to make the
page slower to load. This does not have to be a problem though. You
can write and test your program as a number of small files, and put
them all into a single big file when 'publishing' the program to the
web.

---

Just like an object type, a module has an interface. In simple
collection-of-functions modules such as |FunctionalTools|, the
interface usually consists of all the functions that are defined in
the module. In other cases, the interface of the module is only a
small part of the functions defined inside it. For example, our
manuscript-to-HTML system from \\cfp only needs an interface of a
single function, |renderFile|. (The sub-system for building HTML would
be a separate module.)

For modules which only define a single type of object, such as
|Dictionary|, the object's interface is the same as the module's
interface.

---

In JavaScript, 'top-level' variables all live together in a single
place. In browsers, this place is an object that can be found under
the name |window|. The name is somewhat odd, |environment| or |top|
would have made more sense, but since browsers associate a JavaScript
environment with a window (or 'frame'), someone decided that |window|
was a logical name.

> show(window);
> show(window.print == print);
> show(window.window.window.window.window);

As the third line shows, the name |window| is merely a property of
this environment object, pointing at itself.

---

When much code is loaded into an environment, it will use many
top-level variable names. Once there is more code than you can really
keep track of, it becomes very easy to accidentally use a name that
was already used for something else. This will break the code that
used the original value. The proliferation of top-level variables is
called _name-space pollution_, and it can be a rather severe problem
in JavaScript -- the language will not warn you when you redefine an
existing variable.

There is no way to get rid of this problem entirely, but it can be
greatly reduced by taking care to cause as little pollution as
possible. For one thing, modules should not use top-level variables
for values that are not part of their external interface.

---

Not being able to define any internal functions and variables at all
in your modules is, of course, not very practical. Fortunately, there
is a trick to get around this. We write all the code for the module
inside a function, and then finally add the variables that are part of
the module's interface to the |window| object. Because they were
created in the same parent function, all the functions of the module
can see each other, but code outside of the module can not.

> function buildMonthNameModule() {
>   var names = ["January", "February", "March", "April",
>                "May", "June", "July", "August", "September",
>                "October", "November", "December"];
>   function getMonthName(number) {
>     return names[number];
>   }
>   function getMonthNumber(name) {
>     for (var number = 0; number < names.length; number++) {
>       if (names[number] == name)
>         return number;
>     }
>   }
>
>   window.getMonthName = getMonthName;
>   window.getMonthNumber = getMonthNumber;
> }
> buildMonthNameModule();
>
> show(getMonthName(11));

This builds a very simple module for translating between month names
and their number (as used by |Date|, where January is |0|). But note
that |buildMonthNameModule| is still a top-level variable that is not
part of the module's interface. Also, we have to repeat the names of
the interface functions three times. Ugh.

---

The first problem can be solved by making the module function
anonymous, and calling it directly. To do this, we have to add a pair
of parentheses around the function value, or JavaScript will think it
is a normal function definition, which can not be called directly.

The second problem can be solved with a helper function, |provide|,
which can be given an object containing the values that must be
exported into the |window| object.

> function provide(values) {
>   forEachIn(values, function(name, value) {
>     window[name] = value;
>   });
> }

Using this, we can write a module like this:

> (function() {
>   var names = ["Sunday", "Monday", "Tuesday", "Wednesday",
>                "Thursday", "Friday", "Saturday"];
>   provide({
>     getDayName: function(number) {
>       return names[number];
>     },
>     getDayNumber: function(name) {
>       for (var number = 0; number < names.length; number++) {
>         if (names[number] == name)
>           return number;
>       }
>     }
>   });
> })();
>
> show(getDayNumber("Wednesday"));

I do not recommend writing modules like this right from the start.
While you are still working on a piece of code, it is easier to just
use the simple approach we have used so far, and put everything at top
level. That way, you can inspect the module's internal values in your
browser, and test them out. Once a module is more or less finished, it
is not difficult to wrap it in a function.

---

There are cases where a module will export so many variables that it
is a bad idea to put them all into the top-level environment. In cases
like this, you can do what the standard |Math| object does, and
represent the module as a single object whose properties are the
functions and values it exports. For example...

> var HTML = {
>   tag: function(name, content, properties) {
>     return {name: name, properties: properties, content: content};
>   },
>   link: function(target, text) {
>     return HTML.tag("a", [text], {href: target});
>   }
>   /* ... many more HTML-producing functions ... */
> };

When you need the content of such a module so often that it becomes
cumbersome to constantly type |HTML|, you can always move it into the
top-level environment using |provide|.

> provide(HTML);
> show(link("http://download.oracle.com/docs/cd/E19957-01/816-6408-10/object.htm",
>           "This is how objects work."));

You can even combine the function and object approaches, by putting
the internal variables of the module inside a function, and having
this function return an object containing its external interface.

---

When adding methods to standard prototypes, such as those of |Array|
and |Object| a similar problem to name-space pollution occurs. If two
modules decide to add a |map| method to |Array.prototype|, you might
have a problem. If these two versions of |map| have the precise same
effect, things will continue to work, but only by sheer luck.

---

Designing an interface for a module or an object type is one of the
subtler aspects of programming. On the one hand, you do not want to
expose too many details. They will only get in the way when using the
module. On the other hand, you do not want to be *too* simple and
general, because that might make it impossible to use the module in
complex or specialised situations.

Sometimes the solution is to provide two interfaces, a detailed
'low-level' one for complicated things, and a simple 'high-level' one
for straightforward situations. The second one can usually be built
very easily using the tools provided by the first one.

In other cases, you just have to find the right idea around which to
base your interface. Compare this to the various approaches to
inheritance we saw in \\coo. By making prototypes the central concept,
rather than constructors, we managed to make some things considerably
more straightforward.

The best way to learn to the value of good interface design is,
unfortunately, to use bad interfaces. Once you get fed up with them,
you'll figure out a way to improve them, and learn a lot in the
process. Try not to assume that a lousy interface is 'just the way it
is'. Fix it, or wrap it in a new interface that is better (we will see
an example of this in \\cdom).

---

There are functions which require a lot of arguments. Sometimes this
means they are just badly designed, and can easily be remedied by
splitting them into a few more modest functions. But in other cases,
there is no way around it. Typically, some of these arguments have a
sensible 'default' value. We could, for example, write yet another
extended version of |range|.

> function range(start, end, stepSize, length) {
>   if (stepSize == undefined)
>     stepSize = 1;
>   if (end == undefined)
>     end = start + stepSize * (length - 1);
>
>   var result = [];
>   for (; start <= end; start += stepSize)
>     result.push(start);
>   return result;
> }
>
> show(range(0, undefined, 4, 5));

It can get hard to remember which argument goes where, not to mention
the annoyance of having to pass |undefined| as a second argument when
a |length| argument is used. We can make passing arguments to this
function more comprehensive by wrapping them in an object.

> function defaultTo(object, values) {
>   forEachIn(values, function(name, value) {
>     if (!object.hasOwnProperty(name))
>       object[name] = value;
>   });
> }
>
> function range(args) {
>   defaultTo(args, {start: 0, stepSize: 1});
>   if (args.end == undefined)
>     args.end = args.start + args.stepSize * (args.length - 1);
>
>   var result = [];
>   for (; args.start <= args.end; args.start += args.stepSize)
>     result.push(args.start);
>   return result;
> }
>
> show(range({stepSize: 4, length: 5}));

The |defaultTo| function is useful for adding default values to an
object. It copies the properties of its second argument into its first
argument, skipping those that already have a value.

---

A module or group of modules that can be useful in more than one
program is usually called a _library_. For many programming languages,
there is a huge set of quality libraries available. This means
programmers do not have to start from scratch all the time, which can
make them a lot more productive. For JavaScript, unfortunately, the
amount of available libraries is not very large.

But recently this seems to be improving. There are a number of good
libraries with 'basic' tools, things like |map| and |clone|. Other
languages tend to provide such obviously useful things as built-in
standard features, but with JavaScript you'll have to either build a
collection of them for yourself or use a library. Using a library is
recommended: It is less work, and the code in a library has usually
been tested more thoroughly than the things you wrote yourself.

Covering these basics, there are (among others) the 'lightweight'
libraries [prototype | http://www.prototypejs.org/], [mootools |
http://mootools.net], [jQuery | http://jquery.com], and [MochiKit |
http://mochikit.com]. There are also some larger 'frameworks'
available, which do a lot more than just provide a set of basic tools.
[YUI | http://developer.yahoo.com/yui/] (by Yahoo), and [Dojo |
http://dojotoolkit.org/] seem to be the most popular ones in that
genre. All of these can be downloaded and used free of charge. My
personal favourite is MochiKit, but this is mostly a matter of taste.
When you get serious about JavaScript programming, it is a good idea
to quickly glance through the documentation of each of these, to get a
general idea about the way they work and the things they provide.

The fact that a basic toolkit is almost indispensable for any
non-trivial JavaScript programs, combined with the fact that there are
so many different toolkits, causes a bit of a dilemma for library
writers. You either have to make your library depend on one of the
toolkits, or write the basic tools yourself and include them with the
library. The first option makes the library hard to use for people who
are using a different toolkit, and the second option adds a lot of
non-essential code to the library. This dilemma might be one of the
reasons why there are relatively few good, widely used JavaScript
libraries. It is possible that, in the future, new versions of
ECMAScript and changes in browsers will make toolkits less necessary,
and thus (partially) solve this problem.

============================
Regular Expressions / regexp
============================

At various points in the previous chapters, we had to look for
patterns in string values. In \\cdata we extracted date values from
strings by writing out the precise positions at which the numbers that
were part of the date could be found. Later, in \\cfp, we saw some
particularly ugly pieces of code for finding certain types of
characters in a string, for example the characters that had to be
escaped in HTML output.

@_regular expression_Regular expressions are a language for describing
patterns in strings. They form a small, separate language, which is
embedded inside JavaScript (and in various other programming
languages, in one way or another). It is not a very readable language
-- big regular expressions tend to be completely unreadable. But, it
is a useful tool, and can really simplify string-processing programs.

---

Just like strings get written between quotes, regular expression
patterns get written between slashes (_|/|_). This means that slashes
inside the expression have to be escaped.

> var slash = /\//;
> show("AC/DC".search(slash));

The _|search|_ method resembles |indexOf|, but it searches for a
regular expression instead of a string. Patterns specified by regular
expressions can do a few things that strings can not do. For a start,
they allow some of their elements to match more than a single
character. In \\cfp, when extracting mark-up from a document, we
needed to find the first asterisk or opening brace in a string. That
could be done like this:

> var asteriskOrBrace = /[\{\*]/;
> var story =
>   "We noticed the *giant sloth*, hanging from a giant branch.";
> show(story.search(asteriskOrBrace));

The |[| and |]| characters have a special meaning inside a regular
expression. They can enclose a set of characters, and they mean 'any
of these characters'. Most non-alphanumeric characters have some
special meaning inside a regular expression, so it is a good idea to
always escape them with a backslash## when you use them to refer to
the actual characters.

## In this case, the backslashes were not really necessary, because
the characters occur between |[| and |]|, but it is easier to just
escape them anyway, so you won't have to think about it.

---

There are a few shortcuts for sets of characters that are needed
often. The dot (|.|) can be used to mean 'any character that is not a
newline', an escaped 'd' (|\d|) means 'any digit', an escaped 'w'
(|\w|) matches any alphanumeric character (including underscores, for
some reason), and an escaped 's' (|\s|) matches any white-space (tab,
newline, space) character.

> var digitSurroundedBySpace = /\s\d\s/;
> show("1a 2 3d".search(digitSurroundedBySpace));

The escaped 'd', 'w', and 's' can be replaced by their capital letter
to mean their opposite. For example, |\S| matches any character that
is *not* white-space. When using |[| and |]|, a pattern can be
inverted by starting with a |^| character:

> var notABC = /[^ABC]/;
> show("ABCBACCBBADABC".search(notABC));

As you can see, the way regular expressions use characters to express
patterns makes them A) very short, and B) very hard to read.

***

Write a regular expression that matches a date in the format
|"XX/XX/XXXX"|, where the |X|s are digits. Test it against the string
|"born 15/11/2003 (mother Spot): White Fang"|.

///

> var datePattern = /\d\d\/\d\d\/\d\d\d\d/;
> show("born 15/11/2003 (mother Spot): White Fang".search(datePattern));

---

Sometimes you need to make sure a pattern starts at the beginning of a
string, or ends at its end. For this, the special characters |^| and
|$| can be used. The first matches the start of the string, the second
the end.

> show(/a+/.test("blah"));
> show(/^a+$/.test("blah"));

The first regular expression matches any string that contains an |a|
character, the second only those strings that consist entirely of |a|
characters.

Note that regular expressions are objects, and have methods. Their
_|test|_ method returns a boolean indicating whether the given string
matches the expression.

The code |\b| matches a 'word boundary', which can be punctuation,
white-space, or the start or end of the string.

> show(/cat/.test("concatenate"));
> show(/\bcat\b/.test("concatenate"));

---

Parts of a pattern can be allowed to be repeated a number of times.
Putting an asterisk (|*|) after an element allows it to be repeated
any number of times, including zero. A plus (|+|) does the same, but
requires the pattern to occur at least one time. A question mark (|?|)
makes an element 'optional' -- it can occur zero or one times.

> var parenthesizedText = /\(.*\)/;
> show("Its (the sloth's) claws were gigantic!".search(parenthesizedText));

When necessary, braces can be used to be more precise about the amount
of times an element may occur. A number between braces (|{4}|) gives
the exact amount of times it must occur. Two numbers with a comma
between them (|{3,10}|) indicate that the pattern must occur at least
as often as the first number, and at most as often as the second one.
Similarly, |{2,}| means two or more occurrences, while |{,4}| means
four or less.

> var datePattern = /\d{1,2}\/\d\d?\/\d{4}/;
> show("born 15/11/2003 (mother Spot): White Fang".search(datePattern));

The pieces |/\d{1,2}/| and |/\d\d?/| both express 'one or two digits'.

***

Write a pattern that matches e-mail addresses. For simplicity, assume
that the parts before and after the |@| can contain only alphanumeric
characters and the characters |.| and |-| (dot and dash), while the
last part of the address, the country code after the last dot, may
only contain alphanumeric characters, and must be two or three
characters long.

///

> var mailAddress = /\b[\w\.-]+@[\w\.-]+\.\w{2,3}\b/;
>
> show(mailAddress.test("kenny@test.net"));
> show(mailAddress.test("I mailt kenny@tets.nets, but it didn wrok!"));
> show(mailAddress.test("the_giant_sloth@gmail.com"));

The |\b|s at the start and end of the pattern make sure that the
second string does not match.

---

Part of a regular expression can be grouped together with parentheses.
This allows us to use |*| and such on more than one character. For
example:

> var cartoonCrying = /boo(hoo+)+/i;
> show("Then, he exclaimed 'Boohoooohoohooo'".search(cartoonCrying));

Where did the |i| at the end of that regular expression come from?
After the closing slash, 'options' may be added to a regular
expression. An |i|, here, means the expression is case-insensitive,
which allows the lower-case B in the pattern to match the upper-case
one in the string.

A pipe character (|||) is used to allow a pattern to make a choice
between two elements. For example:

> var holyCow = /(sacred|holy) (cow|bovine|bull|taurus)/i;
> show(holyCow.test("Sacred bovine!"));

---

Often, looking for a pattern is just a first step in extracting
something from a string. In previous chapters, this extraction was
done by calling a string's |indexOf| and |slice| methods a lot. Now
that we are aware of the existence of regular expressions, we can use
the |match| method instead. When a string is matched against a regular
expression, the result will be |null| if the match failed, or an array
of matched strings if it succeeded.

> show("No".match(/Yes/));
> show("... yes".match(/yes/));
> show("Giant Ape".match(/giant (\w+)/i));

The first element in the returned array is always the part of the
string that matched the pattern. As the last example shows, when there
are parenthesized parts in the pattern, the parts they match are also
added to the array. Often, this makes extracting pieces of string very
easy.

> var parenthesized = prompt("Tell me something", "").match(/\((.*)\)/);
> if (parenthesized != null)
>   print("You parenthesized '", parenthesized[1], "'");

***

Re-write the function |extractDate| that we wrote in \\cdata. When
given a string, this function looks for something that follows the
date format we saw earlier. If it can find such a date, it puts the
values into a |Date| object. Otherwise, it throws an exception. Make
it accept dates in which the day or month are written with only one
digit.

///

> function extractDate(string) {
>   var found = string.match(/(\d\d?)\/(\d\d?)\/(\d{4})/);
>   if (found == null)
>     throw new Error("No date found in '" + string + "'.");
>   return new Date(Number(found[3]), Number(found[2]) - 1,
>                   Number(found[1]));
> }
>
> show(extractDate("born 5/2/2007 (mother Noog): Long-ear Johnson"));

This version is slightly longer than the previous one, but it has the
advantage of actually checking what it is doing, and shouting out when
it is given nonsensical input. This was a lot harder without regular
expressions -- it would have taken a lot of calls to |indexOf| to find
out whether the numbers had one or two digits, and whether the dashes
were in the right places.

---

The _|replace|_ method of string values, which we saw in \\cfp, can be
given a regular expression as its first argument.

> print("Borobudur".replace(/[ou]/g, "a"));

Notice the |g| character after the regular expression. It stands for
'global', and means that every part of the string that matches the
pattern should be replaced. When this |g| is omitted, only the first
|"o"| would be replaced.

Sometimes it is necessary to keep parts of the replaced strings. For
example, we have a big string containing the names of people, one name
per line, in the format "Lastname, Firstname". We want to swap these
names, and remove the comma, to get a simple "Firstname Lastname"
format.

> var names = "Picasso, Pablo\nGauguin, Paul\nVan Gogh, Vincent";
> print(names.replace(/([\w ]+), ([\w ]+)/g, "$2 $1"));

The |$1| and |$2| the replacement string refer to the parenthesized
parts in the pattern. |$1| is replaced by the text that matched
against the first pair of parentheses, |$2| by the second, and so on,
up to |$9|.

If you have more than 9 parentheses parts in your pattern, this will
no longer work. But there is one more way to replace pieces of a
string, which can also be useful in some other tricky situations. When
the second argument given to the |replace| method is a function value
instead of a string, this function is called every time a match is
found, and the matched text is replaced by whatever the function
returns. The arguments given to the function are the matched elements,
similar to the values found in the arrays returned by |match|: The
first one is the whole match, and after that comes one argument for
every parenthesized part of the pattern.

> function eatOne(match, amount, unit) {
>   amount = Number(amount) - 1;
>   if (amount == 1) {
>     unit = unit.slice(0, unit.length - 1);
>   }
>   else if (amount == 0) {
>     unit = unit + "s";
>     amount = "no";
>   }
>   return amount + " " + unit;
> }
>
> var stock = "1 lemon, 2 cabbages, and 101 eggs";
> stock = stock.replace(/(\d+) (\w+)/g, eatOne);
>
> print(stock);

***

That last trick can be used to make the HTML-escaper from \\cfp more
efficient. You may remember that it looked like this: 

> function escapeHTML(text) {
>   var replacements = [["&", "&amp;"], ["\"", "&quot;"],
>                       ["<", "&lt;"], [">", "&gt;"]];
>   forEach(replacements, function(replace) {
>     text = text.replace(replace[0], replace[1]);
>   });
>   return text;
> }

Write a new function |escapeHTML|, which does the same thing, but only
calls |replace| once.

///

> function escapeHTML(text) {
>   var replacements = {"<": "&lt;", ">": "&gt;",
>                       "&": "&amp;", "\"": "&quot;"};
>   return text.replace(/[<>&"]/g, function(character) {
>     return replacements[character];
>   });
> }
>
> print(escapeHTML("The 'pre-formatted' tag is written \"<pre>\"."));

The |replacements| object is a quick way to associate each character
with its escaped version. Using it like this is safe (i.e. no
|Dictionary| object is needed), because the only properties that will
be used are those matched by the |/[<>&"]/| expression.

---

There are cases where the pattern you need to match against is not
known while you are writing the code. Say we are writing a (very
simple-minded) obscenity filter for a message board. We only want to
allow messages that do not contain obscene words. The administrator of
the board can specify a list of words that he or she considers
unacceptable.

The most efficient way to check a piece of text for a set of words is
to use a regular expression. If we have our word list as an array, we
can build the regular expression like this:

> var badWords = ["ape", "monkey", "simian", "gorilla", "evolution"];
> var pattern = new RegExp(badWords.join("|"), "i");
> function isAcceptable(text) {
>   return !pattern.test(text);
> }
>
> show(isAcceptable("Mmmm, grapes."));
> show(isAcceptable("No more of that monkeybusiness, now."));

We could add |\b| patterns around the words, so that the thing about
grapes would not be classified as unacceptable. That would also make
the second one acceptable, though, which is probably not correct.
Obscenity filters are hard to get right (and usually way too annoying
to be a good idea).

The first argument to the _|RegExp|_ constructor is a string
containing the pattern, the second argument can be used to add
case-insensitivity or globalness. When building a string to hold the
pattern, you have to be careful with backslashes. Because, normally,
backslashes are removed when a string is interpreted, any backslashes
that must end up in the regular expression itself have to be escaped:

> var digits = new RegExp("\\d+");
> show(digits.test("101"));

---

The most important thing to know about regular expressions is that
they exist, and can greatly enhance the power of your string-mangling
code. They are so cryptic that you'll probably have to look up the
details on them the first ten times you want to make use of them.
Persevere, and you will soon be off-handedly writing expressions that
look like occult gibberish

[[xkcd_regular_expressions.png]]

(Comic by [Randall Munroe | http://xkcd.com].)

=====================================
Web programming: A crash course / web
=====================================

You are probably reading this in a web browser, so you are likely to
be at least a little familiar with the World Wide Web. This
chapter contains a quick, superficial introduction to the various
elements that make the web work, and the way they relate to
JavaScript. The three after this one are more practical, and show some
of the ways JavaScript can be used to inspect and change a web-page.

---

The Internet is, basically, just a computer network spanning most of
the world. Computer networks make it possible for computers to send
each other messages. The techniques that underlie networking are an
interesting subject, but not the subject of this book. All you have to
know is that, typically, one computer, which we will call the
_server_, is waiting for other computers to start talking to it. Once
another computer, the _client_, opens communications with this server,
they will exchange whatever it is that needs to be exchanged using
some specific language, a _protocol_.

The Internet is used to carry messages for *many* different protocols.
There are protocols for chatting, protocols for file sharing,
protocols used by malicious software to control the computer of the
poor schmuck who installed it, and so on. The protocol that is of
interest to us is that used by the World Wide Web. It is called
_HTTP_, which stands for Hyper Text Transfer Protocol, and is used to
retrieve web-pages and the files associated with them.

In HTTP communication, the server is the computer on which the
web-page is stored. The client is the computer, such as yours, which
asks the server for a page, so that it can display it. Asking for a
page like this is called an '_HTTP request_'.

---

Web-pages and other files that are accessible though the Internet are
identified by _URL_s, which is an abbreviation of Universal Resource
Locators. A URL looks like this:

] http://acc6.its.brooklyn.cuny.edu/~phalsall/texts/taote-v3.html

It is composed of three parts. The start, |http://|, indicates that
this URL uses the HTTP protocol. There are some other protocols, such
as FTP (File Transfer Protocol), which also make use of URLs. The next
part, |acc6.its.brooklyn.cuny.edu|, names the server on which this
page can be found. The end of the URL,
|/~phalsal/texts/taote-v3.html|, names a specific file on this server.

Most of the time, the World Wide Web is accessed using a browser.
After typing a URL or clicking a link, the browser makes the
appropriate HTTP request to the appropriate server. If all goes well,
the server responds by sending a file back to the browser, who shows
it to the user in one way or another.

When, as in the example, the retrieved file is an _HTML_ document, it
will be displayed as a web-page. We briefly discussed HTML in \\cfp,
where we saw that it could refer to image files. In \\cmodularity, we
found that HTML pages can also contain |<script>| tags to load files
of JavaScript code. When showing an HTML document, a browser will
fetch all these extra files from their servers, so it can add them to
the document.

---

Although a URL is supposed to point at a file, it is possible for a
web-server to do something more complicated than just looking up a
file and sending it to the client. -- It can process this file in some
way first, or maybe there is no file at all, but only a program that,
given an URL, has some way of generating the relevant document for it.

Programs that transform or generate documents on a server are a
popular way to make web-pages less static. When a file is just a file,
it is always the same, but when there is a program that builds it
every time it is requested, it could be made to look different for
each person, based on things like whether this person has logged in or
specified certain preferences. This can also make managing the content
of web-pages much easier -- instead of adding a new HTML file whenever
something new is put on a website, a new document is added to some
central storage, and the program knows where to find it and how to
show it to clients.

This kind of web programming is called _server-side programming_. It
affects the document before it is sent to the user. In some cases, it
is also practical to have a program that runs *after* the page has
been sent, when the user is looking at it. This is called _client-side
programming_, because the program runs on the client computer.
Client-side web programming is what JavaScript was invented for.

---

Running programs client-side has an inherent problem. You can never
really know in advance what kinds of programs the page you are
visiting is going to run. If it can send information from your
computer to others, damage something, or infiltrate your system,
surfing the web would be a rather hazardous activity.

To solve this dilemma, browsers severely limit the things a JavaScript
program may do. It is not allowed to look at your files, or to modify
anything not related to the web-page it came with. Isolating a
programming environment like this is called _sand-boxing_. Allowing
the programs enough room to be useful, and at the same time
restricting them enough to prevent them from doing harm is not an easy
thing to do. Every few months, some JavaScript programmer comes up
with a new way to circumvent the limitations and do something harmful
or privacy-invading. The people responsible for the browsers respond
by modifying their programs to make this trick impossible, and all is
well again -- until the next problem is discovered.

---

One of the first JavaScript tricks that became widely used is the
@_|window.open|__|open|_ method of the |window| object. It takes a URL
as an argument, and will open a new window showing that URL.

> var perry = window.open("http://www.pbfcomics.com");

Unless you turned off pop-up blocking in \\cfp, there's a chance that
this new window is blocked. There is a good reason pop-up blockers
exist. Web-programmers, especially those trying to get people to pay
attention to advertisements, have abused the poor |window.open| method
so much that by now, most users hate it with a passion. It has its
place though, and in this book we will be using it to show some
example pages. As a general rule, your scripts should not open any new
windows unless the user asked for them.

Note that, because |open| (just like |setTimeout| and company) is a
method on the |window| object, the |window.| part can be left off.
When a function is called 'normally', it is called as a method on the
top-level object, which is what |window| is. Personally, I think
|open| sounds a bit generic, so I'll usually type |window.open|, which
makes it clear that it is a window that is being opened.

The value returned by |window.open| is a new window. This is the
global object for the script running in that window, and contains all
the standard things like the |Object| constructor and the |Math|
object. But if you try to look at them, most browsers will (probably)
not let you...

!> show(perry.Math);

This is part of the sand-boxing that I mentioned earlier. Pages opened
by your browser might show information that is meant only for you, for
example on sites where you logged in, and thus it would be bad if any
random script could go and read them. The exception to this rule is
pages opened on the same domain: When a script running on a page from
|eloquentjavascript.net| opens another page on that same domain, it
can do everything it wants to this page.

An opened window can be closed with its @_|window.close|__|close|_
method. If you didn't already close it yourself...

> perry.close();

Other kinds of sub-documents, such as frames
(documents-within-a-document), are also windows from the perspective
of a JavaScript program, and have their own JavaScript environment. In
fact, the environment that you have access to in the console belongs
to a small invisible frame hidden somewhere on this page -- this way,
it is slightly harder for you to accidentally mess up the whole page.

---

Every window object has a _|document|_ property, which contains an
object representing the document shown in that window. This object
contains, for example, a property @_|document.location|_|location|,
with information about the URL of the document.

> show(document.location.href);

Setting |document.location.href| to a new URL can be used to make the
browser load another document. Another application of the |document|
object is its @_|document.write|_|write| method. This method, when
given a string argument, writes some HTML to the document. When it is
used on a fully loaded document, it will replace the whole document by
the given HTML, which is usually not what you want. The idea is to
have a script call it while the document is being loaded, in which
case the written HTML will be inserted into the document at the place
of the |script| tag that triggered it. This is a simple way to add
some dynamic elements to a page. For example, here is a trivially
simple document showing the current time.

> print(timeWriter);
> var time = viewHTML(timeWriter);

> time.close();

Often, the techniques shown in \\cdom provide a cleaner and more
versatile way to modify the document, but occasionally,
|document.write| is the nicest, simplest way to do something.

---

Another popular application of JavaScript in web pages centers around
_form_s. In case you are not quite sure what the role of 'forms' is,
let me give a quick summary.

A basic HTTP request is a simple request for a file. When this file is
not really a passive file, but a server-side program, it can become
useful to include information other than a filename in the request.
For this purpose, HTTP requests are allowed to contain additional
'parameters'. Here is an example:

] http://www.google.com/search?q=aztec%20empire

After the filename (|/search|), the URL continues with a question
mark, after which the parameters follow. This request has one
parameter, called |q| (for 'query', presumably), whose value is |aztec
empire|. The |%20| part corresponds to a space. There are a number of
characters that can not occur in these values, such as spaces,
ampersands, or question marks. These are 'escaped' by replacing them
with a |%| followed by their numerical value##, which serves the same
purpose as the backslashes used in strings and regular expressions,
but is even more unreadable.

## The value a character gets is decided by the ASCII standard, which
assigns the numbers 0 to 127 to a set of letters and symbols used by
the Latin alphabet. This standard is a precursor of the Unicode
standard mentioned in \\cbasics.

JavaScript provides functions _|encodeURIComponent|_ and
_|decodeURIComponent|_ to add these codes to strings and remove them
again.

> var encoded = encodeURIComponent("aztec empire");
> show(encoded);
> show(decodeURIComponent(encoded));

When a request contains more than one parameter, they are separated by
ampersands, as in...

] http://www.google.com/search?q=aztec%20empire&lang=nl

---

A form, basically, is a way to make it easy for browser-users to
create such parameterised URLs. It contains a number of fields, such
as input boxes for text, checkboxes that can be 'checked' and
'unchecked', or thingies that allow you to choose from a given set of
values. It also usually contains a 'submit' button and, invisible to
the user, an 'action' URL to which it should be sent. When the submit
button is clicked, or enter is pressed, the information that was
entered in the fields is added to this action URL as parameters, and
the browser will request this URL.

Here is the HTML for a simple form:

] <form name="userinfo" method="get" action="info.html">
]   <p>Please give us your information, so that we can send
]   you spam.</p>
]   <p>Name: <input type="text" name="name"/></p>
]   <p>E-Mail: <input type="text" name="email"/></p>
]   <p>Sex: <select name="sex">
]             <option>Male</option>
]             <option>Female</option>
]             <option>Other</option>
]           </select></p>
]   <p><input name="send" type="submit" value="Send!"/></p>
] </form>

The name of the form can be used to access it with JavaScript, as we
shall see in a moment. The names of the fields determine the names of
the HTTP parameters that are used to store their values. Sending this
form might produce a URL like this:

] http://planetspam.com/info.html?name=Ted&email=ted@zork.com&sex=Male

There are quite a few other tags and properties that can be used in
forms, but in this book we will stick with simple ones, so that we can
concentrate on JavaScript.

---

The |method="get"| property of the example form shown above indicates
that this form should encode the values it is given as URL parameters,
as shown before. There is an alternative method for sending
parameters, which is called |post|. An HTTP request using the |post|
method contains, in addition to a URL, a block of data. A form using
the |post| method puts the values of its parameters in this data block
instead of in the URL.

When sending big chunks of data, the |get| method will result in URLs
that are a mile wide, so |post| is usually more convenient. But the
difference between the two methods is not just a question of
convenience. Traditionally, |get| requests are used for requests that
just ask the server for some document, while |post| requests are used
to take an action that changes something on the server. For example,
getting a list of recent messages on an Internet forum would be a
|get| request, while adding a new message would be a |post| request.
There is a good reason why most pages follow this distinction --
programs that automatically explore the web, such as those used by
search engines, will generally only make |get| requests. If changes to
a site can be made by |get| requests, these well-meaning 'crawlers'
could do all kinds of damage.

---

When the browser is displaying a page containing a form, JavaScript
programs can inspect and modify the values that are entered in the
form's fields. This opens up possibilities for all kinds of tricks,
such as checking values before they are sent to the server, or
automatically filling in certain fields.

The form shown above can be found in the file |example_getinfo.html|.
Open it.

> var form = window.open("example_getinfo.html");

When a URL does not contain a server name, is called a _relative URL_.
Relative URLs are interpreted by the browser to refer to files on the
same server as the current document. Unless they start with a slash,
the path (or directory) of the current document is also retained, and
the given path is appended to it.

We will be adding a validity check to the form, so that it only
submits if the name field is not left empty and the e-mail field
contains something that looks like a valid e-mail address. Because we
no longer want the form to submit immediately when the 'Send!' button
is pressed, its |type| property has been changed from |"submit"| to
|"button"|, which turns it into a regular button with no effect. --
\\Cevent will show a *much* better way of doing this, but for now, we
use the naive method.

---

@_|attach|_To be able to work with the newly opened window (if you
closed it, re-open it first), we 'attach' the console to it, like
this:

> attach(form);

After doing this, the code run from the console will be run in the
given window. To verify that we are indeed working with the correct
window, we can look at the document's |location| and |title|
properties.

> print(document.location.href);
> print(document.title);

Because we have entered a new environment, previously defined
variables, such as |form|, are no longer present.

!> show(form);

@_|detach|_To get back to our starting environment, we can use the
|detach| function (without arguments). But first, we have to add that
validation system to the form.

---

Every HTML tag shown in a document has a JavaScript object associated
with it. These objects can be used to inspect and manipulate almost
every aspect of the document. In this chapter, we will work with the
objects for forms and form fields, \\cdom talks about these objects in
more detail.

@_|document.forms|_The |document| object has a property named |forms|,
which contains links to all the forms in the document, by name. Our
form has a property |name="userinfo"|, so it can be found under the
property |userinfo|.

> var userForm = document.forms.userinfo;
> print(userForm.method);
> print(userForm.action);

In this case, the properties |method| and |action| that were given to
the HTML |form| tag are also present as properties of the JavaScript
object. This is often the case, but not always: Some HTML properties
are spelled differently in JavaScript, others are not present at all.
\\Cdom will show a way to get at all properties.

The object for the |form| tag has a property |elements|, which refers
to an object containing the fields of the form, by name.

> var nameField = userForm.elements.name;
> nameField.value = "Eugène";

Text-input objects have a |value| property, which can be used to read
and change their content. If you look at the form window after running
the above code, you'll see that the name has been filled in.

***

Being able to read the values of the form fields makes it possible to
write a function |validInfo|, which takes a form object as its
argument and returns a boolean value: |true| when the |name| field is
not empty and the |email| field contains something that looks like an
e-mail address, |false| otherwise. Write this function.

///

> function validInfo(form) {
>   return form.elements.name.value != "" &&
>     /^.+@.+\.\w{2,3}$/.test(form.elements.email.value);
> }
>
> show(validInfo(document.forms.userinfo));

You did think to use a regular expression for the e-mail check, didn't
you?

---

All we have to do now is determine what happens when people click the
'Send!' button. At the moment, it does not do anything at all. This
can be remedied by setting its |onclick| property.

> userForm.elements.send.onclick = function() {
>   alert("Click.");
> };

Just like the actions given to |setInterval| and |setTimeout| (\\coo),
the value stored in an _|onclick|_ (or similar) property can be either
a function or a string of JavaScript code. In this case, we give it a
function that opens an alert window. Try clicking it.

***

Finish the form validator by giving the button's |onclick| property a
new value -- a function that checks the form, submits when it is
valid, or pops up a warning message when it is not. It will be useful
to know that form objects have a _|submit|_ method that takes no
parameters and submits the form.

///

> userForm.elements.send.onclick = function() {
>   if (validInfo(userForm))
>     userForm.submit();
>   else
>     alert("Give us a name and a valid e-mail address!");
> };

---

Another trick related to form inputs, as well as other things that can
be 'selected', such as buttons and links, is the _|focus|_ method.
When you know for sure that a user will want to start typing in a
certain text field as soon as he enters the page, you can have your
script start by placing the cursor in it, so he won't have to click it
or select it in some other way.

> userForm.elements.name.focus();

Because the form sits in another window, it may not be obvious that
something was selected, depending on the browser you are using. Some
pages also automatically make the cursor jump to the next field when
it looks like you finished filling in one field -- for example, when
you type a zip code. This should not be overdone -- it makes the page
behave in a way the user does not expect. If he is used to pressing
tab to move the cursor manually, or mistyped the last character and
wants to remove it, such magic cursor-jumping is very annoying.

---

> detach();

Test the validator. When you enter valid information and click the
button, the form should submit. If the console was still attached to
it, this will cause it to detach itself, because the page reloads and
the JavaScript environment is replaced by a new one.

If you haven't closed the form window yet, this will close it.

> form.close();

---

The above may look easy, but let me assure you, client-side
web programming is no walk in the park. It can, at times, be a very
painful ordeal. Why? Because programs that are supposed to run on the
client computer generally have to work for all popular browsers. Each
of these browsers tends to work slightly different. To make things
worse, each of them contains a unique set of problems. Do not assume
that a program is bug-free just because it was made by a multi-billion
dollar company. So it is up to us, the web-programmer, to rigorously
test our programs, figure out what goes wrong, and find ways to work
around it.

Some of you might think "I will just report any problems/_bug_s I find
to the browser manufacturers, and they will certainly solve fix them
immediately". These people are in for a major disappointment. The most
recent version of Internet Explorer, the browser that is still used by
some seventy percent of web-surfers (and that every web-developer
likes to rag on) still contains bugs that have been known for over
five years. Serious bugs, too.

But do not let that discourage you. With the right kind of
obsessive-compulsive mindset, such problems provide wonderful
challenges. And for those of us who do not like wasting our time,
being careful and avoiding the obscure corners of the browser's
functionality will generally prevent you from running into too much
trouble.

---

Bugs aside, the by-design differences in interface between browsers
still make for an interesting challenge. The current situation looks
something like this: On the one hand, there are all the 'small'
browsers: Firefox, Safari, and Opera are the most important ones, but
there are more. These browsers all make a reasonable effort to adhere
to a set of standards that have been developed, or are being
developed, by the W3C, an organisation that tries to make the Web a
less confusing place by defining standard interfaces for things like
this. On the other hand, there is Internet Explorer, Microsoft's
browser, which rose to dominance in a time when many of these
standards did not really exist yet, and hasn't made much effort to
adjust itself to what other people are doing.

In some areas, such as the way the content of an HTML document can be
approached from JavaScript (\\cdom), the standards are based on the
method that Internet Explorer invented, and things work more or less
the same on all browsers. In other areas, such as the way events
(mouse-clicks, key-presses, and such) are handled (\\cevent), Internet
Explorer works radically different from other browsers.

For a long time, owing partially to the cluelessness of the average
JavaScript developer, and partially to the fact that browser
incompatibilities were much worse when browsers like Internet Explorer
version 4 or 5 and old versions of Netscape were still common, the
usual way to deal with such differences was to detect which browser
the user was running, and litter code with alternate solutions for
each browser -- if this is Internet Explorer, do this, if this is
Netscape, do that, and if this is other browser that we didn't think
of, just hope for the best. You can imagine how hideous, confusing,
and long such programs were.

Many sites would also just refuse to load when opened in a browser
that was 'not supported'. This caused a few of the minor browsers to
swallow their pride and pretend they were Internet Explorer, just so
they would be allowed to load such pages. The properties of the
_|navigator|_ object contain information about the browser that a page
was loaded in, but because of such lying this information is not
particularly reliable. See what yours says##:

## Some browsers seem to hide the properties of the |navigator|
object, in which case this will print nothing.

> forEachIn(navigator, function(name, value) {
>   print(name, " = ", value);
> });

A better approach is to try and 'isolate' our programs from
differences in browsers. If you need, for example, to find out more
about an event, such as the clicks we handled by setting the |onclick|
property of our send button, you have to look at the top-level object
called |event| on Internet Explorer, but you have to use the first
argument passed to the event-handling function on other browsers. To
handle this, and a number of other differences related to events, one
can write a helper function for attaching events to things, which
takes care of all the plumbing and allows the event-handling functions
themselves to be the same for all browsers. In \\cevent we will write
such a function.

(Note: The browser quirks mentioned in the following chapters refer to
the state of affairs in early 2007, and might no longer be accurate on
some points.)

---

These chapters will only give a somewhat superficial introduction to
the subject of browser interfaces. They are not the main subject of
this book, and they are complex enough to fill a thick book on their
own. When you understand the basics of these interfaces (and
understand something about HTML), it is not too hard to look for
specific information online. The interface documentation for the
[Firefox | https://developer.mozilla.org/en/Gecko_DOM_Reference]
and [Internet Explorer |
http://msdn2.microsoft.com/library/yek4tbz0.aspx] browsers are a good
place to start.

The information in the next chapters will not deal with the quirks of
'previous-generation' browsers. They deal with Internet Explorer 6,
Firefox 1.5, Opera 9, Safari 3, or any more recent versions of the
same browsers. Most of it will also probably be relevant to modern but
obscure browsers such as Konqueror, but this has not been extensively
checked. Fortunately, these previous-generation browsers have pretty
much died out, and are hardly used anymore.

There is, however, a group of web-users that will still use a browser
without JavaScript. A large part of this group consists of people
using a regular graphical browser, but with JavaScript disabled for
security reasons. Then there are people using textual browsers, or
browsers for blind people. When working on a 'serious' site, it is
often a good idea to start with a plain HTML system that works, and
then add non-essential tricks and conveniences with JavaScript.

===============================
The Document-Object Model / dom
===============================

In \\cweb we saw JavaScript objects referring to |form| and |input|
tags from the HTML document. Such objects are part of a structure
called the _Document-Object Model_ (_DOM_). Every tag of the document
is represented in this model, and can be looked up and interacted
with.

HTML documents have what is called a hierarchical structure. Each
element (or tag) except the top |<html>| tag is contained in another
element, its parent. This element can in turn contain child elements.
You can visualise this as a kind of family tree:

[[html.png]]

The document-object model is based on such a view of the document.
Note that the tree contains two types of elements: Nodes, which are
shown as blue boxes, and pieces of simple text. The pieces of text, as
we will see, work somewhat different than the other elements. For one
thing, they never have children.

Open the file |example_alchemy.html|, which contains the document
shown in the picture, and attach the console to it.

> attach(window.open("example_alchemy.html"));

@_|document.documentElement|_The object for the root of the document
tree, the |html| node, can be reached through the |documentElement|
property of the |document| object. Most of the time, we need access to
the |body| part of the document instead, which is at
_|document.body|_.

---

The links between these nodes are available as properties of the node
objects. Every DOM object has a _|parentNode|_ property, which refers
to the object in which it is contained, if any. These parents also
have links pointing back to their children, but because there can be
more than one child, these are stored in a pseudo-array called
_|childNodes|_.

> show(document.body);
> show(document.body.parentNode);
> show(document.body.childNodes.length);

For convenience, there are also links called _|firstChild|_ and
_|lastChild|_, pointing at the first and last child inside a node, or
|null| when there are no children.

> show(document.documentElement.firstChild);
> show(document.documentElement.lastChild);

Finally, there are properties called _|nextSibling|_ and
_|previousSibling|_, which point at the nodes sitting 'next' to a node
-- nodes that are children of the same parent, coming before or after
the current node. Again, when there is no such sibling, the value of
these properties is |null|.

> show(document.body.previousSibling);
> show(document.body.nextSibling);

---

To find out whether a node represents a simple piece of text or an
actual HTML node, we can look at its _|nodeType|_ property. This
contains a number, |1| for regular nodes and |3| for text nodes. There
are actually other kinds of objects with a |nodeType|, such as the
|document| object, which has |9|, but the most common use for this
property is distinguishing between text nodes and other nodes.

> function isTextNode(node) {
>   return node.nodeType == 3;
> }
>
> show(isTextNode(document.body));
> show(isTextNode(document.body.firstChild.firstChild));

Regular nodes have a property called _|nodeName|_, indicating the type
of HTML tag that they represent. Text nodes, on the other hand, have a
_|nodeValue|_, containing their text content.

> show(document.body.firstChild.nodeName);
> show(document.body.firstChild.firstChild.nodeValue);

The |nodeName|s are always capitalised, which is something you need to
take into account if you ever want to compare them to something.

> function isImage(node) {
>   return !isTextNode(node) && node.nodeName == "IMG";
> }
>
> show(isImage(document.body.lastChild));

***

Write a function |asHTML| which, when given a DOM node, produces a
string representing the HTML text for that node and its children. You
may ignore attributes, just show nodes as |<nodename>|. The
|escapeHTML| function from \\cregexp is available to properly escape
the content of text nodes.

Hint: Recursion!

///

> function asHTML(node) {
>   if (isTextNode(node))
>     return escapeHTML(node.nodeValue);
>   else if (node.childNodes.length == 0)
>     return "<" + node.nodeName + "/>";
>   else
>     return "<" + node.nodeName + ">" +
>            map(asHTML, node.childNodes).join("") +
>            "</" + node.nodeName + ">";
> }
>
> print(asHTML(document.body));

---

Nodes, in fact, already have something similar to |asHTML|. Their
_|innerHTML|_ property can be used to retrieve the HTML text *inside*
of the node, without the tags for the node itself. Some browsers also
support |outerHTML|, which does include the node itself, but not all
of them.

> print(document.body.innerHTML);

Some of these properties can also be modified. Setting the |innerHTML|
of a node or the |nodeValue| of a text-node will change its content.
Note that, in the first case, the given string is interpreted as HTML,
while in the second case it is interpreted as plain text.

> document.body.firstChild.firstChild.nodeValue =
>   "Chapter 1: The deep significance of the bottle";

Or ...

> document.body.firstChild.innerHTML =
>   "Did you know the 'blink' tag yet? <blink>Joy!</blink>";

---

We have been accessing nodes by going through a series of |firstChild|
and |lastChild| properties. This can work, but it is verbose and easy
to break -- if we add another node at the start of our document,
|document.body.firstChild| no longer refers to the |h1| element, and
code which assumes it does will go wrong. On top of that, some
browsers will add text-nodes for things like spaces and newlines
between tags, while others do not, so that the exact layout of the DOM
tree can vary.

An alternative to this is to give elements that you need to have
access to an |id| attribute. In the example page, the picture has an
id |"picture"|, and we can use this to look it up.

> var picture = document.getElementById("picture");
> show(picture.src);
> picture.src = "img/ostrich.png";

@_|document.getElementById|_When typing |getElementById|, note that
the last letter is lowercase. Also, when typing it a lot, beware of
carpal-tunnel syndrome. Because |document.getElementById| is a
ridiculously long name for a very common operation, it has become a
convention among JavaScript programmers to aggressively abbreviate it
to _|$|_. |$|, as you might remember, is considered a letter by
JavaScript, and is thus a valid variable name.

> function $(id) {
>   return document.getElementById(id);
> }
> show($("picture"));

DOM nodes also have a method _|getElementsByTagName|_ (another nice,
short name), which, when given a tag name, returns an array of all
nodes of that type contained in the node it was called on.

> show(document.body.getElementsByTagName("BLINK")[0]);

---

Another thing we can do with these DOM nodes is creating new ones
ourselves. This makes it possible to add pieces to a document at will,
which can be used to create some interesting effects. Unfortunately,
the interface for doing this is extremely clumsy. But that can be
remedied with some helper functions.

@_|document.createElement|_@_|document.createTextNode|_The |document|
object has |createElement| and |createTextNode| methods. The first is
used to create regular nodes, the second, as the name suggests,
creates text nodes.

> var secondHeader = document.createElement("H1");
> var secondTitle = document.createTextNode("Chapter 2: Deep magic");

Next, we'll want to put the title name into the |h1| element, and then
add the element to the document. The simplest way to do this is the
_|appendChild|_ method, which can be called on every (non-text) node.

> secondHeader.appendChild(secondTitle);
> document.body.appendChild(secondHeader);

Often, you will also want to give these new nodes some attributes. For
example, an |img| (image) tag is rather useless without an |src|
property telling the browser which image it should show. Most
attributes can be approached directly as properties of the DOM nodes,
but there are also methods _|setAttribute|_ and _|getAttribute|_,
which are used to access attributes in a more general way:

> var newImage = document.createElement("IMG");
> newImage.setAttribute("src", "img/Hiva Oa.png");
> document.body.appendChild(newImage);
> show(newImage.getAttribute("src"));

---

But, when we want to build more than a few simple nodes, it gets very
tiresome to create every single node with a call to
|document.createElement| or |document.createTextNode|, and then add
its attributes and child nodes one by one. Fortunately, it is not hard
to write a function to do most of the work for us. Before we do so,
there is one little detail to take care of -- the |setAttribute|
method, while working fine on most browsers, does not always work on
Internet Explorer. The names of a few HTML attributes already have a
special meaning in JavaScript, and thus the corresponding object
properties got an adjusted name. Specifically, the |class| attribute
becomes _|className|_, |for| becomes |htmlFor|, and |checked| is
renamed to |defaultChecked|. On Internet Explorer, |setAttribute| and
|getAttribute| also work with these adjusted names, instead of the
original HTML names, which can be confusing. On top of that the
_|style|_ attribute, which, along with |class|, will be discussed
later in this chapter, can not be set with |setAttribute| on that
browser.

A workaround would look something like this:

> function setNodeAttribute(node, attribute, value) {
>   if (attribute == "class")
>     node.className = value;
>   else if (attribute == "checked")
>     node.defaultChecked = value;
>   else if (attribute == "for")
>     node.htmlFor = value;
>   else if (attribute == "style")
>     node.style.cssText = value;
>   else
>     node.setAttribute(attribute, value);
> }

For every case where Internet Explorer deviates from other browsers,
it does something that works in all cases. Don't worry about the
details -- this is the kind of ugly trick that we'd rather not need,
but which non-conforming browsers force us to write. Having this, it
is possible to write a simple function for building DOM elements.

> function dom(name, attributes) {
>   var node = document.createElement(name);
>   if (attributes) {
>     forEachIn(attributes, function(name, value) {
>       setNodeAttribute(node, name, value);
>     });
>   }
>   for (var i = 2; i < arguments.length; i++) {
>     var child = arguments[i];
>     if (typeof child == "string")
>       child = document.createTextNode(child);
>     node.appendChild(child);
>   }
>   return node;
> }
>
> var newParagraph = 
>   dom("P", null, "A paragraph with a ",
>       dom("A", {href: "http://en.wikipedia.org/wiki/Alchemy"},
>           "link"),
>       " inside of it.");
> document.body.appendChild(newParagraph);

The _|dom|_ function creates a DOM node. Its first argument gives the
tag name of the node, its second argument is an object containing the
attributes of the node, or |null| when no attributes are needed. After
that, any amount of arguments may follow, and these are added to the
node as child nodes. When strings appear here, they are first put into
a text node.

---

|appendChild| is not the only way nodes can be inserted into another
node. When the new node should not appear at the end of its parent,
the _|insertBefore|_ method can be used to place it in front of
another child node. It takes the new node as a first argument, and the
existing child as second argument.

> var link = newParagraph.childNodes[1];
> newParagraph.insertBefore(dom("STRONG", null, "great "), link);

If a node that already has a |parentNode| is placed somewhere, it is
automatically removed from its current position -- nodes can not exist
in the document in more than one place.

When a node must be replaced by another one, use the _|replaceChild|_
method, which again takes the new node as first argument and the
existing one as second argument.

> newParagraph.replaceChild(document.createTextNode("lousy "),
>                           newParagraph.childNodes[1]);

And, finally, there is _|removeChild|_ to remove a child node. Note
that this is called on the *parent* of the node to be removed, giving
the child as argument.

> newParagraph.removeChild(newParagraph.childNodes[1]);

***

Write the convenient function _|removeElement|_ which removes the DOM
node it is given as an argument from its parent node.

///

> function removeElement(node) {
>   if (node.parentNode)
>     node.parentNode.removeChild(node);
> }
>
> removeElement(newParagraph);

---

When creating new nodes and moving nodes around it is necessary to be
aware of the following rule: Nodes are not allowed to be inserted into
another document from the one in which they were created. This means
that if you have extra frames or windows open, you can not take a
piece of the document from one and move it to another, and nodes
created with methods on one |document| object must stay in that
document. Some browsers, notably Firefox, do not enforce this
restriction, and thus a program which violates it will work fine in
those browsers but break on others.

---

An example of something useful that can be done with this |dom|
function is a program that takes JavaScript objects and summarises
them in a _table_. Tables, in HTML, are created with a set of tags
starting with |t|s, something like this:

] <table>
]   <tbody>
]     <tr> <th>Tree </th> <th>Flowers</th> </tr>
]     <tr> <td>Apple</td> <td>White  </td> </tr>
]     <tr> <td>Coral</td> <td>Red    </td> </tr>
]     <tr> <td>Pine </td> <td>None   </td> </tr>
]   </tbody>
] </table>

Each |tr| element is a row of the table. |th| and |td| elements are
the cells of the table, |td|s are normal data cells, |th| cells are
'header' cells, which will be displayed in a slightly more prominent
way. The |tbody| (table body) tag does not have to be included when a
table is written as HTML, but when building a table from DOM nodes it
should be added, because Internet Explorer refuses to display tables
created without a |tbody|.

***

The function |makeTable| takes two arrays as arguments. The first
contains the JavaScript objects that it should summarise, and the
second contains strings, which name the columns of the table and the
properties of the objects that should be shown in these columns. For
example, the following will produce the table above:

!> makeTable([{Tree: "Apple", Flowers: "White"},
!>            {Tree: "Coral", Flowers: "Red"},
!>            {Tree: "Pine",  Flowers: "None"}],
!>           ["Tree", "Flowers"]);

Write this function.

///

> function makeTable(data, columns) {
>   var headRow = dom("TR");
>   forEach(columns, function(name) {
>     headRow.appendChild(dom("TH", null, name));
>   });
>
>   var body = dom("TBODY", null, headRow);
>   forEach(data, function(object) {
>     var row = dom("TR");
>     forEach(columns, function(name) {
>       row.appendChild(dom("TD", null, String(object[name])));
>     });
>     body.appendChild(row);
>   });
>
>   return dom("TABLE", null, body);
> }
>
> var table = makeTable(document.body.childNodes,
>                       ["nodeType", "tagName"]);
> document.body.appendChild(table);

Do not forget to convert the values from the objects to strings before
adding them to the table -- our |dom| function only understands
strings and DOM nodes.

---

Closely tied to HTML and the document-object model is the topic of
_style-sheet_s. It is a big topic, and I will not discuss it entirely,
but some understanding of style-sheets is necessary for a lot of
interesting JavaScript techniques, so we will go over the basics.

In old-fashioned HTML, the only way to change the appearance of
elements in a document was to give them extra attributes or to wrap
them in extra tags, such as |center| to center them horizontally, or
|font| to change the font style or colour. Most of the time, this meant
that if you wanted the paragraphs or the tables in your document to
look a certain way, you had to add a bunch of attributes and tags to
*every single one of them*. This quickly adds a lot of noise to such
documents, and makes them very painful to write or change by hand.

Of course, people being the inventive monkeys they are, someone came
up with a solution. Style-sheets are a way to make statements like 'in
this document, all paragraphs use the Comic Sans font, and are purple,
and all tables have a thick green border'. You specify them once, at
the top of the document or in a separate file, and they affect the
whole document. Here, for example, is a style-sheet to make headers 22
points big and centered, and make paragraphs use the font and colour
mentioned earlier, when they are of the 'ugly' class.

] <style type="text/css">
]   h1 {
]     font-size: 22pt;
]     text-align: center;
]   }
]
]   p.ugly {
]     font-family: Comic Sans MS;
]     color: purple;
]   }
] </style>

Classes are a concept related to styles. If you have different kinds
of paragraphs, ugly ones and nice ones for example, setting the style
for all |p| elements is not what you want, so _class_es can be used to
distinguish between them. The above style will only be applied to
paragraphs like this:

] <p class="ugly">Mirror, mirror...</p>

And this is also the meaning of the _|className|_ property which was
briefly mentioned for the |setNodeAttribute| function. The _|style|_
attribute can be used to add a piece of style directly to an element.
For example, this gives our image a solid border 4 pixels ('px') wide.

> setNodeAttribute($("picture"), "style",
>                  "border-width: 4px; border-style: solid;");

---

There is much more to styles: Some styles are inherited by child nodes
from parent nodes, and interfere with each other in complex and
interesting ways, but for the purpose of DOM programming, the most
important thing to know is that each DOM node has a |style| property,
which can be used to manipulate the style of that node, and that there
are a few kinds of styles that can be used to make nodes do
extraordinary things.

This |style| property refers to an object, which has properties for
all the possible elements of the style. We can, for example, make the
picture's border green.

> $("picture").style.borderColor = "green";
> show($("picture").style.borderColor);

Note that in style-sheets, the words are separated by hyphens, as in
|border-color|, while in JavaScript, capital letters are used to mark
the different words, as in |borderColor|.

A very practical kind of style is |display: none|. This can be used to
temporarily hide a node: When _|style.display|_ is |"none"|, the element
does not appear at all to the viewer of the document, even though it
does exist. Later, |display| can be set to the empty string, and the
element will re-appear.

> $("picture").style.display = "none";

And, to get our picture back:

> $("picture").style.display = "";

---

Another set of style types that can be abused in interesting ways are
those related to positioning. In a simple HTML document, the browser
takes care of determining the screen positions of all the elements --
each element is put next to or below the elements that come before it,
and nodes (generally) do not overlap.

@_|style.position|_When its |position| style is set to |"absolute"|, a
node is taken out of the normal document 'flow'. It no longer takes up
room in the document, but sort of floats above it. The |left| and
|top| styles can then be used to influence its position. This can be
used for various purposes, from making a node obnoxiously follow the
mouse cursor to making 'windows' open on top of the rest of the
document.

> $("picture").style.position = "absolute";
> var angle = 0;
> var spin = setInterval(function() {
>   angle += 0.1;
>   $("picture").style.left = (100 + 100 * Math.cos(angle)) + "px";
>   $("picture").style.top = (100 + 100 * Math.sin(angle)) + "px";
> }, 100);

If you aren't familiar with goniometry, just believe me when I tell
you that the cosine and sine stuff is used to build coordinates lying
on the outline of a circle. Ten times per second, the angle at which
we place the picture is changed, and new coordinates are computed. It
is a common error, when setting styles like this, to forget to append
|"px"| to your value. In most cases, setting a style to a number
without a unit does not work, so you must add |"px"| for pixels, |"%"|
for percent, |"em"| for 'ems' (the width of an |M| character), or
|"pt"| for points.

(Now put the image to rest again...)

> clearInterval(spin);

The place that is treated as 0,0 for the purpose of these positions
depends on the place of the node in the document. When it is placed
inside another node that has |position: absolute| or |position:
relative|, the top left of this node is used. Otherwise, you get the
top left corner of the document.

---

@_|style.width|_@_|style.height|_One last aspect of DOM nodes that is
fun to play with is their size. There are style types called |width|
and |height|, which can be used to set the absolute size of an
element.

> $("picture").style.width = "400px";
> $("picture").style.height = "200px";

But, when you need to accurately set the size of an element, there is
an tricky problem to take into account. Some browsers, in some
circumstances, take these sizes to mean the outside size of the
object, including any border and internal padding. Other browsers, in
other circumstances, use the size of the space inside of the object
instead, and do not count the width of borders and padding. Thus, if
you set the size of an object that has a border or a padding, it will
not always appear the same size.

Fortunately, you can inspect the inner and outer size of a node,
which, when you really need to accurately size something, can be used
to compensate for browser behaviour. The _|offsetWidth|_ and
_|offsetHeight|_ properties give you the outer size of your element
(the space it takes up in the document), while the _|clientWidth|_ and
_|clientHeight|_ properties give the space inside of it, if any.

> print("Outer size: ", $("picture").offsetWidth,
>       " by ", $("picture").offsetHeight, " pixels.");
> print("Inner size: ", $("picture").clientWidth,
>       " by ", $("picture").clientHeight, " pixels.");

---

If you've followed through with all the examples in this chapter, and
maybe did a few extra things by yourself, you will have completely
mutilated the poor little document that we started with. Now let me
moralise for a moment and tell you that you do not want to do this to
real pages. The temptation to add all kinds of moving bling-bling will
at times be strong. Resist it, or your pages shall surely become
unreadable or even, if you go far enough, induce the occasional
seizure.

======================
Browser Events / event
======================

To add interesting functionality to a web-page, just being able to
inspect or modify the document is generally not enough. We also need
to be able to detect what the user is doing, and respond to it. For
this, we will use a thing called _event handler_s. Pressed keys are
events, mouse clicks are events, even mouse motion can be seen as a
series of events. In \\cweb, we added an |onclick| property to a
button, in order to do something when it was pressed. This is a simple
event handler.

The way browser events work is, fundamentally, very simple. It is
possible to register handlers for specific event types and specific
DOM nodes. Whenever an _event_ occurs, the handler for that event, if
any, is called. For some events, such as key presses, knowing just
that the event occurred is not good enough, you also want to know
which key was pressed. To store such information, every event creates
an _event object_, which the handler can look at.

It is important to realise that, even though events can fire at any
time, no two handlers ever run at the same moment. If other JavaScript
code is still running, the browser waits until it finishes before it
calls the next handler. This also holds for code that is triggered in
other ways, such as with |setTimeout|. In programmer jargon, browser
JavaScript is _single-threaded_, there are never two '_thread_s'
running at the same time. This is, in most cases, a good thing. It is
very easy to get strange results when multiple things happen at the
same time.

An event, when not handled, can 'bubble' through the DOM tree. What
this means is that if you click on, for example, a link in a
paragraph, any handlers associated with the link are called first. If
there are no such handlers, or these handlers do not indicate that
they have finished handling the event, the handlers for the paragraph,
which is the parent of the link, are tried. After that, the handlers
for |document.body| get a turn. Finally, if no JavaScript handlers
have taken care of the event, the browser handles it. When clicking a
link, this means that the link will be followed.

---

So, as you see, events are easy. The only hard thing about them is
that browsers, while all supporting more or less the same
functionality, support this functionality through different
interfaces. As usual, the most incompatible browser is Internet
Explorer, which ignores the standard that most other browsers follow.
After that, there is Opera, which does not properly support some
useful events, such as the |onunload| event which fires when leaving a
page, and sometimes gives confusing information about keyboard events.

There are four event-related actions one might want to take.

 * Registering an event handler.
 * Getting the event object.
 * Extracting information from this object.
 * Signalling that an event has been handled.

None of them work the same across all major browsers.

---

As a practice field for our event-handling, we open a document with a
button and a text field. Keep this window open (and attached) for the
rest of the chapter.

> attach(window.open("example_events.html"));

---

The first action, registering a handler, can be done by setting an
element's |onclick| (or |onkeypress|, and so on) property. This does
in fact work across browsers, but it has an important drawback -- you
can only attach one handler to an element. Most of the time, one is
enough, but there are cases, especially when a program has to be able
to work together with other programs (which might also be adding
handlers), that this is annoying.

@_|attachEvent|_In Internet Explorer, one can add a click handler to a
button like this:

!> $("button").attachEvent("onclick", function(){print("Click!");});

@_|addEventListener|_On the other browsers, it goes like this:

!> $("button").addEventListener("click", function(){print("Click!");},
!>                              false);

Note how |"on"| is left off in the second case. The third argument
to |addEventListener|, |false|, indicates that the event should
'bubble' through the DOM tree as normal. Giving |true| instead can be
used to give this handler priority over the handlers 'beneath' it, but
since Internet Explorer does not support such a thing, this is rarely
useful.

***

Write a function called |registerEventHandler| to wrap the
incompatibilities of these two models. It takes three arguments: first
a DOM node that the handler should be attached to, then the name of
the event type, such as |"click"| or |"keypress"|, and finally the
handler function.

To determine which method should be called, look for the methods
themselves -- if the DOM node has a method called |attachEvent|, you
may assume that this is the correct method. Note that this is much
preferable to directly checking whether the browser is Internet
Explorer. If a new browser arrives which uses Internet Explorer's
model, or Internet Explorer suddenly switches to the standard model,
the code will still work. Both are rather unlikely, of course, but
doing something in a smart way never hurts.

///

> function registerEventHandler(node, event, handler) {
>   if (typeof node.addEventListener == "function")
>     node.addEventListener(event, handler, false);
>   else
>     node.attachEvent("on" + event, handler);
> }
>
> registerEventHandler($("button"), "click",
>                      function(){print("Click (2)");});

Don't fret about the long, clumsy name. Later on, we will have to add
an extra wrapper to wrap this wrapper, and it will have a shorter
name.

It is also possible to do this check only once, and define
|registerEventHandler| to hold a different function depending on the
browser. This is more efficient, but a little strange.

> if (typeof document.addEventListener == "function")
>   var registerEventHandler = function(node, event, handler) {
>     node.addEventListener(event, handler, false);
>   };
> else
>   var registerEventHandler = function(node, event, handler) {
>     node.attachEvent("on" + event, handler);
>   };

---

Removing events works very much like adding them, but this time the
methods _|detachEvent|_ and _|removeEventListener|_ are used. Note
that, to remove a handler, you need to have access to the function you
attached to it.

> function unregisterEventHandler(node, event, handler) {
>   if (typeof node.removeEventListener == "function")
>     node.removeEventListener(event, handler, false);
>   else
>     node.detachEvent("on" + event, handler);
> }

---

Exceptions produced by event handlers can, because of technical
limitations, not be caught by the console. Thus, they are handled by
the browser, which might mean they get hidden in some kind of 'error
console' somewhere, or cause a message to pop up. When you write an
event handler and it does not seem to work, it might be silently
aborting because it causes some kind of error.

---

@_|event|_Most browsers pass the _event object_ as an argument to the
handler. Internet Explorer stores it in the top-level variable called
|event|. When looking at JavaScript code, you will often come across
something like |event || window.event|, which takes the local variable
|event| or, if that is undefined, the top-level variable by that same
name.

> function showEvent(event) {
>   show(event || window.event);
> }
>
> registerEventHandler($("textfield"), "keypress", showEvent);

Type a few characters in the field, look at the objects, and shut it
up again:

> unregisterEventHandler($("textfield"), "keypress", showEvent);

---

@_|onmousedown|_@_|onmouseup|_@_|onclick|_@_|ondblclick|_When the user
clicks his mouse, three events are generated. First _|mousedown|_, at
the moment the mouse button is pressed. Then, _|mouseup|_, at the
moment it is released. And finally, _|click|_, to indicate something
was clicked. When this happens two times in quick succession, a
_|dblclick|_ (double-click) event is also generated. Note that it is
possible for the |mousedown| and |mouseup| events to happen some time
apart -- when the mouse button is held for a while.

When you attach an event handler to, for example, a button, the fact
that it has been clicked is often all you need to know. When the
handler, on the other hand, is attached to a node that has children,
clicks from the children will 'bubble' up to it, and you will want to
find out which child has been clicked. For this purpose, event objects
have a property called _|target|_... or |srcElement|, depending on the
browser.

@_|scrollTop|_@_|scrollLeft|_Another interesting piece of information
are the precise coordinates at which the click occurred. Event objects
related to the mouse contain _|clientX|_ and _|clientY|_ properties,
which give the |x| and |y| coordinates of the mouse, in pixels, on the
screen. Documents can scroll, though, so often these coordinates do
not tell us much about the part of the document that the mouse is
over. Some browsers provide _|pageX|_ and _|pageY|_ properties for
this purpose, but others (guess which) do not. Fortunately, the
information about the amount of pixels the document has been scrolled
can be found in |document.body.scrollLeft| and
|document.body.scrollTop|.

This handler, attached to the whole document, intercepts all mouse
clicks, and prints some information about them.

> function reportClick(event) {
>   event = event || window.event;
>   var target = event.target || event.srcElement;
>   var pageX = event.pageX, pageY = event.pageY;
>   if (pageX == undefined) {
>     pageX = event.clientX + document.body.scrollLeft;
>     pageY = event.clientY + document.body.scrollTop;
>   }
>
>   print("Mouse clicked at ", pageX, ", ", pageY,
>         ". Inside element:");
>   show(target);
> }
> registerEventHandler(document, "click", reportClick);

And get rid of it again:

> unregisterEventHandler(document, "click", reportClick);

Obviously, writing all these checks and workarounds is not something
you want to do in every single event handler. In a moment, after we
have gotten acquainted with a few more incompatibilities, we will
write a function to 'normalise' event objects to work the same across
browsers.

It is also sometimes possible to find out which mouse button was
pressed, using the _|which|_ and _|button|_ properties of event
objects. Unfortunately, this is very unreliable -- some browsers
pretend mouses have only one button, others report right-clicks as
clicks during which the control key was held down, and so on.

---

@_|onmousemove|_@_|onmouseover|_@_|onmouseout|_Apart from clicks, we
might also be interested in the movement of the mouse. The
_|mousemove|_ event of a DOM node is fired whenever the mouse moves
while it is over that element. There are also _|mouseover|_ and
_|mouseout|_, which are fired only when the mouse enters or leaves a
node. For events of this last type, the |target| (or |srcElement|)
property points at the node that the event is fired for, while the
_|relatedTarget|_ (or |toElement|, or |fromElement|) property gives
the node that the mouse came from (for |mouseover|) or left to (for
|mouseout|).

|mouseover| and |mouseout| can be tricky when they are registered on
an element that has child nodes. Events fired for the child nodes will
bubble up to the parent element, so you will also see a |mouseover|
event when the mouse enters one of the child nodes. The |target| and
|relatedTarget| properties can be used to detect (and ignore) such
events.

---

@_|onkeydown|_@_|onkeyup|_@_|onkeypress|_For every key that the user
presses, three events are generated: _|keydown|_, _|keyup|_, and
_|keypress|_. In general, you should use the first two in cases where
you really want to know which key was pressed, for example when you
want to do something when the arrow keys are pressed. |keypress|, on
the other hand, is to be used when you are interested in the character
that is being typed. The reason for this is that there is often no
character information in |keyup| and |keydown| events, and Internet
Explorer does not generate a |keypress| event at all for special keys
such as the arrow keys.

Finding out which key was pressed can be quite a challenge by itself.
For |keydown| and |keyup| events, the event object will have a
_|keyCode|_ property, which contains a number. Most of the time, these
codes can be used to identify keys in a reasonably browser-independant
way. Finding out which code corresponds to which key can be done by
simple experiments...

> function printKeyCode(event) {
>   event = event || window.event;
>   print("Key ", event.keyCode, " was pressed.");
> }
>
> registerEventHandler($("textfield"), "keydown", printKeyCode);

> unregisterEventHandler($("textfield"), "keydown", printKeyCode);

In most browsers, a single key code corresponds to a single *physical*
key on your keyboard. The Opera browser, however, will generate
different key codes for some keys depending on whether shift is
pressed or not. Even worse, some of these shift-is-pressed codes are
the same codes that are also used for other keys -- shift-9, which on
most keyboards is used to type a parenthesis, gets the same code as
the down arrow, and as such is hard to distinguish from it. When this
threatens to sabotage your programs, you can usually resolve it by
ignoring key events that have shift pressed.

To find out whether the shift, control, or alt key was held during a
key or mouse event, you can look at the _|shiftKey|_, _|ctrlKey|_, and
_|altKey|_ properties of the event object.

For |keypress| events, you will want to know which character was
typed. The event object will have a _|charCode|_ property, which, if
you are lucky, contains the _Unicode_ number corresponding to the
character that was typed, which can be converted to a 1-character
string by using _|String.fromCharCode|_. Unfortunately, some browsers
do not define this property, or define it as |0|, and store the
character code in the _|keyCode|_ property instead.

> function printCharacter(event) {
>   event = event || window.event;
>   var charCode = event.charCode;
>   if (charCode == undefined || charCode === 0)
>     charCode = event.keyCode;
>   print("Character '", String.fromCharCode(charCode), "'");
> }
>
> registerEventHandler($("textfield"), "keypress", printCharacter);

> unregisterEventHandler($("textfield"), "keypress", printCharacter);

---

An event handler can 'stop' the event it is handling. There are two
different ways to do this. You can prevent the event from bubbling up
to parent nodes and the handlers defined on those, and you can prevent
the browser from taking the standard action associated with such an
event. It should be noted that browsers do not always follow this --
preventing the default behaviour for the pressing of certain 'hotkeys'
will, on many browsers, not actually keep the browser from executing
the normal effect of these keys.

On most browsers, stopping event bubbling is done with the
_|stopPropagation|_ method of the event object, and preventing default
behaviour is done with the _|preventDefault|_ method. For Internet
Explorer, this is done by setting the _|cancelBubble|_ property of
this object to |true|, and the _|returnValue|_ property to |false|,
respectively.

And that was the last of the long list of incompatibilities that we
will discuss in this chapter. Which means that we can finally write
the event normaliser function and move on to more interesting things.

> function normaliseEvent(event) {
>   if (!event.stopPropagation) {
>     event.stopPropagation = function() {this.cancelBubble = true;};
>     event.preventDefault = function() {this.returnValue = false;};
>   }
>   if (!event.stop) {
>     event.stop = function() {
>       this.stopPropagation();
>       this.preventDefault();
>     };
>   }
>
>   if (event.srcElement && !event.target)
>     event.target = event.srcElement;
>   if ((event.toElement || event.fromElement) && !event.relatedTarget)
>     event.relatedTarget = event.toElement || event.fromElement;
>   if (event.clientX != undefined && event.pageX == undefined) {
>     event.pageX = event.clientX + document.body.scrollLeft;
>     event.pageY = event.clientY + document.body.scrollTop;
>   }
>   if (event.type == "keypress") {
>     if (event.charCode === 0 || event.charCode == undefined)
>       event.character = String.fromCharCode(event.keyCode);
>     else
>       event.character = String.fromCharCode(event.charCode);
>   }
>
>   return event;
> }

A _|stop|_ method is added, which cancels both the bubbling and
the default action of the event. Some browsers already provide this,
in which case we leave it as it is.

Next we can write convenient wrappers for |registerEventHandler| and
|unregisterEventHandler|:

> function addHandler(node, type, handler) {
>   function wrapHandler(event) {
>     handler(normaliseEvent(event || window.event));
>   }
>   registerEventHandler(node, type, wrapHandler);
>   return {node: node, type: type, handler: wrapHandler};
> }
>
> function removeHandler(object) {
>   unregisterEventHandler(object.node, object.type, object.handler);
> }
>
> var blockQ = addHandler($("textfield"), "keypress", function(event) {
>   if (event.character.toLowerCase() == "q")
>     event.stop();
> });

The new |addHandler| function wraps the handler function it is given
in a new function, so it can take care of normalising the event
objects. It returns an object that can be given to |removeHandler|
when we want to remove this specific handler. Try typing a '|q|' in
the text field.

> removeHandler(blockQ);

---

Armed with |addHandler| and the |dom| function from the last chapter,
we are ready for more challenging feats of document-manipulation. As
an exercise, we will implement the game known as _Sokoban_. This is
something of a classic, but you may not have seen it before. The rules
are this: There is a grid, made up of walls, empty space, and one or
more 'exits'. On this grid, there are a number of crates or stones,
and a little dude that the player controls. This dude can be moved
horizontally and vertically into empty squares, and can push the
boulders around, provided that there is empty space behind them. The
goal of the game is to move a given number of boulders into the exits.

Just like the terraria from \\coo, a Sokoban level can be represented
as text. The variable |sokobanLevels|, in the |example_events.html|
window, contains an array of level objects. Each level has a property
|field|, containing a textual representation of the level, and a
property |boulders|, indicating the amount of boulders that must be
expelled to finish the level.

> show(sokobanLevels.length);
> show(sokobanLevels[1].boulders);
> forEach(sokobanLevels[1].field, print);

In such a level, the |#| characters are walls, spaces are empty
squares, |0| characters are used for for boulders, an |@| for the
starting location of the player, and a |*| for the exit.

---

But, when playing the game, we do not want to be looking at this
textual representation. Instead, we will put a _table_ into the
document. I made small _style-sheet_ ([sokoban.css | css/sokoban.css],
if you are curious what it looks like) to give the cells of this table
a fixed square size, and added it to the example document. Each of the
cells in this table will get a background image, representing the type
of the square (empty, wall, or exit). To show the location of the
player and the boulders, images are added to these table cells, and
moved to different cells as appropriate.

It would be possible to use this table as the main representation of
our data -- when we want to look whether there is a wall in a given
square, we just inspect the background of the appropriate table cell,
and to find the player, we just search for the image node with the
correct |src| property. In some cases, this approach is practical, but
for this program I chose to keep a separate data structure for the
grid, because it makes things much more straightforward.

This data structure is a two-dimensional grid of objects, representing
the squares of the playing field. Each of the objects must store the
type of background it has and whether there is a boulder or player
present in that cell. It should also contain a reference to the table
cell that is used to display it in the document, to make it easy to
move images in and out of this table cell.

That gives us two kinds of objects -- one to hold the grid of the
playing field, and one to represent the individual cells in this grid.
If we want the game to also do things like moving the next level at
the appropriate moment, and being able to reset the current level when
you mess up, we will also need a 'controller' object, which creates or
removes the field objects at the appropriate moment. For convenience,
we will be using the prototype approach outlined at the end of \\coo,
so object types are just prototypes, and the |create| method, rather
than the |new| operator, is used to make new objects.

---

Let us start with the objects representing the squares of the game's
field. They are responsible for setting the background of their cells
correctly, and adding images as appropriate. The |img/sokoban/|
directory contains a set of images, based on another ancient game,
which will be used to visualise the game. For a start, the |Square|
prototype could look like this.

> var Square = {
>   construct: function(character, tableCell) {
>     this.background = "empty";
>     if (character == "#")
>       this.background = "wall";
>     else if (character == "*")
>       this.background = "exit";
> 
>     this.tableCell = tableCell;
>     this.tableCell.className = this.background;
> 
>     this.content = null;
>     if (character == "0")
>       this.content = "boulder";
>     else if (character == "@")
>       this.content = "player";
>
>     if (this.content != null) {
>       var image = dom("IMG", {src: "img/sokoban/" +
>                                    this.content + ".gif"});
>       this.tableCell.appendChild(image);
>     }
>   },
> 
>   hasPlayer: function() {
>     return this.content == "player";
>   },
>   hasBoulder: function() {
>     return this.content == "boulder";
>   },
>   isEmpty: function() {
>     return this.content == null && this.background == "empty";
>   },
>   isExit: function() {
>     return this.background == "exit";
>   }
> };
>
> var testSquare = Square.create("@", dom("TD"));
> show(testSquare.hasPlayer());

The |character| argument to the constructor will be used to transform
characters from the level blueprints into actual |Square| objects. To
set the background of the cells, style-sheet classes are used (defined
in [sokoban.css | css/sokoban.css]), which are assigned to the |td|
elements' |className| property.

The methods like |hasPlayer| and |isEmpty| are a way to 'isolate' the
code that uses objects of this type from the internals of the objects.
They are not strictly necessary in this case, but they will make the
other code look better.

***

Add methods |moveContent| and |clearContent| to the |Square|
prototype. The first one takes another |Square| object as an argument,
and moves the content of the |this| square into the argument by
updating the |content| properties and moving the image node associated
with this content. This will be used to move boulders and players
around the grid. It may assume the square is not currently empty.
|clearContent| removes the content from the square without moving it
anywhere. Note that the |content| property for empty squares contains
|null|.

The |removeElement| function we defined in \\cdom is available in this
chapter too, for your node-removing convenience. You may assume that
the images are the only child nodes of the table cells, and can thus
be reached through, for example, |this.tableCell.lastChild|.

///

> Square.moveContent = function(target) {
>   target.content = this.content;
>   this.content = null;
>   target.tableCell.appendChild(this.tableCell.lastChild);
> };
> Square.clearContent = function() {
>   this.content = null;
>   removeElement(this.tableCell.lastChild);
> };

---

The next object type will be called |SokobanField|. Its constructor is
given an object from the |sokobanLevels| array, and is responsible for
building both a table of DOM nodes and a grid of |Square| objects.
This object will also take care of the details of moving the player
and boulders around, through a |move| method that is given an argument
indicating which way the player wants to move.

To identify the individual squares, and to indicate directions, we
will again use the |Point| object type from \\coo, which, as you might
remember, has an |add| method.

The base of the field prototype looks like this:

> var SokobanField = {
>   construct: function(level) {
>     var tbody = dom("TBODY");
>     this.squares = [];
>     this.bouldersToGo = level.boulders;
> 
>     for (var y = 0; y < level.field.length; y++) {
>       var line = level.field[y];
>       var tableRow = dom("TR");
>       var squareRow = [];
>       for (var x = 0; x < line.length; x++) {
>         var tableCell = dom("TD");
>         tableRow.appendChild(tableCell);
>         var square = Square.create(line.charAt(x), tableCell);
>         squareRow.push(square);
>         if (square.hasPlayer())
>           this.playerPos = new Point(x, y);
>       }
>       tbody.appendChild(tableRow);
>       this.squares.push(squareRow);
>     }
> 
>     this.table = dom("TABLE", {"class": "sokoban"}, tbody);
>     this.score = dom("DIV", null, "...");
>     this.updateScore();
>   },
> 
>   getSquare: function(position) {
>     return this.squares[position.y][position.x];
>   },
>   updateScore: function() {
>     this.score.firstChild.nodeValue = this.bouldersToGo + 
>                                       " boulders to go.";
>   },
>   won: function() {
>     return this.bouldersToGo <= 0;
>   }
> };
>
> var testField = SokobanField.create(sokobanLevels[0]);
> show(testField.getSquare(new Point(10, 2)).content);

The constructor goes over the lines and characters in the level, and
stores the |Square| objects in the |squares| property. When it
encounters the square with the player, it saves this position as
|playerPos|, so that we can easily find the square with the player
later on. |getSquare| is used to find a |Square| object corresponding
to a certain |x,y| position on the field. Note that it doesn't take
the edges of the field into account -- to avoid writing some boring
code, we assume that the field is properly walled off, making it
impossible to walk out of it.

The word |"class"| in the |dom| call that makes the |table| node is
quoted as a string. This is necessary because _|class|_ is a 'reserved
word' in JavaScript, and may not be used as a variable or property
name.

The amount of boulders that have to be cleared to win the level (this
may be less than the total amount of boulders on the level) is stored
in |bouldersToGo|. Whenever a boulder is brought to the exit, we can
subtract 1 from this, and see whether the game is won yet. To show the
player how he is doing, we will have to show this amount somehow. For
this purpose, a |div| element with text is used. |div| nodes are
containers without inherent markup. The score text can be updated with
the |updateScore| method. The |won| method will be used by the
controller object to determine when the game is over, so the player
can move on to the next level.

---

If we want to actually see the playing field and the score, we will
have to insert them into the document somehow. That is what the
|place| method is for. We'll also add a |remove| method to make it
easy to remove a field when we are done with it.

> SokobanField.place = function(where) {
>   where.appendChild(this.score);
>   where.appendChild(this.table);
> };
> SokobanField.remove = function() {
>   removeElement(this.score);
>   removeElement(this.table);
> };
>
> testField.place(document.body);

If all went well, you should see a Sokoban field now.

***

But this field doesn't do very much yet. Add a method called |move|.
It takes a |Point| object specifying the move as argument (for example
|-1,0| to move left), and takes care of moving the game elements in
the correct way.

The correct way is this: The |playerPos| property can be used to
determine where the player is trying to move. If there is a boulder
here, look at the square behind this boulder. When there is an exit
there, remove the boulder and update the score. When there is empty
space there, move the boulder into it. Next, try to move the player.
If the square he is trying to move into is not empty, ignore the move.

///

> SokobanField.move = function(direction) {
>   var playerSquare = this.getSquare(this.playerPos);
>   var targetPos = this.playerPos.add(direction);
>   var targetSquare = this.getSquare(targetPos);
>
>   // Possibly pushing a boulder
>   if (targetSquare.hasBoulder()) {
>     var pushTarget = this.getSquare(targetPos.add(direction));
>     if (pushTarget.isEmpty()) {
>       targetSquare.moveContent(pushTarget);
>     }
>     else if (pushTarget.isExit()) {
>       targetSquare.moveContent(pushTarget);
>       pushTarget.clearContent();
>       this.bouldersToGo--;
>       this.updateScore();
>     }
>   }
>   // Moving the player
>   if (targetSquare.isEmpty()) {
>     playerSquare.moveContent(targetSquare);
>     this.playerPos = targetPos;
>   }
> };

By taking care of boulders first, the move code can work the same way
when the player is moving normally and when he is pushing a boulder.
Note how the square behind the boulder is found by adding the
|direction| to the |playerPos| twice. Test it by moving left two
squares:

> testField.move(new Point(-1, 0));
> testField.move(new Point(-1, 0));

If that worked, we moved a boulder into a place from which we can't
get it out anymore, so we'd better throw this field away.

> testField.remove();

---

All the 'game logic' has been taken care of now, and we just need a
controller to make it playable. The controller will be an object type
called |SokobanGame|, which is responsible for the following things:

 * Preparing a place where the game field can be placed.
 * Building and removing |SokobanField| objects.
 * Capturing key events and calling the |move| method on current field with the correct argument.
 * Keeping track of the current level number and moving to the next level when a level is won.
 * Adding buttons to reset the current level or the whole game (back to level 0).

We start again with an unfinished prototype.

> var SokobanGame = {
>   construct: function(place) {
>     this.level = null;
>     this.field = null;
> 
>     var newGame = dom("BUTTON", null, "New game");
>     addHandler(newGame, "click", method(this, "newGame"));
>     var reset = dom("BUTTON", null, "Reset level");
>     addHandler(reset, "click", method(this, "reset"));
>     this.container = dom("DIV", null,
>                          dom("H1", null, "Sokoban"),
>                          dom("DIV", null, newGame, " ", reset));
>     place.appendChild(this.container);
> 
>     addHandler(document, "keydown", method(this, "keyDown"));
>     this.newGame();
>   },
> 
>   newGame: function() {
>     this.level = 0;
>     this.reset();
>   },
>   reset: function() {
>     if (this.field)
>       this.field.remove();
>     this.field = SokobanField.create(sokobanLevels[this.level]);
>     this.field.place(this.container);
>   },
>
>   keyDown: function(event) {
>     // To be filled in
>   }
> };

The constructor builds a |div| element to hold the field, along with
two buttons and a title. Note how |method| is used to attach methods
on the |this| object to events.

We can put a Sokoban game into our document like this:

> var sokoban = SokobanGame.create(document.body);

***

All that is left to do now is filling in the key event handler.
Replace the |keyDown| method of the prototype with one that detects
presses of the arrow keys and, when it finds them, moves the player in
the correct direction. The following |Dictionary| will probably come
in handy:

> var arrowKeyCodes = new Dictionary({
>   37: new Point(-1, 0), // left
>   38: new Point(0, -1), // up
>   39: new Point(1, 0),  // right
>   40: new Point(0, 1)   // down
> });

After an arrow key has been handled, check |this.field.won()| to find
out if that was the winning move. If the player won, use |alert| to
show a message, and go to the next level. If there is no next level
(check |sokobanLevels.length|), restart the game instead.

It is probably wise to stop the events for key presses after handling
them, otherwise pressing arrow-up and arrow-down will scroll your
window, which is rather annoying.

///

> SokobanGame.keyDown = function(event) {
>   if (arrowKeyCodes.contains(event.keyCode)) {
>     event.stop();
>     this.field.move(arrowKeyCodes.lookup(event.keyCode));
>     if (this.field.won()) {
>       if (this.level < sokobanLevels.length - 1) {
>         alert("Excellent! Going to the next level.");
>         this.level++;
>         this.reset();
>       }
>       else {
>         alert("You win! Game over.");
>         this.newGame();
>       }
>     }
>   }
> };

It has to be noted that capturing keys like this -- adding a handler
to the |document| and stopping the events that you are looking for --
is not very nice when there are other elements in the document. For
example, try moving the cursor around in the text field at the top of
the document. -- It won't work, you'll only move the little man in the
Sokoban game. If a game like this were to be used in a real site, it
is probably best to put it in a frame or window of its own, so that it
only grabs events aimed at its own window.

***

When brought to the exit, the boulders vanish rather abrubtly. By
modifying the |Square.clearContent| method, try to show a 'falling'
animation for boulders that are about to be removed. Make them grow
smaller for a moment before, and then disappear. You can use
|style.width = "50%"|, and similarly for |style.height|, to make an
image appear, for example, half as big as it usually is.

///

We can use |setInterval| to handle the timing of the animation. Note
that the method makes sure to clear the interval after it is done. If
you don't do that, it will continue wasting your computer's time until
the page is closed.

> Square.clearContent = function() {
>   self.content = null;
>   var image = this.tableCell.lastChild;
>   var size = 100;
>
>   var animate = setInterval(function() {
>     size -= 10;
>     image.style.width = size + "%";
>     image.style.height = size + "%";
>
>     if (size < 60) {
>       clearInterval(animate);
>       removeElement(image);
>     }
>   }, 70);
> };

Now, if you have a few hours to waste, try finishing all levels.

---

@_|onfocus|_@_|onblur|_Other event types that can be useful are
_|focus|_ and _|blur|_, which are fired on elements that can be
'focused', such as form inputs. |focus|, obviously, happens when you
put the focus on the element, for example by clicking on it. |blur| is
JavaScript-speak for 'unfocus', and is fired when the focus leaves the
element.

> addHandler($("textfield"), "focus", function(event) {
>   event.target.style.backgroundColor = "yellow";
> });
> addHandler($("textfield"), "blur", function(event) {
>   event.target.style.backgroundColor = "";
> });

@_|onchange|_Another event related to form inputs is _|change|_. This
is fired when the content of the input has changed... except that for
some inputs, such as text inputs, it does not fire until the element
is unfocused.

> addHandler($("textfield"), "change", function(event) {
>   print("Content of text field changed to '",
>         event.target.value, "'.");
> });

You can type all you want, the event will only fire when you click
outside of the input, press tab, or unfocus it in some other way.

@_|submit|_Forms also have a _|submit|_ event, which is fired when
they submit. It can be stopped to prevent the submit from taking
place. This gives us a *much* better way to do the form validation we
saw in the previous chapter. You just register a |submit| handler,
which stops the event when the content of the form is not valid. That
way, when the user does not have JavaScript enabled, the form will
still work, it just won't have instant validation.

@_|onload|_@_|unload|_Window objects have a _|load|_ event that fires
when the document is fully loaded, which can be useful if your script
needs to do some kind of initialisation that has to wait until the
whole document is present. For example, the scripts on the pages for
this book go over the current chapter to hide solutions to exercises.
You can't do that when the exercises are not loaded yet. There is also
an _|unload|_ event, firing when the user leaves the document, but
this is not properly supported by all browsers.

@_|onresize|_Most of the time it is best to leave the laying out of a
document to the browser, but there are effects that can only be
produced by having a piece of JavaScript set the exact sizes of some
nodes in a document. When you do this, make sure you also listen for
_|resize|_ events on the window, and re-calculate the sizes of your
element every time the window is resized.

---

Finally, I have to tell you something about event handlers that you
would rather not know. The Internet Explorer browser (which means, at
the time of writing, the browser used by a majority of web-surfers)
has a bug that causes values to not be cleaned up as normal: Even when
they are no longer used, they stay in the machine's memory. This is
known as a _memory leak_, and, once enough memory has been leaked,
will seriously slow down a computer.

When does this leaking occur? Due to a deficiency in Internet
Explorer's _garbage collector_, the system whose purpose it is to
reclaim unused values, when you have a DOM node that, through one of
its properties or in a more indirect way, refers to a normal
JavaScript object, and this object, in turn, refers back to that DOM
node, both objects will not be collected. This has something to do
with the fact that DOM nodes and other JavaScript objects are
collected by different systems -- the system that cleans up DOM nodes
will take care to leave any nodes that are still referenced by
JavaScript objects, and vice versa for the system that collects normal
JavaScript values.

As the above description shows, the problem is not specifically
related to event handlers. This code, for example, creates a bit of
un-collectable memory:

!> var jsObject = {link: document.body};
!> document.body.linkBack = jsObject;

Even after such an Internet Explorer browser goes to a different page,
it will still hold on to the |document.body| shown here. The reason
this bug is often associated with event handlers is that it is
extremely easy to make such circular links when registering a handler.
The DOM node keeps references to its handlers, and the handler, most
of the time, has a reference to the DOM node. Even when this reference
is not intentionally made, JavaScript's scoping rules tend to add it
implicitly. Consider this function:

!> function addAlerter(element) {
!>   addHandler(element, "click", function() {
!>     alert("Alert! ALERT!");
!>   });
!> }

The anonymous function that is created by the |addAlerter| function
can 'see' the |element| variable. It doesn't use it, but that does not
matter -- just because it can see it, it will have a reference to it.
By registering this function as an event handler on that same
|element| object, we have created a circle.

There are three ways to deal with this problem. The first approach, a
very popular one, is to ignore it. Most scripts will only leak a
little bit, so it takes a long time and a lot of pages before the
problems become noticeable. And, when the problems are so subtle,
who's going to hold *you* responsible? Programmers given to this
approach will often searingly denounce Microsoft for their shoddy
programming, and state that the problem is not their fault, so *they*
shouldn't be fixing it.

Such reasoning is not entirely without merit, of course. But when half
your users are having problems with the web-pages you make, it is hard
to deny that there is a practical problem. Which is why people working
on 'serious' sites usually make an attempt not to leak any memory.
Which brings us to the second approach: Painstakingly making sure that
no circular references between DOM objects and regular objects are
created. This means, for example, rewriting the above handler like
this:

> function addAlerter(element) {
>   addHandler(element, "click", function() {
>     alert("Alert! ALERT!");
>   });
>   element = null;
> }

Now the |element| variable no longer points at the DOM node, and the
handler will not leak. This approach is viable, but requires the
programmer to *really* pay attention.

The third solution, finally, is to not worry too much about creating
leaky structures, but to make sure to clean them up when you are done
with them. This means unregistering any event handlers when they are
no longer needed, and registering an |onunload| event to unregister
the handlers that are needed until the page is unloaded. It is
possible to extend an event-registering system, like our |addHandler|
function, to automatically do this. When taking this approach, you
must keep in mind that event handlers are not the only possible source
of memory leaks -- adding properties to DOM node objects can cause
similar problems.

===================
HTTP requests / xhr
===================

As mentioned in \\cweb, communication on the World Wide Web happens
over the _HTTP_ protocol. A simple @_HTTP request_request might look
like this:

] GET /files/fruit.txt HTTP/1.1
] Host: eloquentjavascript.net
] User-Agent: The Imaginary Browser

Which asks for the file |files/fruit.txt| from the server at
|eloquentjavascript.net|. In addition, it specifies that this request
uses version 1.1 of the HTTP protocol -- version 1.0 is also still in
use, and works slightly differently. The |Host| and |User-Agent| lines
follow a pattern: They start with a word that identifies the
information they contain, followed by a colon and the actual
information. These are called '_header_s'. The |User-Agent| header
tells the server which browser (or other kind of program) is being
used to make the request. Other kinds of headers are often sent along,
for example to state the types of documents that the client can
understand, or the language that it prefers.

When given the above request, the server might send the following
_response_:

] HTTP/1.1 200 OK
] Last-Modified: Mon, 23 Jul 2007 08:41:56 GMT
] Content-Length: 24
] Content-Type: text/plain
]
] apples, oranges, bananas

The first line indicates again the version of the HTTP protocol,
followed by the status of the request. In this case the status code is
|200|, meaning 'OK, nothing out of the ordinary happened, I am sending
you the file'. This is followed by a few headers, indicating (in this
case) the last time the file was modified, its length, and its type
(plain text). After the headers you get a blank line, followed by the
file itself.

Apart from requests starting with |GET|, which indicates the client
just wants to fetch a document, the word |POST| can also be used to
indicate some information will be sent along with the request, which
the server is expected to process in some way.##

## These are not the only types of requests. There is also |HEAD|, to
request just the headers for a document, not its content, |PUT|, to
add a document to a server, and |DELETE|, to delete a document. These
are not used by browsers, and often not supported by web-servers, but
-- if you add server-side programs to support them -- they can be
useful.

---

When you click a link, submit a form, or in some other way encourage
your browser to go to a new page, it will do an HTTP request and
immediately unload the old page to show the newly loaded document. In
typical situations, this is just what you want -- it is how the web
traditionally works. Sometimes, however, a JavaScript program wants to
communicate with the server without re-loading the page. The 'Load'
button in the console, for example, can load files without leaving the
page.

To be able to do things like that, the JavaScript program must make
the HTTP request itself. Contemporary browsers provide an interface
for this. As with opening new windows, this interface is subject to
some restrictions. To prevent a script from doing anything scary, it
is only allowed to make HTTP requests to the domain that the current
page came from.

---

@_|XMLHttpRequest|_An object used to make an HTTP request can, on most
browsers, be created by doing |new XMLHttpRequest()|. Older versions
of Internet Explorer, which originally invented these objects, require
you to do |new ActiveXObject("Msxml2.XMLHTTP")| or, on even older
versions, |new ActiveXObject("Microsoft.XMLHTTP")|. _|ActiveXObject|_
is Internet Explorer's interface to various kinds of browser add-ons.
We are already used to writing incompatibility-wrappers by now, so let
us do so again:

> function makeHttpObject() {
>   try {return new XMLHttpRequest();}
>   catch (error) {}
>   try {return new ActiveXObject("Msxml2.XMLHTTP");}
>   catch (error) {}
>   try {return new ActiveXObject("Microsoft.XMLHTTP");}
>   catch (error) {}
>
>   throw new Error("Could not create HTTP request object.");
> }
>
> show(typeof(makeHttpObject()));

The wrapper tries to create the object in all three ways, using |try|
and |catch| to detect which ones fail. If none of the ways work, which
might be the case on older browsers or browsers with strict security
settings, it raises and error.

Now why is this object called an *XML* HTTP request? This is a bit of
a misleading name. _XML_ is a way to store textual data. It uses tags
and attributes like HTML, but is more structured and flexible -- to
store your own kinds of data, you may define your own types of XML
tags. These HTTP request objects have some built-in functionality for
dealing with retrieved XML documents, which is why they have XML in
their name. They can also handle other types of documents, though, and
in my experience they are used just as often for non-XML requests.

---

Now that we have our HTTP object, we can use it to make a request
similar the example shown above.

> var request = makeHttpObject();
> request.open("GET", "files/fruit.txt", false);
> request.send(null);
> print(request.responseText);

The _|open|_ method is used to configure a request. In this case we
choose to make a |GET| request for our |fruit.txt| file. The _URL_
given here is relative, it does not contain the |http://| part or a
server name, which means it will look for the file on the server that
the current document came from. The third parameter, |false|, will be
discussed in a moment. After |open| has been called, the actual
request can be made with the _|send|_ method. When the request is a
|POST| request, the data to be sent to the server (as a string) can be
passed to this method. For |GET| requests, one should just pass
|null|.

After the request has been made, the _|responseText|_ property of the
request object contains the content of the retrieved document. The
headers that the server sent back can be inspected with the
_|getResponseHeader|_ and _|getAllResponseHeaders|_ functions. The
first looks up a specific header, the second gives us a string
containing all the headers. These can occasionally be useful to get
some extra information about the document.

> print(request.getAllResponseHeaders());
> show(request.getResponseHeader("Date"));

If, for some reason, you want to add headers to the request that is
sent to the server, you can do so with the _|setRequestHeader|_
method. This takes two strings as arguments, the name and the value of
the header.

The response code, which was |200| in the example, can be found under
the _|status|_ property. When something went wrong, this cryptic code
will indicate it. For example, |404| means the file you asked for did
not exist. The _|statusText|_ contains a slightly less cryptic
description of the status.

> show(request.status);
> show(request.statusText);

When you want to check whether a request succeeded, comparing the
|status| to |200| is usually enough. In theory, the server might in
some situations return the code |304| to indicate that the older
version of the document, which the browser has stored in its
'_cache_', is still up to date. But it seems that browsers shield you
from this by setting the |status| to |200| even when it is |304|.
Also, if you are doing a request over a non-HTTP protocol##, such as
FTP, the |status| will not be usable because the protocol does not
use HTTP status codes.

## Not only the 'XML' part of the |XMLHttpRequest| name is misleading
-- the object can also be used for request over protocols other than
HTTP, so |Request| is the only meaningful part we have left.

---

When a request is done as in the example above, the call to the |send|
method does not return until the request is finished. This is
convenient, because it means the |responseText| is available after the
call to |send|, and we can start using it immediately. There is a
problem, though. When the server is slow, or the file is big, doing a
request might take quite a while. As long as this is happening, the
program is waiting, which causes the whole browser to wait. Until the
program finishes, the user can not do anything, not even scroll the
page. Pages that run on a local network, which is fast and reliable,
might get away with doing requests like this. Pages on the big great
unreliable Internet, on the other hand, should not.

When the third argument to |open| is |true|, the request is set to be
'_asynchronous_'. This means that |send| will return right away, while
the request happens in the background.

> request.open("GET", "files/fruit.xml", true);
> request.send(null);
> show(request.responseText);

But wait a moment, and...

> print(request.responseText);

'Waiting a moment' could be implemented with |setTimeout| or something
like that, but there is a better way. A request object has a
_|readyState|_ property, indicating the state it is in. This will
become |4| when the document has been fully loaded, and have a smaller
value before that##. To react to changes in this status, you can set
the _|onreadystatechange|_ property of the object to a function. This
function will be called every time the state changes.

## |0| ('uninitialized') is the state of the object before |open| is
called on it. Calling |open| moves it to |1| ('open'). Calling |send|
makes it proceed to |2| ('sent'). When the server responds, it goes to
|3| ('receiving'). Finally, |4| means 'loaded'.

> request.open("GET", "files/fruit.xml", true);
> request.send(null);
> request.onreadystatechange = function() {
>   if (request.readyState == 4)
>     show(request.responseText.length);
> };

---

When the file retrieved by the request object is an XML document, the
request's _|responseXML|_ property will hold a representation of this
document. This representation works like the DOM objects discussed in
\\cdom, except that it doesn't have HTML-specific functionality, such
as |style| or |innerHTML|. |responseXML| gives us a document object,
whose |documentElement| property refers to the outer tag of the XML
document.

> var catalog = request.responseXML.documentElement;
> show(catalog.childNodes.length);

Such XML documents can be used to exchange structured information with
the server. Their form -- tags contained inside other tags -- is often
very suitable to store things that would be tricky to represent as
simple flat text. The DOM interface is rather clumsy for extracting
information though, and XML documents are notoriously wordy: The
|fruit.xml| document looks like a lot, but all it says is 'apples are
red, oranges are orange, and bananas are yellow'.

---

@_|JSON|_As an alternative to XML, JavaScript programmers have come up
with something called [JSON | http://www.json.org]. This uses the
basic notation of JavaScript values to represent 'hierarchical'
information in a more minimalist way. A JSON document is a file
containing a single JavaScript object or array, which in turn contains
any number of other objects, arrays, strings, numbers, booleans, or
|null| values. For an example, look at |fruit.json|:

> request.open("GET", "files/fruit.json", true);
> request.send(null);
> request.onreadystatechange = function() {
>   if (request.readyState == 4)
>     print(request.responseText);
> };

Such a piece of text can be converted to a normal JavaScript value by
using the _|eval|_ function. Parentheses should be added around it
before calling |eval|, because otherwise JavaScript might interpret an
object (enclosed by braces) as a block of code, and produce an error.

> function evalJSON(json) {
>   return eval("(" + json + ")");
> }
> var fruit = evalJSON(request.responseText);
> show(fruit);

When running |eval| on a piece of text, you have to keep in mind that
this means you let the piece of text run whichever code it wants.
Since JavaScript only allows us to make requests to our own domain,
you will usually know exactly what kind of text you are getting, and
this is not a problem. In other situations, it might be unsafe.

***

Write a function called |serializeJSON| which, when given a JavaScript
value, produces a string with the value's JSON representation. Simple
values like numbers and booleans can be simply given to the |String|
function to convert them to a string. Objects and arrays can be
handled by recursion.

Recognizing arrays can be tricky, since its type is |"object"|. You
can use |instanceof Array|, but that only works for arrays that were
created in your own window -- others will use the |Array| prototype
from other windows, and |instanceof| will return |false|. A cheap
trick is to convert the |constructor| property to a string, and see
whether that contains |"function Array"|.

When converting a string, you have to take care to escape special
characters inside it. If you use double-quotes around the string, the
characters to escape are |\"|, |\\|, |\f|, |\b|, |\n|, |\t|, |\r|, and
|\v|##.

## We already saw |\n|, which is a newline. |\t| is a tab character,
|\r| a 'carriage return', which some systems use before or instead of
a newline to indicate the end of a line. |\b| (backspace), |\v|
(vertical tab), and |\f| (form feed) are useful when working with old
printers, but less so when dealing with Internet browsers.

///

> function serializeJSON(value) {
>   function isArray(value) {
>     return /^\s*function Array/.test(String(value.constructor));
>   }
>
>   function serializeArray(value) {
>     return "[" + map(serializeJSON, value).join(", ") + "]";
>   }
>   function serializeObject(value) {
>     var properties = [];
>     forEachIn(value, function(name, value) {
>       properties.push(serializeString(name) + ": " +
>                       serializeJSON(value));
>     });
>     return "{" + properties.join(", ") + "}";
>   }
>   function serializeString(value) {
>     var special =
>       {"\"": "\\\"", "\\": "\\\\", "\f": "\\f", "\b": "\\b",
>        "\n": "\\n", "\t": "\\t", "\r": "\\r", "\v": "\\v"};
>     var escaped = value.replace(/[\"\\\f\b\n\t\r\v]/g,
>                                 function(c) {return special[c];});
>     return "\"" + escaped + "\"";
>   }
>
>   var type = typeof value;
>   if (type == "object" && isArray(value))
>     return serializeArray(value);
>   else if (type == "object")
>     return serializeObject(value);
>   else if (type == "string")
>     return serializeString(value);
>   else
>     return String(value);
> }
>
> print(serializeJSON(fruit));

The trick used in |serializeString| is similar to what we saw in the
|escapeHTML| function in \\cregexp. It uses an object to look up the
correct replacements for each of the characters. Some of them, such as
|"\\\\"|, look quite weird because of the need to put two backslashes
for every backslash in the resulting string.

Also note that the names of properties are quoted as strings. For some
of them, this is not necessary, but for property names with spaces and
other strange things in them it is, so the code just takes the easy
way out and quotes everything.

---

When making lots of requests, we do, of course, not want to repeat the
whole |open|, |send|, |onreadystatechange| ritual every time. A very
simple wrapper could look like this:

> function simpleHttpRequest(url, success, failure) {
>   var request = makeHttpObject();
>   request.open("GET", url, true);
>   request.send(null);
>   request.onreadystatechange = function() {
>     if (request.readyState == 4) {
>       if (request.status == 200)
>         success(request.responseText);
>       else if (failure)
>         failure(request.status, request.statusText);
>     }
>   };
> }
>
> simpleHttpRequest("files/fruit.txt", print);

The function retrieves the url it is given, and calls the function it
is given as a second argument with the content. When a third argument
is given, this is used to indicate failure -- a non-|200| status code.

To be able to do more complex requests, the function could be made to
accept extra parameters to specify the method (|GET| or |POST|), an
optional string to post as data, a way to add extra headers, and so
on. When you have so many arguments, you'd probably want to pass them
as an arguments-object as seen in \\cmodularity.

---

Some websites make use of intensive communication between the programs
running on the client and the programs running on the server. For such
systems, it can be practical to think of some HTTP requests as calls
to functions that run on the server. The client makes request to URLs
that identify the functions, giving the arguments as URL parameters or
|POST| data. The server then calls the function, and puts the result
into JSON or XML document that it sends back. If you write a few
convenient support functions, this can make calling server-side
functions almost as easy as calling client-side ones... except, of
course, that you do not get their results instantly.

+++++++++++++++++++++++++++++++++++++++++++
More (obscure) control structures / control
+++++++++++++++++++++++++++++++++++++++++++

In \\cbasics, a number of control statements were introduced, such as
|while|, |for|, and |break|. To keep things simple, I left out some
others, which, in my experience, are a lot less useful. This appendix
briefly describes these missing control statements.

---

First, there is _|do|_. |do| works like |while|, but instead of
executing the loop body zero or more times, it executes it one or more
times. A |do| loop looks like this:

> do {
>   var answer = prompt("Say 'moo'.", "");
>   print("You said '", answer, "'.");
> } while (answer != "moo");

To emphasise the fact that the condition is only checked *after* the
loop has run once, it is written at the end of the loop's body.

---

Next, there is _|continue|_. This one is closely related to |break|,
and can be used in the same places. While |break| jumps *out* of a
loop and causes the program to proceed after the loop, |continue|
jumps to the next iteration of the loop.

> for (var i = 0; i < 10; i++) {
>   if (i % 3 != 0)
>     continue;
>   print(i, " is divisible by three.");
> }

A similar effect can usually be produced using just |if|, but there
are cases where |continue| looks nicer.

---

When there is a loop sitting inside another loop, a |break| or
|continue| statement will affect only the inner loop. Sometimes you
want to jump out of the *outer* loop. To be able to refer to a
specific loop, loop statements can be _label_led. A label is a name
(any valid variable name will do), followed by a colon (|:|).

> outer: for (var sideA = 1; sideA < 10; sideA++) {
>   inner: for (var sideB = 1; sideB < 10; sideB++) {
>     var hypotenuse = Math.sqrt(sideA * sideA + sideB * sideB);
>     if (hypotenuse % 1 == 0) {
>       print("A right triangle with straight sides of length ",
>             sideA, " and ", sideB, " has a hypotenuse of ",
>             hypotenuse, ".");
>       break outer;
>     }
>   }
> }

---

Next, there is a construct called _|switch|_ which can be used to
choose which code to execute based on some value. This is a very
useful thing to do, but the syntax JavaScript uses for this (which it
took from the C programming language) is so clumsy and ugly that I
usually prefer to use a chain of |if| statements instead.

> function weatherAdvice(weather) {
>   switch(weather) {
>     case "rainy":
>       print("Remember to bring an umbrella.");
>       break;
>     case "sunny":
>       print("Dress lightly.");
>     case "cloudy":
>       print("Go outside.");
>       break;
>     default:
>       print("Unknown weather type: ", weather);
>       break;
>   }
> }
>
> weatherAdvice("sunny");

Inside the block opened by |switch|, you can write a number of |case|
labels. The program will jump to the label that corresponds to the
value that |switch| was given (comparing the values with an equivalent
of |===|, so without automatic type conversion), or to |default| if no
matching value is found. Then it start executing statements there, and
*continues* past other labels, until it reaches a |break| statement.
In some cases, such as the |"sunny"| case in the example, this can be
used to share some code between cases (it recommends going outside for
both sunny and cloudy weather). Most of the time, this just adds a lot
of ugly |break| statements, or causes problems when you forget to add
one.

Like loops, |switch| statements can be given a label.

---

Finally, there is a keyword named _|with|_. I've never actually *used*
this in a real program, but I have seen other people use it, so it is
useful to know what it is. Code using |with| looks like this:

> var scope = "outside";
> var object = {name: "Ignatius", scope: "inside"};
> with(object) {
>   print("Name == ", name, ", scope == ", scope);
>   name = "Raoul";
>   var newVariable = 49;
> }
> show(object.name);
> show(newVariable);

Inside the block, the properties of the object given to |with| act as
variables. Newly introduced variables are *not* added as properties to
this object though. I assume the idea behind this construct was that
it could be useful in methods that make lots of use of the properties
of their object. You could start such a method with |with(this)
{...}|, and not have to write |this| all the time after that.

+++++++++++++++++++++++++
Binary Heaps / binaryheap
+++++++++++++++++++++++++

In \\csearch, the _binary heap_ was introduced as a method to store a
collection of objects in such a way that the smallest element can be
quickly found. As promised, this appendix will explain the details
behind this data structure.

Consider again the problem we needed to solve. The A* algorithm
created large amounts of small objects, and had to keep these in an
'open list'. It was also constantly removing the smallest element from
this list. The simplest approach would be to just keep all the objects
in an array, and search for the smallest one when we need it. But,
unless we have a *lot* of time, this will not do. Finding the smallest
element in an unsorted array requires going over the whole array, and
checking each element.

The next solution would be, of course, to sort our array. JavaScript
arrays have a wonderful _|sort|_ method, which can be used to do the
heavy work. Unfortunately, re-sorting a whole array every time an
element is removed is more work than searching for a minimum value in
an unsorted array. Some tricks can be used, such as, instead of
re-sorting the whole array, just making sure new values are inserted
in the right place so that the array, which was sorted before, stays
sorted. This is coming closer to the approach a binary heap uses
already, but inserting a value in the middle of an array requires
moving all the elements after it one place up, which is still just too
slow.

Another approach is to not use an array at all, but to store the
values in a set of interconnected objects. A simple form of this is to
have every object hold one value and two (or less) links to other
objects. There is one root object, holding the smallest value, which
is used to access all the other objects. Links always point to objects
holding greater values, so the whole structure looks something like
this:

[[tree.png]]

Such structures are usually called _tree_s, because of the way they
branch. Now, when you need the smallest element, you just take off the
top element and rearrange the tree so that one of the top element's
children -- the one with the lowest value -- becomes the new top. When
inserting new elements, you 'descend' the tree until you find an
element less than the new element, and insert it there. This takes a
lot less searching than a sorted array does, but it has the
disadvantage of creating a lot of objects, which also slows things
down.

---

A binary heap, then, does make use of a sorted array, but it is only
partially sorted, much like the tree above. Instead of objects, the
positions in the array are used to form a tree, as this picture tries
to show:

[[heap.png]]

Array element |1| is the root of the tree, array element |2| and |3|
are its children, and in general array element |X| has children |X *
2| and |X * 2 + 1|. You can see why this structure is called a 'heap'.
Note that this array starts at |1|, while JavaScript arrays start at
|0|. The heap will always keep the smallest element in position |1|,
and make sure that for every element in the array at position |X|, the
element at |X / 2| (round down) is smaller.

Finding the smallest element is now a matter of taking the element at
position |1|. But when this element is removed, the heap must make
sure that there are no holes left in the array. To do this, it takes
the last element in the array and moves it to the start, and then
compares it to its child elements at position |2| and |3|. It is
likely to be greater, so it is exchanged with one of them, and the
process of comparing it with its children is repeated for the new
position, and so on, until it comes to a position where its children
are greater, or a position where it has no children.

] [2, 3, 5, 4, 8, 7, 6]
] Take out 2, move 6 to the front.
] [6, 3, 5, 4, 8, 7]
] 6 is greater than its first child 3, so swap them.
] [3, 6, 5, 4, 8, 7]
] Now 6 has children 4 and 8 (position 4 and 5). It is greater than
] 4, so we swap again.
] [3, 4, 5, 6, 8, 7]
] 6 is in position 4, and has no more children. The heap is in order
] again.

Similarly, when an element has to be added to the heap, it is put at
the end of the array and allowed to 'bubble' up by repeatedly
exchanging it with its parent, until we find a parent that is less
than the new node.

] [3, 4, 5, 6, 8, 7]
] Element 2 gets added again, it starts at the back.
] [3, 4, 5, 6, 8, 7, 2]
] 2 is in position 7, its parent is at 3, which is a 5. 5 is greater
] than 2, so we swap.
] [3, 4, 2, 6, 8, 7, 5]
] The parent of position 3 is position 1. Again, we swap.
] [2, 4, 3, 6, 8, 7, 5]
] The element can not go further than position 1, so we are done.

Note how adding or inserting an element does not require it to be
compared with every element in the array. In fact, because the jumps
between parents and children get bigger as the array gets bigger, this
advantage is especially large when we have a lot of elements##.

## The amount of comparisons and swaps that are needed -- in the worst
case -- can be approached by taking the logarithm (base 2) of the
amount of elements in the heap.

---

Here is the full code of a binary heap implementation. Two things to
note are that, instead of directly comparing the elements put into the
heap, a function (|scoreFunction|) is first applied to them, so that
it becomes possible to store objects that can not be directly
compared.

Also, because JavaScript arrays start at |0|, and the parent/child
calculations use a system that starts at |1|, there are a few strange
calculations to compensate.

> function BinaryHeap(scoreFunction){
>   this.content = [];
>   this.scoreFunction = scoreFunction;
> }
> 
> BinaryHeap.prototype = {
>   push: function(element) {
>     // Add the new element to the end of the array.
>     this.content.push(element);
>     // Allow it to bubble up.
>     this.bubbleUp(this.content.length - 1);
>   },
>
>   pop: function() {
>     // Store the first element so we can return it later.
>     var result = this.content[0];
>     // Get the element at the end of the array.
>     var end = this.content.pop();
>     // If there are any elements left, put the end element at the
>     // start, and let it sink down.
>     if (this.content.length > 0) {
>       this.content[0] = end;
>       this.sinkDown(0);
>     }
>     return result;
>   },
>
>   remove: function(node) {
>     var len = this.content.length;
>     // To remove a value, we must search through the array to find
>     // it.
>     for (var i = 0; i < len; i++) {
>       if (this.content[i] == node) {
>         // When it is found, the process seen in 'pop' is repeated
>         // to fill up the hole.
>         var end = this.content.pop();
>         if (i != len - 1) {
>           this.content[i] = end;
>           if (this.scoreFunction(end) < this.scoreFunction(node))
>             this.bubbleUp(i);
>           else
>             this.sinkDown(i);
>         }
>         return;
>       }
>     }
>     throw new Error("Node not found.");
>   },
>
>   size: function() {
>     return this.content.length;
>   },
>
>   bubbleUp: function(n) {
>     // Fetch the element that has to be moved.
>     var element = this.content[n];
>     // When at 0, an element can not go up any further.
>     while (n > 0) {
>       // Compute the parent element's index, and fetch it.
>       var parentN = Math.floor((n + 1) / 2) - 1,
>           parent = this.content[parentN];
>       // Swap the elements if the parent is greater.
>       if (this.scoreFunction(element) < this.scoreFunction(parent)) {
>         this.content[parentN] = element;
>         this.content[n] = parent;
>         // Update 'n' to continue at the new position.
>         n = parentN;
>       }
>       // Found a parent that is less, no need to move it further.
>       else {
>         break;
>       }
>     }
>   },
>
>   sinkDown: function(n) {
>     // Look up the target element and its score.
>     var length = this.content.length,
>         element = this.content[n],
>         elemScore = this.scoreFunction(element);
>
>     while(true) {
>       // Compute the indices of the child elements.
>       var child2N = (n + 1) * 2, child1N = child2N - 1;
>       // This is used to store the new position of the element,
>.      // if any.
>       var swap = null;
>       // If the first child exists (is inside the array)...
>       if (child1N < length) {
>         // Look it up and compute its score.
>         var child1 = this.content[child1N],
>             child1Score = this.scoreFunction(child1);
>         // If the score is less than our element's, we need to swap.
>         if (child1Score < elemScore)
>           swap = child1N;
>       }
>       // Do the same checks for the other child.
>       if (child2N < length) {
>         var child2 = this.content[child2N],
>             child2Score = this.scoreFunction(child2);
>         if (child2Score < (swap == null ? elemScore : child1Score))
>           swap = child2N;
>       }
>
>       // If the element needs to be moved, swap it, and continue.
>       if (swap != null) {
>         this.content[n] = this.content[swap];
>         this.content[swap] = element;
>         n = swap;
>       }
>       // Otherwise, we are done.
>       else {
>         break;
>       }
>     }
>   }
> };

And a simple test...

> var heap = new BinaryHeap(function(x){return x;});
> forEach([10, 3, 4, 8, 2, 9, 7, 1, 2, 6, 5],
>         method(heap, "push"));
>
> heap.remove(2);
> while (heap.size() > 0)
>   print(heap.pop());
