====================
Introduction / intro
====================

Lorsque les premiers ordinateurs personnels sont apparus, la plupart d'entre
eux étaient fournis avec un langage de programmation simple, généralement
une variante de _BASIC_. Les interactions avec l'ordinateur étaient fortement
liées à ce langage, et tout utilisateur d'un ordinateur devait dès lors y
goûter, qu'il le veuille ou non. À présent que les ordinateurs sont devenus
nombreux et bon marché, l'utilisateur moyen se contente la plupart du temps
de ce qu'il peut faire en cliquant avec la souris. Pour nombre d'entre eux,
cela fonctionne très bien. Mais pour ceux d'entre nous qui ont une inclination
naturelle au bricolage technique, la disparition de la programmation dans
l'usage quotidien d'un ordinateur représente une forme de barrière.

Heureusement, avec l'évolution du World Wide Web, il se trouve que chaque
ordinateur équipé d'un navigateur web moderne a également un environnement
pour programmer en JavaScript. Il est gardé bien caché car il est dans
l'air du temps de ne pas ennuyer l'utilisateur avec des détails techniques,
mais une page web peut le rendre accessible et l'utiliser comme une plateforme
pour apprendre à programmer.

C'est ce que ce livre (ou hyper-livre) essaie de faire.

---

| Je n'ai pas pour but d'éclairer ceux qui ne sont pas désireux
| d'apprendre, ni éveiller ceux qui ne sont pas soucieux de donner une
| explication eux-mêmes. Si je leur ai montré un angle du carré et
| qu'ils ne peuvent pas revenir à moi avec les trois autres, je ne
| devrais pas revenir sur le premier angle.
|
| — Confucius

Au-delà des explications qu'il donne sur le JavaScript, ce livre s'efforce
d'initier aux principes fondamentaux de la programmation. Programmer
s'avère être un exercice difficile. Les règles de base sont la plupart
du temps simples et claires. Cependant, même des programmes construits
suivant ces règles de base, tendent à devenir suffisamment élaborés pour
générer leurs propres règles et leur propre complexité. Voilà pourquoi la
programmation est rarement simple et prévisible. Comme le dit Donald Knuth,
que l'on peut considérer comme un des pères fondateurs dans ce domaine,
c'est un *art*.

Pour tirer quelque chose de ce livre, il est indispensable de faire plus que
de le lire passivement. Essayez de garder l'esprit affûté, efforcez-vous
de résoudre les exercices, et n'allez plus loin que lorsque vous êtes
certain d'avoir bien assimilé les étapes précédentes.

---

| Le programmeur en informatique est un créateur d'univers dont il
| est seul responsable. Des univers d'une complexité potentiellement
| illimitée peuvent être créés sous forme de programmes informatiques.
|
| ― Joseph Weizenbaum, *La puissance de l'ordinateur et la raison humaine*

Un programme, c'est beaucoup de choses. C'est un bout de texte tapé par un
programmeur, c'est la force directrice qui indique à l'ordinateur ce qu'il
doit faire, c'est un ensemble de données dans la mémoire de l'ordinateur,
et pourtant il contrôle les actions accomplies dans cette même mémoire. Les
analogies qui comparent les programmes à des objets qui nous sont familiers
ont tendance à tourner court alors que celle d'une machine est, de manière
superficielle, mieux adaptée. Les roues et les engrenages d'une montre
mécanique sont ingénieusement agencés et coordonnés, et si l'horloger
connaît son affaire, la montre donnera l'heure pendant des années. Les
parties d'un programme sont de même étroitement solidaires et si le
programmeur sait ce qu'il fait, son programme fonctionnera sans plantage.

Un ordinateur est une machine conçue pour héberger ce genre de machines
immatérielles. Les ordinateurs eux-mêmes ne peuvent qu'exécuter stupidement
des choses simples. S'ils sont très utiles, c'est parce qu'ils peuvent
faire ces choses à une vitesse incroyable. Un programme peut, en combinant
un grand nombre de ces actions simples, accomplir des tâches très complexes.

Pour beaucoup d'entre nous, écrire des programmes informatiques est un
jeu fascinant. Un programme est une construction de l'esprit. Il ne coûte
rien à élaborer, il ne pèse rien et se développe facilement sous nos
mains. Si nous nous laissons aller, sa taille et sa complexité vont prendre
des proportions démesurées, au point d'échapper au contrôle même de celui
qui l'a créé. C'est le principal problème de la programmation. C'est la
raison pour laquelle beaucoup de logiciels aujourd'hui finissent par planter,
échouer et tout saloper.

Quand un programme fonctionne, c'est beau. L'art de la programmation est
l'art de contrôler la complexité. Un programme de grande qualité est
discret et apparaît simple malgré sa complexité.

---

Aujourd'hui, beaucoup de programmeurs croient que cette complexité est
plus facile à gérer en utilisant seulement un petit jeu de techniques
bien comprises dans leurs programmes. Ils ont élaboré des règles strictes
concernant la forme que devraient adopter les programmes, et les plus zélés
d'entre eux dénonceront ceux qui enfreignent ces règles comme de *mauvais*
programmeurs.

Quelle hostilité envers la richesse de la programmation ! Essayer de
la réduire à quelque chose de direct et de prévisible, jeter l'opprobre
sur tous les programmes bizarres et magnifiques. Le champ des techniques de
programmation est gigantesque, fascinant par sa diversité et encore largement
inexploré. Il est certainement bourré de chausse-trappes et de pièges à
loups, menaçant de faire commettre au programmeur inexpérimenté toute sorte
d'affreuses erreurs. Cela signifie seulement que vous devez procéder avec
prudence et garder votre sang-froid. En apprenant, vous rencontrerez toujours
de nouveaux défis, de nouveaux territoires à explorer. Le programmeur qui
refuse l'exploration va sûrement végéter, ne plus trouver ça drôle,
perdre le désir de programmer (et devenir chef de projet).

En ce qui me concerne, le critère décisif pour évaluer un programme est :
« Est-il correct ? ». L'efficacité, la clarté et la taille sont
également importantes, mais pouvoir peser avec exactitude le poids de l'un
et le poids de l'autre est toujours une question d'opinion, une opinion
que doit se faire chaque programmeur. Les règles générales sont utiles,
mais on ne devrait jamais avoir peur de les transgresser.

---

Au début de l'informatique, lorsqu'elle venait de naître, il n'existait
pas de langage de programmation. Les programmes ressemblaient à ceci :

] 00110001 00000000 00000000
] 00110001 00000001 00000001
] 00110011 00000001 00000010
] 01010001 00001011 00000010
] 00100010 00000010 00001000
] 01000011 00000001 00000000
] 01000001 00000001 00000001
] 00010000 00000010 00000000
] 01100010 00000000 00000000

Il s'agit d'un programme qui fait la somme des nombres de 1 à 10 et donne
le résultat (1 + 2 + … + 10 = 55). Il pourrait tourner sur l'ordinateur le
plus simple. Pour programmer les premiers ordinateurs, il était nécessaire
de disposer de grandes séries d'interrupteurs dans la bonne position, ou de
perforer des trous dans des cartes et les faire avaler à la machine. Vous
imaginez facilement à quel point la procédure était fastidieuse et sujette
à erreurs. Écrire ne serait-ce qu'un programme simple exigeait beaucoup
d'intelligence et de discipline, les programmes complexes étaient carrément
hors d'atteinte.

Bien entendu, saisir à la main des masques de bits (c'est ainsi qu'on
appelle en général les suites de 1 et de 0 ci-dessus) donnait au programmeur
l'impression d'être un puissant sorcier. Cela ne peut pas compter pour du
beurre en ce qui concerne la satisfaction professionnelle.

Chaque ligne de programme contient une instruction unique. On pourrait
l'exprimer en français sous cette forme :

 1. Stocker le nombre 0 à l'adresse mémoire 0
 2. Stocker le nombre 1 à l'adresse mémoire 1
 3. Stocker la valeur de l'adresse mémoire 1 dans l'adresse mémoire 2
 4. Soustraire 11 de la valeur stockée à l'adresse mémoire 2
 5. Si la valeur à l'adresse mémoire 2 est le nombre 0, continuer à l'instruction 9
 6. Ajouter la valeur de l'adresse mémoire 1 à l'adresse mémoire 0
 7. Ajouter le nombre 1 à la valeur de l'adresse mémoire 1
 8. Continuer avec l'instruction 3
 9. Donner la valeur de l'adresse mémoire 0

Alors que c'est déjà plus lisible que la soupe binaire, cela reste assez
désagréable. Il pourrait être utile d'utiliser des noms au lieu de nombres
pour les instructions et les adresses mémoire :

]  Mettre 0 à 'total'
]  Mettre 1 à 'compteur'
] [boucle]
]  Mettre compteur' à 'comparaison'
]  Soustraire 11 à 'comparaison'
]  Si 'comparaison' est zero, continuer à [fin]
]  Ajouter 'compteur' à 'total'
]  Ajouter 1 à 'compteur'
]  Continuer à [boucle]
] [fin]
]  Afficher 'total'

À partir de là il n'est pas trop difficile de deviner comment fonctionne
le programme. Qu'en dites-vous ? Les deux premières lignes donnent leur
valeur initiale aux adresses mémoire : |total| sera utilisé pour calculer
le résultat du programme et |compteur| conserve le nombre courant. Les
lignes qui utilisent |comparaison| sont probablement les plus bizarres. Ce
que le programme cherche à savoir c'est si |compteur| est égal à 11,
de manière à savoir s'il doit interrompre le calcul. Comme la machine est
très rudimentaire, il peut seulement tester si un nombre est zéro, et prend
une décision (sauter) basée sur ce critère. il utilise donc l'adresse
mémoire nommée |comparaison| pour calculer la valeur de |compteur - 11|,
et décide suivant la valeur obtenue. Les deux lignes suivantes ajoutent la
valeur de |compteur| au résultat, et l'incrémentent |compteur| d'une unité
à chaque fois que le programme a décidé qu'il n'avait pas encore atteint 11.

Voici maintenant le même programme en JavaScript :

> var total = 0, compteur = 1;
> while (compteur <= 10) {
>   total += compteur;
>   compteur += 1;
> }
> print(total);

C'est encore un peu mieux pour nous. Le plus important est qu'il n'y a plus
besoin de préciser la façon dont nous voulons que le programme fasse un bond
par-ci par-là. Le mot magique |while| s'en occupe. Le programme continue à
exécuter les lignes ci-dessous tant que la condition qu'on lui a donnée est
satisfaite : |compteur <= 10|, ce qui veut dire tant que « |compteur|
est inférieur ou égal à |10| ». Apparemment, il n'y a plus besoin de
créer une valeur temporaire et de la comparer à zéro. C'était un petit
détail stupide, et le pouvoir des langages de programmation est justement
qu'ils règlent pour nous ce genre de choses accessoires.

Finalement, voici à quoi pourrait ressembler le programme si nous nous étions
arrangés pour que les opérations |serie| et |somme| soient disponibles,
la première créant une collection de nombres dans une série tandis que
la seconde calcule la somme d'une série de nombres :

> print(somme(serie(1, 10)));

La morale de cette histoire est donc que le même programme peut être
exprimé de façon brève ou longue, lisible ou illisible. La première
version du programme était extrêmement obscure, tandis que la dernière
est quasiment du français : |print| (afficher) la |somme| de la |serie|
des nombres de |1| à |10|. Nous verrons par la suite dans d'autres chapitres
comment construire des choses telles que |somme| et |serie|.

Un bon langage de programmation aide le programmeur en lui fournissant une
manière plus abstraite de s'exprimer. Il masque les détails inintéressants,
procure des composants de base pratiques (comme la |while|) et, la plupart
du temps, permet au programmeur d'ajouter lui-même de telles briques (comme
les opérations |somme| et |serie|).

---

JavaScript est le langage qui est, actuellement, le plus
utilisé pour faire toutes sortes de choses géniales et
horribles avec des pages sur le World Wide Web. [Certains |
http://steve-yegge.blogspot.com/2007/02/next-big-language.html] prétendent
que la prochaine version de JavaScript en fera un langage de référence
pour d'autres tâches également. J'ignore si cela va se produire, mais si
vous êtes intéressé par la programmation, JavaScript est sans aucun doute
un langage utile à apprendre. Même si en fin de compte vous ne faites pas
tellement de programmation web, les programmes hallucinants que je vais vous
montrer dans cet ouvrage resteront toujours en vous, à vous hanter et à
influencer les programmes que vous écrirez dans d'autres langages.

Certains vous diront des choses *terribles* à propos de JavaScript. Beaucoup
de ces reproches sont fondés. La première fois que j'ai dû écrire quelque
chose en JavaScript, j'ai rapidement méprisé ce langage. Il acceptait
à peu près tout ce que je tapais, mais l'interprétait d'une façon
complètement différente de celle que je voulais. Cela venait surtout du
fait que je n'avais aucune idée de ce que je faisais, mais il y a aussi un
véritable problème ici : JavaScript est absurdement laxiste dans ce qu'il
permet. L'idée derrière cette conception était de rendre la programmation
en JavaScript plus facile pour les débutants. En réalité, il rend surtout
plus difficile la recherche des problèmes dans vos programmes, parce que
le système ne vous les montrera pas.

Toutefois, la souplesse de ce langage est aussi un avantage. Elle laisse la
place à de nombreuses techniques que les langages de programmation plus
rigides ne permettent pas, et on peut l'utiliser pour compenser certains
défauts de JavaScript. Après l'avoir étudié correctement et avoir
travaillé avec un certain temps, j'ai vraiment appris à *aimer* ce langage.

---

Contrairement à ce que son nom suggère, JavaScript a très peu à voir avec
le langage de programmation nommé Java. Le nom similaire a été inspiré
par des considérations commerciales plutôt que rationnelles. En 1995,
quand le JavaScript a été lancé par Netscape, le langage Java était promu
partout et gagnait en popularité. Apparemment, quelqu'un a dû penser que
c'était une bonne idée d'essayer de surfer sur la mode du moment. Nous
voilà aujourd'hui coincé avec ce nom.

Il existe un langage associé au JavaScript et qui s'appelle ECMAScript. Quand
les navigateurs autres que Netscape ont commencé à prendre en charge le
JavaScript, ou quelque chose du même genre, on a écrit une documentation pour
décrire avec précision comment le langage en question devait fonctionner. On
l'a appelé ECMAScript, d'après le nom de l'organisation qui l'a standardisé.

ECMAScript décrit un langage de programmation à usage général, mais ne
dit rien sur l'intégration de ce langage dans un navigateur internet. Le
JavaScript c'est ECMAScript plus des outils supplémentaires pour gérer
les pages web et les fenêtres de navigation.

Quelques autres logiciels utilisent le langage décrit dans le document
ECMAScript. Plus important, le langage ActionScript utilisé par Flash est
basé sur ECMAScript (bien qu'il ne suive pas précisément le standard). Flash
est un système utilisé pour ajouter des trucs qui bougent et font du bruit
sur les pages web. Ça ne vous fera pas de mal de connaître JavaScript si
vous devez un jour apprendre à faire des animations en Flash.

JavaScript continue d'évoluer. Depuis la sortie de cet ouvrage, ECMAScript
5 est sorti, il est compatible avec la version décrite ici, mais y ajoute,
en tant que méthodes natives, quelques fonctionnalités que nous écrirons
nous-même. La dernière génération de navigateurs fournit cette version
augmentée de JavaScript. En 2011, « ECMAScript harmony », une extension
plus radicale du langage, est en cours de standardisation. Vous ne devriez
pas trop craindre que ces nouvelles versions rendent obsolètes ce que vous
apprenez dans ce livre. Il ne s'agira que d'une extension du langage dont
nous disposons actuellement, donc pratiquement tout ce qui est écrit dans
ce livre restera valide.

---

La plupart des chapitres de ce livre contiennent une quantité non négligeable
de code##. D'après mon expérience, lire et écrire du code est une part
importante de l'apprentissage de la programmation. Essayez de ne pas seulement
jeter un œil sur ces exemples mais lisez-les vraiment attentivement et
comprenez-les. Cela peut être long et déroutant au début, mais vous prendrez
rapidement le coup. Il en va de même concernant les exercices. N'estimez pas
les comprendre avant d'avoir effectivement écrit une solution qui fonctionne.

## Le « Code » est la substance dont sont composés les
programmes. Chaque morceau de programme, que ce soit une ligne unique ou
tout un ensemble, peut être appelé « code ».

Le fonctionnement même du Web fait qu'il est toujours possible d'examiner
les programmes JavaScript que les gens utilisent dans leurs pages
web. Cela peut être un bon moyen d'apprendre comment certaines choses sont
réalisées. Étant donné que la plupart des programmeurs web ne sont pas
des programmeurs « professionnels », ou qu'ils ne considèrent pas
la programmation JavaScript comme suffisamment intéressante pour en faire
convenablement l'apprentissage, beaucoup du code que vous pourrez trouver
ainsi sera de *très* mauvaise qualité. Quand vous apprenez à partir de
code laid et incorrect, la laideur et la confusion se propagent dans votre
propre code ; faites donc très attention de qui vous prenez vos leçons.

---

Pour vous permettre d'essayer les programmes, aussi bien les exemples que le
code que vous écrirez vous-même, ce livre utilise ce que l'on appelle une
_console_. Si vous utilisez un navigateur graphique moderne (Internet Explorer
version 6 ou supérieur, Firefox 1.5 ou supérieur, Opera 9 ou supérieur,
Safari 3 ou supérieur), les pages de ce livre vont afficher une barre en
bas de votre écran. Vous pouvez ouvrir la console en cliquant sur la petite
flèche à l'extrémité droite de cette barre.

La console contient trois éléments importants. Il y a une fenêtre de
sortie, qui est utilisée pour montrer les messages d'erreurs et les choses
qu'affichent les programmes. Sous celle-ci se trouve une ligne où vous pouvez
saisir un bout de JavaScript. Essayez de saisir un nombre et appuyez sur la
touche Entrée pour lancer ce que vous avez tapé. Si le texte que vous avez
saisi a produit quelque chose de sensé, cela sera affiché dans la fenêtre
de sortie. Maintenant, essayez de taper |mauvais!|, et appuyez à nouveau
sur Entrée. La fenêtre de sortie va afficher un message d'erreur. Vous
pouvez utiliser les touches flèche vers le haut et flèche vers le bas pour
revenir aux commandes que vous avez saisies précédemment.

Pour les bouts de code plus importants, ceux qui s'étendent sur plusieurs
lignes et que vous voulez conserver un peu, le champ de droite peut être
utilisé. Le bouton « Lancer » est utilisé pour exécuter les programmes
écrits dans ce champ. Il est possible d'avoir plusieurs programmes ouverts en
même temps. Utilisez les boutons « Nouveau » et « Charger » pour
ajouter un nouveau programme (vide ou depuis un fichier sur le web). Quand il
y a plus d'un programme ouvert, le menu après le bouton « Lancer » peut
être utilisé pour choisir lequel est affiché. Le bouton « Fermer »,
comme vous pouvez vous en douter, ferme un programme.

Il y a toujours un petit bouton avec une flèche dans le coin supérieur
droit des programmes d'exemple de ce livre, qui peut être utilisé pour
les lancer. L'exemple que nous avons vu auparavant ressemblait à ceci :

> var total = 0, compteur = 1;
> while (compteur <= 10) {
>   total += compteur;
>   compteur += 1;
> }
> print(total);

Lancez-le en cliquant sur la flèche. Il y a aussi un autre bouton qui sert
à charger le programme dans la console. N'hésitez pas à le modifier et
à essayer le résultat. Le pire qu'il puisse arriver est que vous créiez
une boucle sans fin. Une boucle infinie est ce que vous obtenez lorsque
la condition d'un |while| ne devient jamais fausse, par exemple si vous
choisissez d'ajouter |0| au lieu de |1| à la variable compteur. Alors le
programme va tourner pour toujours.

Heureusement, les navigateurs gardent un œil sur les programmes qu'ils font
tourner. Lorsque l'un d'eux prend un délai démesuré pour se terminer,
ils vous demandent si vous voulez l'interrompre.

---

Dans certains chapitres à venir, nous créerons des programmes d'exemple
qui seront constitués de multiples blocs de code. Souvent, vous devrez
lancer chacun d'eux pour faire fonctionner le programme. Comme vous l'avez
peut-être remarqué, la flèche d'un bloc de code devient violette lorsque
le bloc a été exécuté. Lorsque vous lisez un chapitre, essayez de
lancer chaque bloc de code que vous rencontrez, particulièrement ceux qui
« définissent » quelque chose de nouveau (vous verrez ce que cela
signifie dans le prochain chapitre).

Il est évidemment possible que vous ne puissiez pas lire un chapitre
d'une seule traite. Ça veut dire que vous devrez commencer à mi-chemin
quand vous reprendrez votre lecture, mais si vous ne lancez pas tout le
code en commençant du haut du chapitre, certaines choses peuvent ne pas
fonctionner. En maintenant la touche majuscule pendant que vous appuyez sur
la flèche « Lancer » d'un bloc de code, tous les blocs précédents
celui-ci seront également exécutés, ainsi lorsque vous commencez au
milieu d'un chapitre, maintenez la touche majuscule enfoncée la première
fois que vous faites tourner un morceau de code, et tout devrait fonctionner
comme prévu.

---

Enfin, le petit visage dans le coin supérieur gauche de votre écran peut
être utilisé pour m'envoyer, à moi l'auteur, un message##. Si vous avez
un commentaire, ou que vous trouvez un passage incroyablement confus,
ou simplement que vous repérez une faute d'orthographe, faites-le moi
savoir. Il est possible d'envoyer un message sans quitter la page, ainsi
vous ne serez pas interrompu dans votre lecture.

## NdT: N'oubliez pas que l'auteur est anglophone.

===============================================================================
Les bases du JavaScript : valeurs, variables et structures de contrôle / basics
===============================================================================

Dans le monde des ordinateurs, seules les données existent. Ce qui n'est pas
une donnée n'existe pas. Bien que toute donnée soit en essence seulement une
séquence de bits##, et en cela fondamentalement similaires, chaque morceau
de donnée joue un rôle qui lui est propre. Dans le système JavaScript,
la plupart de ces données est soigneusement répartie entre des choses
appelées _valeur_s. Chaque valeur a un type qui détermine le rôle qu'elle
peut jouer. Il y a six types de valeurs de base : les nombres, les chaîne
de caractères, les booléens, les objets, les fonctions et |undefined|
pour représenter les valeurs indéfinies.

## Les bits sont toutes les choses à deux valeurs possibles, habituellement
décrits comme des |0| et des |1|. Dans l'ordinateur, ils se concrétisent
par une charge électrique élevée ou basse, un signal fort ou faible,
ou encore un point brillant ou terne sur la surface d'un CD.

Pour créer une valeur, on doit seulement invoquer son nom. C'est très
pratique. Vous n'avez pas à rassembler du matériel de construction pour vos
valeurs, ou payer pour elles, il vous suffit d'en appeler une et *hop*, vous
l'avez. Elles ne sont pas créées à partir de rien, évidemment. Chaque
valeur doit être stockée quelque part, et si vous voulez en utiliser un
grand nombre en même temps la mémoire de l'ordinateur pourrait venir à
manquer. Heureusement, ce problème ne se présente que si vous devez les
utiliser simultanément. Dès que vous n'utiliserez plus une valeur, elle
se dissipera en ne laissant que quelques bits derrière elle. Ces bits sont
recyclés pour fabriquer la génération suivante de valeurs.

---

Les valeurs de type nombre, nommées _number_ en JavaScript sont, comme vous
l'avez peut-être déduit, des valeurs numériques. Elles sont écrites de
la manière dont sont habituellement écrits les nombres :

>> 144

Saisissez cela dans la console et la même chose est affichée dans la
fenêtre de sortie. Le texte que vous avez saisi a donné naissance à une
valeur numérique; la console a pris ce nombre et l'a affiché de nouveau à
l'écran. Dans ce cas, c'était assez inutile, mais nous produirons bientôt
des valeurs de manières moins directes et il pourra être utile de « les
essayer » dans la console pour voir ce qu'elles produisent.

Voilà à quoi ressemble |144| écrit sous forme de bits##:

## Si vous attendiez quelque chose comme |10010000| c'est bien vu, mais
continuez à lire. Les nombres JavaScript ne sont pas stockés comme des
entiers.

] 0100000001100010000000000000000000000000000000000000000000000000

Le nombre précédent a 64 bits. C'est le cas de tous les nombres en
JavaScript. Cela a une répercussion importante : il y a une quantité
limitée de nombres pouvant être exprimés. Avec une décimale à trois
chiffres, seuls les nombres de 0 à 999 peuvent être écrits, soit 10^3 =
1000 nombres différents. Avec 64 chiffres binaires, on peut écrire 2^64
nombres différents. Cela en fait beaucoup, plus de 10^19 (un 1 suivi de
dix-neuf zéros).

Tous les nombres inférieurs à 10^19 ne tiennent cependant pas dans un
nombre JavaScript. D'une part, il y a aussi les nombres négatifs, ce
qui oblige à utiliser un des bits pour stocker le signe du nombre. Mais
ensuite, la représentation des nombres décimaux est un problème encore
plus important. Pour permettre celle-ci, 11 bits sont utilisés pour stocker
la position de la virgule au sein du nombre.

Il nous reste donc 52 bits##. Tout nombre entier inférieur à 2^52, ce
qui correspond à plus de 10^15, sera contenu sans risque dans un nombre
JavaScript. Dans la plupart des cas, les nombres que nous utilisons restent
bien en-deçà, nous n'avons donc absolument pas besoin de nous préoccuper
des bits, ce qui nous arrange. Je n'ai rien de particulier contre les bits,
mais *vous* avez besoin de beaucoup d'entre eux pour pouvoir faire quoi
que ce soit. Si possible, il est donc plus agréable de travailler avec des
entités plus grosses.

## En fait 53, à cause d'une astuce utilisable pour obtenir un bit
librement. Consultez le format « IEEE 754 » si vous êtes intéressé
par les détails.

Les nombres décimaux s'écrivent en utilisant un point.

>> 9.81

Pour les nombres très grands ou très petits, il est possible d'utiliser
la notation « scientifique », en ajoutant un |e| suivi de l'exposant
du nombre :

>> 2.998e8

Ce qui donne 2.998 * 10^8 = 299800000.

Les opérations avec des nombres sans virgule (aussi appelés nombres entiers)
tenant en 52 bits sont garanties d'être toujours précis. Malheureusement,
les opérations avec des nombres fractionnels ne le sont généralement
pas. Tout comme π (pi) qui ne peut être exprimé de manière précise
par un nombre fini de chiffres à décimales, beaucoup de nombres perdent en
précision lorsqu'on ne dispose que de 64 bits pour les stocker. C'est dommage,
mais cela ne crée de problèmes pratiques que dans des situations très
spécifiques. Le plus important est d'en être conscient et de considérer
les nombres fractionnels décimaux comme des approximations et non des
valeurs précises.

---

On utilise les nombres principalement en arithmétique. Les opérations
arithmétiques, comme l'addition ou la multiplication prennent deux valeurs
de type |number| pour créer un nouveau nombre. Voici ce que cela donne
en JavaScript :

>> 100 + 4 * 11

Les symboles _|+|_ et _|*|_ sont appelés des opérateurs. Le premier
correspond à l'addition et le second à la multiplication. Placer un
opérateur entre deux valeurs le fera s'appliquer @_applying_ à ces deux
valeurs et produire une nouvelle valeur.

L'exemple veut-il dire « ajouter 4 et 100 puis multiplier le résultat par
11 », ou la multiplication est-elle effectuée avant l'addition ? Comme
vous l'avez probablement deviné, la multiplication a lieu en premier. Mais
comme en mathématiques, cela peut être modifié en entourant l'addition
de parenthèses@_|()|_ :

>> (100 + 4) * 11

Pour la soustraction, il y a l'opérateur _|-|_, et la division peut être
effectuée avec _|/|_. Lorsque des opérateurs apparaissent ensemble sans
parenthèses, l'ordre dans lequel ils sont appliqués est déterminé par la
_priorité_ des opérateurs. Le premier exemple montre que la multiplication
a une priorité plus forte que l'addition. La division et la multiplication
viennent toujours avant la soustraction et l'addition. Lorsque plusieurs
opérateurs ayant la même priorité se suivent (|1 - 1 + 1|) ils sont
appliqués de gauche à droite.

Essayez de trouver la valeur que produit cette opération, puis exécutez-la
en console pour voir si vous aviez raison…

>> 115 * 4 - 4 + 88 / 2

Vous ne devriez pas avoir à vous inquiéter de ces règles de priorité. En
cas de doute, ajoutez simplement des parenthèses.

Il y a encore un opérateur arithmétique qui vous est sûrement moins
familier. Le symbole _|%|_ est utilisé pour représenter l'opération
_modulo_. |X| modulo |Y| est le reste de la division de |X| par |Y|. Par
exemple |314 % 100| vaut |14|, |10 % 3| vaut |1| et |144 % 12| vaut |0|. Modulo
a le même ordre de priorité que la multiplication et la division.

---

Le type de données suivant est la chaîne de caractères. Elle est nommée
« _string_ » en anglais et donc en JavaScript. Son utilisation n'est pas
aussi évidente à deviner d'après son nom que pour « number », mais
elle remplit également un rôle très basique. Les chaînes de caractères
sont utilisées pour représenter du texte, le nom est censé venir du fait
qu'il enchaîne un groupe de caractères ensemble. Les chaînes de caractères
sont écrites en insérant leur contenu entre des guillemets :

>> "Colmater mon bateau avec du chewing-gum."

On peut mettre pratiquement tout ce qu'on veut entre des guillemets et
le JavaScript fera la conversion en une valeur de type |string|. Mais pour
certains caractères c'est un peu tordu. Vous pouvez imaginer à quel point il
est délicat de mettre des guillemets entre guillemets. Les sauts de lignes
@_newline_, comme vous en faites en appuyant sur Entrée, ne peuvent pas
non plus être mis entre guillemets, la chaîne doit tenir sur une seule ligne.

Pour mettre de tels caractères dans une chaîne, on emploie l'astuce
suivante : à chaque fois qu'on trouve un antislash (« |\| ») dans
un texte entre guillemets, cela signifie que le caractère qui le suit
a une signification particulière. Un guillemet qui est précédé d'un
antislash n'achèvera pas la chaîne mais en fera partie. Quand le caractère
« |n| » se trouve derrière l'antislash, il est interprété comme un
saut de ligne. De même, un « |t| » derrière un antislash signifie
un caractère de tabulation##.

## Lorsque vous entrez des chaînes de caractères dans la console, vous
pouvez remarquer qu'elles reviennent avec des guillemets et des antislashs
de la même manière que vous les aviez saisies. Pour obtenir un affichage
convenable des caractères spéciaux, vous pouvez faire |print("a\nb")|
— nous verrons pourquoi cela fonctionne dans quelques instants.

>> "Voici une première ligne\nEt maintenant la seconde"

Il existe bien entendu des cas où vous voudrez que l'antislash dans une
chaîne soit juste un antislash et pas un caractère d'échappement. Si
deux antislashs se succèdent, ils vont se combiner et seul l'un d'eux sera
conservé dans la chaîne résultante :

>> "Un caractère de saut de ligne est écrit ainsi \"\\n\"."

---

Les chaînes ne peuvent être divisées, multipliées ou
soustraites. L'opérateur _|+|_ *peut* être utilisé avec des chaînes. Il
n'ajoute rien au sens mathématique mais concatène les chaînes, il les
colle ensemble.

>> "con" + "cat" + "é" + "ner"

Il existe bien d'autres outils pour manipuler des chaînes de caractères,
nous les exposerons par la suite.

---

Tous les opérateurs ne sont pas des symboles. Certains sont écrits sous
forme de mots. Par exemple l'opérateur _|typeof|_ qui renvoie une chaîne
de caractères spécifiant le type d'une valeur.

>> typeof 4.5

Les autres opérateurs que nous avons vus opèrent toujours sur deux valeurs,
|typeof| sur une seul. Les opérateurs qui utilisent deux valeurs sont appelés
des _opérateurs binaires_ alors que ceux qui n'en n'utilisent qu'une sont
des _opérateurs unaires_. Le @_|-|_signe moins peut être utilisé aussi
bien comme un opérateur binaire que comme un unaire :

>> - (10 - 2)

---

Il existe enfin des valeurs de type _booléen_. Il n'en existe que deux :
_|true|_ pour vrai et _|false|_ pour faux. Voici un moyen de produire une
valeur |true| :

>> 3 > 2

Et on peut produire |false| comme ceci :

>> 3 < 2

J'espère que vous connaissiez déjà les signes _|>|_ et _|<|_. Ils
signifient, respectivement, « plus grand que » et « plus petit
que ». Ce sont des opérateurs binaires et le résultat de leur application
est une valeur booléenne qui indique dans ce cas si l'expression est
vérifiée ou non.

On peut comparer des chaînes de la même façon :

>> "Aardvark" < "Zoroaster"

Le classement des chaînes suit plus ou moins l'ordre alphabétique. Plus
ou moins parce que… les lettres majuscules sont toujours « plus petites
que » les minuscules, donc |"Z" < "a"| (« Z » en majuscule, « a » en
minuscule) vaut |true| et les caractères non alphabétiques (« |!| »,
« |@| », etc.) sont également inclus dans ce classement. Le véritable
principe sur lequel repose la comparaison est le standard _Unicode_. Ce
dernier assigne un nombre à potentiellement tout caractère dont on peut
avoir besoin, y compris les caractères spéciaux de langues comme le grec,
l'arabe, le japonais, le tamoul, etc. Disposer de tels nombres est bien
pratique pour stocker des chaînes de caractères dans un ordinateur --
vous pouvez les représenter comme une série de nombres. En comparant les
chaînes, le JavaScript se contente de comparer les nombres associés aux
caractères dans la chaîne, de gauche à droite.

Voici d'autres opérateurs du même genre : _|>=|_ (« supérieur ou
égal à »), |<=|_ (« inférieur ou égal à »), _|==|_ (« égal
à »), et _|!=|_ (« n'est pas égal à »).

>> "Itchy" != "Scratchy"

>> 5e2 == 500

---

Il existe également des opérations très utiles qui peuvent être appliquées
aux valeurs booléennes elles-mêmes. JavaScript prend en charge trois
opérateurs logiques : *et*, *ou* et *non*, que l'on peut utiliser pour
des opérations logiques sur les booléens.

L'opérateur _|&&|_ représente le *et* logique. C'est un opérateur binaire
dont le résultat est |true| seulement si les deux valeurs qu'on lui donne
sont |true|.

>> true && false

_||||_ est le *ou* logique, qui vaut |true| si l'une ou l'autre des valeurs
qu'on lui attribue est |true| :

>> true || false

*Non* s'écrit avec un point d'exclamation : _|!|_, c'est un opérateur
unaire qui inverse la valeur qu'on lui attribue, |!true| devient |false|
et |!false| signifie |true|.

***

>> ((4 >= 6) || ("herbe" != "verte")) &&
>>   !(((12 * 2) == 144) && true)

Est-ce vrai (|true|) ? Pour une meilleure lisibilité, on peut se séparer
d'un grand nombre de parenthèses inutiles ici. Cette version, plus simple,
signifie la même chose :

>> (4 >= 6 || "herbe" != "verte") &&
>>   !(12 * 2 == 144 && true)

///

Oui, l'expression vaut bien |true|. Vous pouvez la décomposer étape par
étape comme ceci :

>> (false || true) && !(false && true)

>> true && !false

>> true

J'espère que vous avez remarqué que |"herbe" != "verte"| est |true|. L'herbe
est peut-être verte, mais elle n'est pas égale à "verte".

---

Il n'est pas toujours évident de savoir si des parenthères sont
nécessaires. En pratique, on peut généralement s'en sortir en sachant que
parmi tous les opérateurs rencontrés, |||| a la priorité la plus basse,
viennent ensuite, dans l'ordre, |&&| puis les opérateurs de comparaisons
(|>|, |==|, etc.) et enfin tout le reste. Ceci a été déterminé de telle
sorte que, dans les cas simples, on ne doive utiliser les parenthèses que
si elles sont strictement nécessaires.

---

Les exemples rencontrés jusqu'à présent utilisent le langage JavaScript
de la même façon que l'on se sert d'une calculatrice de poche. Utiliser des
valeurs et leur appliquer des opérateurs pour obtenir d'autres valeurs. Créer
de telles valeurs est une partie essentielle de chaque programme JavaScript,
mais ce n'en est qu'une partie. Un bout de code qui produit une valeur
s'appelle une _expression_. Chaque valeur écrite directement (telle que |22|
ou |"psychanalyse"|) est une expression. Une expression entre parenthèses
est également une expression. Un opérateur binaire appliqué à deux
expressions, ou un opérateur unaire appliqué à une seule expression est
également une expression.

Il existe quelques autres moyens de construire des expressions, qui seront
dévoilés lorsque le moment sera venu.

Il existe une unité plus grande que l'expression. On l'appelle
_instruction_. Un programme est une suite d'instructions. La plupart des
instructions se terminent par un _point-virgule_ (|;|). La forme la plus
simple d'une instruction est une expression avec un point-virgule après. Voici
un programme :

> 1;
> !false;

Ce programme est inutile. Une expression peut se contenter de produire une
valeur, mais une instruction ne vaudra quelque chose que si elle change un
peu le monde. Elle peut imprimer quelque chose à l'écran -- ce qui compte
comme un changement du monde -- ou elle peut modifier l'état interne du
programme de telle sorte que cela affecte les instructions qui suivent. Ces
modifications sont appelées « _effets de bord_ ». Les instructions de
l'exemple ci-dessus ne renvoient que les valeurs |1| et |true| puis les
jettent au récupérateur de bits##. Ceci ne laisse aucune trace dans ce
monde et ça n'a aucun effet de bord.

## Le récupérateur de bits est l'endroit où sont supposés être stockés
les vieux bits. Sur certains systèmes, les programmeurs doivent le vider
manuellement de temps en temps. Heureusement, JavaScript est fourni avec un
système automatique de recyclage des bits.

---

Comment un programme conserve-t-il un état interne ? Comment se rappelle-t-il
les choses ? Nous avons vu de quelle façon créer de nouvelles valeurs
à partir de vieilles valeurs, mais cela ne modifie pas les valeurs de
celles-ci, et la nouvelle valeur doit être utilisée immédiatement ou
elle disparaîtra. Pour « attraper » et conserver des valeurs, JavaScript
fournit un mécanisme appelé la _variable_.

> var caught = 5 * 5;

Une variable possède toujours un nom et elle peut pointer vers une valeur et
la conserver. L'instruction ci-dessus crée une variable appelée |caught|
et l'utilise pour conserver le nombre produit par la multiplication de |5|
par |5|.

Après avoir exécuté le programme ci-dessus, vous pouvez entrer le mot
|caught| dans la console et cela ressortira la valeur |25| à votre place. Le
nom d'une variable est utilisé pour récupérer sa valeur. |caught + 1|
fonctionne également. Un nom de variable peut être utilisé comme expression
et ainsi faire partie de plus grandes expressions.

Le mot-clé _|var|_ est utilisé pour créer des variables. Le nom de la
variable suit |var|. Les noms de variable peuvent être à peu près n'importe
quel mot, mais ils ne peuvent pas contenir d'espaces. Les chiffres peuvent
faire partie du nom de variable, |catch22| est un nom valide, mais le nom
ne doit pas commencer par un chiffre. Les caractères « |$| » et « |_|
» peuvent être utilisés dans les noms comme s'ils étaient des lettres,
ainsi |$_$| est un nom de variable correct.

Si vous souhaitez que la nouvelle variable contienne tout de suite une
valeur, comme c'est souvent le cas, vous pouvez utiliser l'opérateur _|=|_
pour lui affecter la valeur d'une expression.

Si une variable pointe vers une valeur, cela ne veut pas dire qu'elles sont
liées pour toujours. Vous pouvez utiliser l'opérateur |=| à tout moment
sur une variable existante pour lui enlever sa valeur actuelle et la faire
pointer sur une nouvelle valeur.

> caught = 4 * 4;

---

Il est préférable d'imaginer les variables comme des tentacules plutôt
que comme des boîtes. Elles ne *contiennent* pas de valeurs, elles
s'en *saisissent* (et deux variables peuvent se référer à la même
valeur). Seules les valeurs qui sont encore retenues par le programme lui
sont accessibles. Quand vous avez besoin de vous souvenir de quelque chose,
vous dressez un tentacule pour l'accrocher fermement ou enserrez une nouvelle
valeur dans un tentacule existant : pour vous souvenir de la somme en
dollars que Luigi vous doit encore, vous pouvez faire :

> var detteLuigi = 140;

Puis, à chaque fois que Luigi vous rembourse quelque chose, ce montant peut
être décrémenté en allouant un nouveau nombre à la variable :

> detteLuigi = detteLuigi - 35;

L'ensemble des variables et de leurs valeurs à un moment donné s'appelle
l'_environnement_. Quand le programme se lance, cet environnement n'est pas
vide. Il contient toujours un certain nombre de variables standards. Quand
votre navigateur charge une nouvelle page, il crée un nouvel environnement
et lui affecte les valeurs standards. Les variables créées et modifiées
par les programmes d'une page sont conservées jusqu'à ce que le navigateur
aille sur une nouvelle page.

---

Beaucoup de valeurs fournies par l'environnement standard sont de type
« _function_ ». Une fonction est une partie de programme contenue dans
une valeur.
Généralement, cette portion de programme fait quelque chose d'utile qui
peut être invoqué en utilisant le nom défini pour la fonction. Dans un
navigateur, la variable _|alert|_ est reliée à une fonction qui ouvre une
petite fenêtre avec un message. Elle s'utilise comme ceci :

> alert("De plus, vos cheveux sont en feu.");

@_|()|_Quand on exécute le code d'une fonction, on dit qu'on l'_invoque_ ou
qu'on l'_appelle_. La notation pour faire ça utilise des parenthèses. Chaque
expression qui produit une valeur peut être invoquée en utilisant des
parenthèses après son nom. La chaîne de caractères entre parenthèses est
donnée à la fonction qui l'utilise en tant que texte pour l'afficher dans la
fenêtre. Les valeurs données aux fonctions sont appelées _paramètre_s ou
_argument_s. |alert| en a juste besoin d'un, mais d'autres fonctions peuvent
en vouloir plus.

---

Afficher une fenêtre de dialogue est un effet de bord. Beaucoup de fonctions
sont utiles par leurs effets de bord. Une fonction peut aussi produire une
valeur et dans ce cas elle n'a pas besoin de produire un effet de bord pour
être utile. Par exemple, il existe une fonction _|Math.max|_, qui prend
deux arguments et retourne le plus grand des deux :

> alert(Math.max(2, 4));

@_|Math.min|_Quand une fonction produit une valeur, on dit qu'elle
la _retourne_. Parce qu'il n'y a que les expressions qui produisent des
valeurs, les appels de fonctions peuvent être utilisés comme une partie
d'une expression plus longue :

> alert(Math.min(2, 4) + 100);

Nous examinerons dans le \\cfunctions la façon de créer vos propres fonctions.

---

Comme l'a montré l'exemple précédent, |alert| peut être utile pour
montrer le résultat de certaines expressions. Mais cliquer pour fermer
toutes ces petites fenêtres peut devenir très vite énervant, donc à partir
de maintenant nous allons plutôt utiliser une fonction similaire appellée
_|print|_ qui ne fait pas apparaître de fenêtre, mais écrit juste une valeur
dans la zone de sortie de la console. |print| n'est pas une fonction standard
du JavaScript, les navigateurs ne la fournissent pas, mais il est possible
de l'utiliser dans ce livre, donc vous pouvez l'utiliser sur ces pages.

> print("N");

Une fonction similaire également disponible sur ces pages est |show|. Alors
que |print| affichera son argument en texte brut, _|show|_ essayera de
l'afficher de la même manière qu'un programme le ferait. Ce qui signifie
qu'il donnera plus d'information sur le type de la valeur. Par exemple,
les chaînes de caractères garderont leurs guillemets, en utilisant |show|:

> show("N");

L'environnement standard fourni par les navigateurs contient quelques fonctions
supplémentaires pour faire apparaître des fenêtres. Vous pouvez poser une
question à l'utilisateur en lui demandant de répondre par « Oui »
ou « Non », en utilisant la fonction prédéfinie _|confirm|_. Elle
retourne un booléen, |true| si l'utilisateur choisit « Oui » et |false|
si l'utilisateur choisit « Non ».

> show(confirm("Continuons-nous ?"));

_|prompt|_ peut être utilisé pour poser une question « ouverte ». Le
premier argument est la question, le deuxième est le texte par défaut,
proposé comme la réponse de l'utilisateur.
Une ligne de texte peut alors être tapée dans la case de texte de la
fenêtre et la fonction la retournera comme une chaîne de caractères.

> show(prompt("Dîtes-nous tout ce que vous savez.", "..."));

---

Dans l'environnement, il est possible de donner une nouvelle valeur à
presque toutes les variables. Ça peut être utile mais aussi dangereux. Si
vous donnez la valeur |8| à |print|, vous ne pourrez plus jamais rien
afficher. Heureusement, il y a un bouton « Réinitialiser » sur la
console, qui réinitialise totalement l'environnement.

---

Des programmes d'une ligne ne sont pas très intéressant. Quand vous mettez
plus d'une instruction dans un programme ces dernières sont, comme on peut
s'en douter, exécutées une à la fois de haut en bas.

> var leNombre = Number(prompt("Choissisez un nombre", ""));
> print("Votre nombre est la racine carrée de " +
>       (leNombre * leNombre));

La fonction _|Number|_ converti une valeur en un nombre, ce qui est
nécessaire dans notre cas parce que le résultat de |prompt| est une chaîne
de caractères. Il existe des fonctions similaires appelées _|String|_
et _|Boolean|_ qui convertissent des valeurs dans ces types.

---

Considérons un programme qui affiche tous les nombres pairs de 0 à 12. Une
façon de le faire est d'écrire :

> print(0);
> print(2);
> print(4);
> print(6);
> print(8);
> print(10);
> print(12);

Ça marche mais lorsqu'on écrit un programme l'idée est de nous faire faire
*moins* de travail et non pas plus. Si nous avions besoin des nombres pairs
jusqu'à 100 cette méthode deviendrait tout simplement inexploitable. Nous
avons besoin d'une manière de répéter une portion de code automatiquement.

> var nombreCourant = 0;
> while (nombreCourant <= 12) {
>   print(nombreCourant);
>   nombreCourant = nombreCourant + 2;
> }

Vous avez sûrement vu dans l'introduction le mot _|while|_. Une instruction
démarrant par |while| crée une _boucle_. Une boucle est une perturbation
dans la séquence des instructions, il fera répéter plusieurs fois
au programme une séquence de code. Dans notre cas le mot |while| est
suivi par une expression entre parenthèse (les parenthèses étant
obligatoires) qui détermine si la boucle continue à s'exécuter ou si
elle doit s'arrêter. Aussi longtemps que la valeur booléenne produite
par cette exression est |true|, le code à l'intérieur de la boucle est
répété. Dès qu'elle devient |false| le programme se place à la fin de
la boucle et reprend à la normale.

La variable |nombreCourant| montre la façon dont une variable peut suivre
la progression d'un programme. À chaque fois que la boucle est répétée
la variable est incrémentée de |2| et à chaque début elle est comparée
au nombre |12| pour décider si la boucle continue ou non.

La troisième partie d'une instruction |while| est une autre instruction. C'est
le _corps_ de la boucle qui contient les actions qui doivent se reproduire
plusieurs fois. Si nous ne devions pas afficher les nombres le programme
aurait pu être :

> var nombreCourant = 0;
> while (nombreCourant <= 12)
>   nombreCourant = nombreCourant + 2;

Ici |nombreCourant = nombreCourant + 2;| est l'instruction qui forme le corps
de la boucle. Mais nous devons aussi afficher le nombre, donc la boucle sera
consituée d'une instruction supplémentaire.
Les@_|{}|_accolades (|{| et |}|) sont utilisées pour grouper des instructions
dans des _bloc_s. Pour le reste du code un bloc compte comme une seule et
même instruction. Dans l'exemple précédant ceci est utilisé pour inclure
dans la boucle à la fois l'appel à la fonction |print| et l'instruction
qui actualise la variable |nombreCourant|.

*** power2

Utilisez cette technique pour écrire un programme qui calcule et affiche la
valeur de 2^10 (2 à la puissance 10). Vous n'êtes bien sûr pas autorisé
à tricher en écrivant juste |2 * 2 * ...|.

Si vous avez des problèmes avec ça, essayez de comparer avec l'exemple
des nombres pairs. Le programme doit exécuter une action un certain nombre
de fois. Pour cela, on peut utiliser une variable compteur avec une boucle
|while|. À la place d'afficher le compteur, le programme doit multiplier
quelque chose par deux. Ce quelque chose doit être une variable dans laquelle
le résultat sera construit.

Ne vous inquiétez pas si vous ne voyez pas tout de suite comment cela peut
fonctionner. Même si vous comprenez parfaitement tous les concepts de ce
chapitre, il peut être dur de les appliquer à des problèmes concrets. Lire
et écrire du code vous aidera à développer votre sensibilité pour
ça. Donc, étudiez la solution, et essayez le prochain exercice.

///

> var resultat = 1;
> var compteur = 0;
> while (compteur < 10) {
>   resultat = resultat * 2;
>   compteur = compteur + 1;
> }
> show(resultat);

Le compteur peut aussi commencer à |1| et être vérifié pour |<= 10|,
mais pour des raisons que nous vous exposeront après il est préférable
de commencer à compter depuis 0.

Évidemment vos solutions n'ont pas à être exactement identiques aux
miennes. Elles doivent fonctionner. Et dans le cas où elles seraient très
différentes, assurez-vous d'avoir compris la mienne.

***

Avec quelques petites modifications, la solution à l'exercice précédent
peut être utilisée pour tracer un triangle. Et quand je dis « tracer
un triangle », je veux dire « afficher du texte qui ressemble presque
à un triangle quand on louche ».

Affichez dix lignes. Sur la première, mettez un « # ». Sur la deuxième
en mettez-en deux, et ainsi de suite.

Comment avoir une chaîne composée de X « # » ? Une solution est de
la construire avec une « boucle imbriquée », c'est à dire une boucle
dans une bloucle. Une méthode plus simple est de réutiliser la chaîne de
la précédente itération, et d'y ajouter un caractère.

///

> var ligne = "";
> var compteur = 0;
> while (compteur < 10) {
>   ligne = ligne + "#";
>   print(ligne);
>   compteur = compteur + 1;
> }

---

Vous remarquerez les espaces que j'ai mis devant certaines instructions. Ils
ne sont pas nécessaires : l'ordinateur accepte très bien un programme
sans ces espaces. En fait, même les retours à la ligne sont facultatifs.

Vous pouvez les écrire sur une seule longue ligne si cela vous fait
plaisir. Le rôle de l'_indentation_ dans les blocs est de construire la
structure du code de manière plus claire et lisible pour les humains. Parce
qu'on peut créer un nouveau bloc dans un autre et il peut alors devenir
difficile de voir où un bloc finit et où un autre commence dans des parties
complexes de code. Quand les lignes sont indentées, la forme visuelle du
code correspond à la forme des blocs. Je préfère utiliser deux espaces
pour chaque nouveau bloc, mais les goûts varient.

Le champ dans la console où vous pouvez taper des programmes ajoutera
automatiquement ces espaces. Ça peut sembler pénible au début, mais
quand vous écrirez beaucoup de code, vous verrez que c'est un gain de
temps important. Appuyer sur la touche « tab » réindentra la ligne
sur laquelle est le curseur.

Dans quelques cas, le JavaScript vous autorise à omettre le point-virgule en
fin d'instruction. Dans d'autres cas, il faut le mettre sans quoi des choses
étranges se produiront. Les règles définissant quand on peut les oublier
sont complexes et particulières. Dans ce livre, je ne les enlèverai jamais
et je vous conseille vivement de faire pareil pour vos propres programmes.

---

L'utilisation de |while| que nous avons vu plus haut suit toujours le même
modèle. Premièrement une variable « compteur » est créée. Elle
tracera la progression dans la boucle. L'instruction |while| contient
une vérification, généralement pour voir si le compteur a atteint sa
limite. Ensuite, à la fin du corps de la boucle, le compteur est mis à jour.

Beaucoup de boucles obéissent à ce schéma. C'est pour cette raison que
le JavaScript, comme d'autres langages, fournit une forme plus courte et
plus compréhensive :

> for (var nombre = 0; nombre <= 12; nombre = nombre + 2)
>   show(nombre);

Ce code est strictement équivalent à l'exemple précédent qui affichait les
nombres pairs. La seule différence est que toutes les instructions liées
à l'état de la boucle sont maintenant sur une seule ligne. La parenthèse
après le _|for|_ doit contenir deux points-virgules. La première partie
*initialise* la boucle, généralement en définissant une variable. La
deuxième est l'instruction qui *vérifie* l'état de la boucle. Et la
dernière partie *modifie* l'état de la boucle. Dans beaucoup de cas,
cette forme est plus claire et concise qu'une construction avec |while|.

---

J'ai utilisé une _casse_ plutôt bizarre dans certains noms de
variables. Comme vous ne pouvez pas utiliser d'espace dans ces noms —
l'ordinateur les lirait comme deux variables distinctes — vos choix pour
un nom composé de plusieurs mots sont plus ou moins limités aux solutions
suivantes : |petitpandaroux|, |petit_panda_roux|, |PetitPandaRoux|
ou |petitPandaRoux|. Le premier est difficile à lire. Personnellement,
j'aime celui avec les tirets bas, bien que ce soit un peu pénible à
taper. Toutefois, les fonctions JavaScript standards, et la plupart des
programmeurs JavaScript, suivent la dernière syntaxe. Il n'est pas compliqué
de s'habituer à ce genre de petites choses, alors je vais simplement suivre
la majorité et mettre une majuscule à la première lettre de chaque mot
excepté le premier.

Dans quelques cas, comme dans la fonction |Number|, la première lettre d'une
variable est également en majuscule. Cela a été défini pour marquer cette
fonction comme étant un constructeur. Ce qu'est un constructeur deviendra
clair dans le \\coo. Pour l'instant, l'important est de ne pas se soucier
de cet apparent manque de cohérence.

Notez que les noms ayant une signification spéciale tels que |var|, |while|
et |for| ne peuvent pas être utilisés en tant que noms de variables. Ils
sont appelés _mots-clés_. Il y a également un certain nombre de @_mot
réservé_mots qui sont « réservés pour l'utilisation » dans de futures
versions de JavaScript. Ceux-ci ne sont également officiellement pas
autorisés à être utilisés comme noms de variables, bien que certains
navigateurs les autorisent. La liste complète est assez longue :

] abstract boolean break byte case catch char class const continue
] debugger default delete do double else enum export extends false
] final finally float for function goto if implements import in
] instanceof int interface long native new null package private
] protected public return short static super switch synchronized
] this throw throws transient true try typeof var void volatile
] while with

Ne vous souciez pas de les mémoriser pour le moment, mais souvenez-vous
qu'ils peuvent être la cause d'un problème lorsque quelque chose ne
fonctionne pas comme prévu. D'après mon expérience, |char| (pour stocker
une chaîne d'un seul caractère) et _|class|_ sont les noms d'utilisation
incorrecte les plus communs.

***

Réécrivez les solutions des deux exercices précédents en utilisant |for|
à la place de |while|.

///

> var resultat = 1;
> for (var compteur = 0; compteur < 10; compteur = compteur + 1)
>   resultat = resultat * 2;
> show(compteur);

Notez que même s'il n'y a pas de bloc ouvert avec une « |{| », l'instruction
dans la boucle est toujours indentée avec deux espaces pour bien spécifier
son « appartenance » à la ligne du dessus.

> var ligne = "";
> for (var compteur = 0; compteur < 10; compteur = compteur + 1) {
>   ligne = ligne + "#";
>   print(ligne);
> }

---

@_|+=|_@_|-=|_@_|/=|_@_|*=|_Un programme a souvent besoin « d'actualiser »
une variable avec une valeur basée sur sa valeur précédente. Par exemple
|compteur = compteur + 1|. JavaScript fournit un raccourci pour cela :
|compteur += 1|. Ça fonctionne également pour beaucoup d'autres opérateurs,
par exemple |resultat *= 2| pour doubler la valeur de |resultat|, ou |compteur
-= 1| pour compter à rebours.

@_|++|_@_|--|_Pour |compteur += 1| et |compteur -= 1|, il existe même des
versions abrégées : |compteur++| et |compteur--|.

---

On dit que les boucles affectent le _flux d'exécution_ d'un programme. Elles
changent l'ordre dans lequel les instructions sont exécutées. Dans de
nombreux cas, un autre type de flux est utile : les instructions de sauts.

Nous voulons afficher tous les nombres en dessous de 20 qui sont divisibles
à la fois par 3 et par 4.

> for (var compteur = 0; compteur < 20; compteur++) {
>   if (compteur % 3 == 0 && compteur % 4 == 0)
>     show(compteur);
> }

Le mot-clé _|if|_ n'est pas très différent du mot-clé |while| :
il vérifie la condition qu'on lui donne (entre parenthèses) et exécute
l'instruction suivante en fonction de cette condition. Mais il ne fait cela
qu'une seule fois, donc l'instruction est exécutée zéro ou une fois.

L'astuce avec l'opérateur modulo (_|%|_) est une manière simple de tester
si un nombre est divisible par un autre nombre. S'il l'est, le reste de leur
division, qui est ce que modulo produit, est zéro.

Si nous avions voulu afficher tous les nombres en dessous de 20, mais en
affichant entre parenthèses ceux n'étant pas divisibles par 4, nous aurions
pu le faire de cette façon :

> for (var compteur = 0; compteur < 20; compteur++) {
>   if (compteur % 4 == 0)
>     print(compteur);
>   if (compteur % 4 != 0)
>     print("(" + compteur + ")");
> }

Mais maintenant le programme doit déterminer si |compteur| est divisible par
|4| deux fois. Le même effet peut être obtenu en ajoutant une partie |else|
(« sinon ») après l'instruction |if|. L'instruction _|else|_ est exécutée
seulement lorsque la condition |if| est fausse.

> for (var compteur = 0; compteur < 20; compteur++) {
>   if (compteur % 4 == 0)
>     print(compteur);
>   else
>     print("(" + compteur + ")");
> }

Pour aller plus loin avec cet exemple trivial, nous voulons maintenant
afficher ces mêmes nombres tout en leur ajoutant deux étoiles lorsqu'ils
sont plus grands que 15, une étoile lorsqu'ils sont plus grands que 10
(mais pas plus grands que 15), et aucune étoile dans les autres cas.

> for (var compteur = 0; compteur < 20; compteur++) {
>   if (compteur > 15)
>     print(compteur + "**");
>   else if (compteur > 10)
>     print(compteur + "*");
>   else
>     print(compteur);
> }

Cela montre que vous pouvez enchaîner des instructions |if|. Dans ce cas,
le programme regarde d'abord si |compteur| est plus grand que |15|. Si
c'est le cas, les deux étoiles sont affichées et les autres tests sont
ignorés. Si ce n'est pas le cas, on continue à vérifier si la valeur
est supérieure à |10|. Et on n'arrive à la dernière instruction |print|
que si |compteur| n'est pas supérieur à |10|.

***

Écrivez un programme qui vous demandera, en utilisant |prompt|, quelle
est la valeur de 2 + 2. Si la réponse est « 4 », utilisez |alert| pour
afficher un message sympa. Si c'est « 3 » ou « 5 », affichez « Ça y
était presque ! ». Dans les autres cas, n'hésitez pas à dire quelque
chose de méchant.

///

> var reponse = prompt("Hé vous ! Quelle est la valeur de 2 + 2 ?", "");
> if (reponse == "4")
>   alert("Vous êtes un vrai génie !");
> else if (reponse == "3" || reponse == "5")
>   alert("Ça y était presque !");
> else
>   alert("Vous êtes nul !");

---

Lorsqu'une boucle n'a pas systématiquement besoin d'aller jusqu'au bout
de ses instructions, le mot-clé _|break|_ peut être utile. Il permet de
sortir de la boucle et d'exécuter les instructions suivantes. Ce programme
trouve le premier nombre supérieur à 20 et divisible par 7 :

> for (var courant = 20; ; courant++) {
>   if (courant % 7 == 0)
>     break;
> }
> print(courant);

La structure |for| n'a pas de mécanisme qui vérifie quand terminer la
boucle. Cela signifie qu'elle est dépendante de l'instruction |break| qui
est à l'intérieur pour pouvoir s'arrêter. Le même programme aurait pu
s'écrire aussi simplement…

> for (var current = 20; current % 7 != 0; current++)
>   ;
> print(current);

Dans ce cas, le corps de la boucle est vide. Un point-virgule isolé peut
être utilisé pour produire une instruction vide. Ici, le seul effet de la
boucle est d'incrémenter la variable |courant| à la valeur voulue. Mais
j'avais besoin d'un exemple utilisant |break|, donc prêtez également
attention à la première version.

***

Ajoutez un |while|, et optionnellement un |break|, à votre solution du
précédent exercice, afin qu'il continue à répéter la question jusqu'à
ce qu'une réponse correcte soit donnée.

Notez que |while (true) …| peut être utilisé pour créer une boucle qui
ne s'arrêtera pas d'elle-même. C'est un peu ridicule, vous demandez au
programme de boucler tant que |true| est |true|, mais c'est une astuce utile.

///

> var reponse;
> while (true) {
>   reponse = prompt("Hé vous ! Quelle est la valeur de 2 + 2 ?", "");
>   if (reponse == "4") {
>     alert("Vous êtes un vrai génie !");
>     break;
>   }
>   else if (reponse == "3" || reponse == "5") {
>     alert("Ça y était presque !");
>   }
>   else {
>     alert("Vous êtes nul !");
>   }
> }

Parce que le corps du premier |if| a deux instructions, j'ai ajouté des
accolades autour de tous les corps de |if|. C'est une question de goût. Avoir
une chaîne |if|/|else| où certains corps sont des blocs et d'autres des
instructions simples me semble un peu bancal. Mais je vous laisse vous faire
votre propre opinion à ce propos.

Une autre solution, probablement meilleure mais sans |break|, est la suivante :

> var valeur = null;
> while (valeur != "4") {
>   valeur = prompt("Hé vous ! Quelle est la valeur de 2 + 2 ?", "");
>   if (valeur == "4")
>     alert("Vous êtes un vrai génie !");
>   else if (valeur == "3" || valeur == "5")
>     alert("Ça y était presque !");
>   else
>     alert("Vous êtes nul !");
> }

---

Dans la solution de l'exercice précédent il y a une instruction |var
answer;|. Elle crée une variable appelée |answer|, mais ne lui donne pas de
valeur. Que se passe-t'il alors lorsqu'on prend la valeur de cette variable ?

> var variableMystere;
> show(variableMystere);

En termes de tentacules, cette variable se termine dans les airs, elle ne
s'accroche à rien. Quand vous demandez la valeur d'une variable vide, vous
obtenez une réponse spéciale appelée _|undefined|_. Les fonctions qui ne
retournent pas de valeur convenable, comme |print| et |alert|, retournent
la valeur |undefined|.

> show(alert("Je suis un effet de bord."));

Il y a aussi une valeur similaire, _|null|_, qui signifie que « cette
variable est définie mais qu'elle n'a pas de valeur ». La différence entre
|undefined| et |null| est principalement académique, et la majeure partie du
temps sans intérêt. Dans la pratique, il est souvent nécessaire de vérifier
si quelque chose possède une valeur. Dans ce cas, l'expression |quelqueChose
== undefined| peut être utilisée, parce que même si ces deux valeurs ne
sont pas strictement équivalentes, |null == undefined| retournera |true|.

---

Ceci nous amène vers un autre sujet un peu plus délicat…

> show(false == 0);
> show("" == 0);
> show("5" == 5);

@_conversion de type_Toutes ces expressions retournent |true|. Quand on
compare des valeurs de différents types, JavaScript utilise un ensemble de
règles complexes et déroutantes. Je ne vais pas essayer de les expliquer
précisément. Dans beaucoup de cas, il essayera juste de convertir une
des variables dans le type de l'autre variable. Cependant, quand |null| ou
|undefined| apparaît, il produira |true| seulement si les deux sont |null|
ou |undefined|.

Que faire si vous voulez tester si une variable se réfère à la valeur
|false| ? La règle pour convertir des chaînes et des nombres en valeurs
booléennes est que |0| et la chaîne vide sont considérés comme |false|,
alors que toutes les autres valeurs comptent pour |true|. À cause de ça,
l'expression |variable == false| est également |true| quand |variable|
se réfère à |0| ou à |""|. Pour des cas comme celui-ci, où vous ne
voulez *aucune* conversion automatique de types, il existe deux nouveaux
opérateurs : _|===|_ et _|!==|_. Le premier teste si une valeur est
précisément égale à l'autre. Le deuxième teste s'ils ne sont pas
précisément égaux.

> show(null === undefined);
> show(false === 0);
> show("" === 0);
> show("5" === 5);

Toutes ces instructions retournent |false|.

---

Les valeurs données comme conditions dans les instructions |if|, |while|, ou
|for| ne doivent pas forcément être booléennes. Elles seront automatiquement
converties en booléen avant d'être vérifiées. Cela signifie que le
nombre |0|, la chaîne vide |""|, |null|, |undefined|, et bien sûr |false|,
compteront comme faux.

Le fait que toutes les autres valeurs soient converties en |true| permet
dans beaucoup de situations d'omettre les comparaisons explicites. Si on
sait qu'une variable contient une chaîne de caractères ou |null|, elle
peut être utilisée pour une vérification de façon très simple…

> var maybeNull = null;
> // …code mystérieux qui pourrait affecter une chaîne à maybeNull…
> if (maybeNull)
>   print("maybeNull possède une valeur");

Notons l'exception où le code mystérieux affecterait la valeur |""| à
|maybeNull|. Une chaîne vide est fausse, donc rien ne sera affiché. Cette
méthode peut donc être *mauvaise*, en fonction de ce que vous voulez
faire. C'est donc souvent une bonne idée d'ajouter |=== null| ou |=== false|
dans des cas comme celui-ci, pour éviter des erreurs subtiles. Ce commentaire
s'applique aussi aux valeurs numériques qui peuvent être égales à |0|.

---

La ligne qui parle du « code mystérieux » dans l'exemple précédent
peut vous sembler un peu étrange. C'est souvent utile pour inclure du texte
supplémentaire dans un programme. On l'utilise le plus souvent pour ajouter
à un programme des explications en langage humain.

> // La variable compteur, qui va être définie, commencera
> // par la valeur 0, c'est-à-dire par zéro.
> var compteur = 0;
> // Maintenant, nous allons créer une boucle.
> while (compteur < 100 /* compteur est inférieur à 100 */)
> /* À chaque fois que l'on boucle, nous incrémentons la valeur du compteur,
>    Vraiment, on ajoute juste un. */
>   compteur++;
> // Puis c'est fini.

Ce type de texte est appelé un _commentaire_. Les règles sont les
suivantes : '|/*|' commence un commentaire qui se termine au prochain
'|*/|'. '|//|' débute un autre type de commentaire qui finit à la fin de
la ligne.

Comme vous pouvez le voir, même les programmes les plus simples peuvent
être faits pour avoir l'air gros, laid et compliqué, simplement en ajoutant
beacuoup de commentaires.

---

Il existe d'autres situations qui provoquent automatiquement une _conversion
de type_. Si vous ajoutez une valeur non chaîne à une chaîne, cette valeur
est automatiquement convertie en chaîne avant d'être concaténée. Si vous
multipliez un nombre et une chaîne, JavaScript essaie de créer un nombre
avec la chaîne.

> show("Apollo" + 5);
> show(null + "ifier");
> show("5" * 5);
> show("fraises" * 5);

La dernière instruction donne pour résultat _|NaN|_, qui est une valeur
particulière. Elle signifie « Pas un nombre » (« Not a Number »)
et elle est de type nombre (ce qui peut sembler légèrement paradoxal). Dans
ce cas, cela signifie  qu'une fraise n'est pas un nombre. Toutes les
opérations arithmétiques sur la valeur |NaN| ont pour résultat |NaN|,
c'est pourquoi en le multipliant par |5| comme dans cet exemple, cela donne
toujours |NaN|. De plus, et c'est parfois assez perturbant, |NaN == NaN|
est égal à |false|, vérifier si une valeur est |NaN| peut être fait
avec la fonction _|isNaN|_. |NaN| est encore (c'est la dernière) une de
ces valeurs qui renvoie |false| quand elle est convertie en booléen.

Ces conversions automatiques peuvent être très pratiques, mais elles sont
aussi plutôt bizarres et sujettes à erreur. Même si |+| et |*| sont tous
deux des opérateurs arithmétiques, ils se comportent de façon complètement
différente dans cet exemple. Dans mon propre code, j'utilise beaucoup |+|
pour combiner les chaînes et les non chaînes, mais notez bien qu'il ne
faut pas utiliser |*| ni les autres opérateurs numériques sur des valeurs
de chaînes. Convertir un nombre en chaîne est toujours possible et simple,
mais convertir une chaîne en nombre peut très bien ne pas marcher du tout
(voir la dernière ligne de l'exemple). Mais nous pouvons utiliser |Number|
pour convertir explicitement la chaîne en nombre, en montrant bien que nous
prenons le risque de nous retrouver devant une valeur |NaN|.

> show(Number("5") * 5);

---

Quand nous parlions des opérateurs booléens |&&| et ||||, je vous avais
dit qu'ils produisent des valeurs booléennes. C'est en fait un peu trop
simplifié. Si vous les appliquez sur des valeurs booléennes, ils retournent
des booléens. Mais ils peuvent aussi s'appliquer à d'autres types de valeurs,
et dans ces cas ils retournent un de leurs arguments.

En fait, ce que _||||_ fait réellement est ceci : il regarde la valeur de
gauche en premier. Si la conversion en booléen produit |true|, il retourne
cette valeur, sinon il retourne le membre de droite. Vérifiez par vous-même
que cela fonctionne correctement avec des arguments booléens. Pourquoi agit-il
comme cela ? Cela s'avère très pratique. Considérons l'exemple suivant :

> var input = prompt("Quel est votre nom ?", "Kilgore Trout");
> print("Bien le bonjour " + (input || "cher ami"));

Si l'utilisateur presse « Annuler » ou ferme la fenêtre de dialogue sans
donner de nom, la variable |input| prendra la valeur |null| ou |""|. Ces deux
donneront |false| en essayant de convertir en booléen. L'expression |input ||
"cher ami"| peut être lue dans ce cas commme « la valeur de la variable
|input|, sinon la chaîne |"cher ami"| ». C'est une manière simple de
fournir une valeur de secours.

L'opérateur _|&&|_ fonctionne sur le même principe mais dans l'autre
sens. Quand la valeur à sa gauche est quelque chose qui donnera |false| en
étant converti en booléen, il retournera cette valeur. Dans l'autre cas,
il retournera la valeur à sa droite.

Une autre propriété de ces deux opérateurs est que l'expression de
droite n'est évaluée que quand c'est nécessaire. Dans le cas |true ||X|,
peu immporte ce qu'est |X|, le résultat sera toujours |true|, donc |X|
n'est jamais évalué, et s'il a des effets de bord, ils ne se produiront
jamais. C'est la même chose pour |false && X|.

> false || alert("Je suis en train de me produire !");
> true || alert("Pas moi.");

=====================
Fonctions / functions
=====================

Un programme doit souvent exécuter la même tâche en différents
endroits. Il est fastidieux de répéter à chaque fois les instructions
nécessaires et c'est un facteur d'erreurs possibles. Il vaudrait mieux
réunir ces instructions au même endroit et demander au programme d'y
faire un détour chaque fois que c'est nécessaire. C'est pour ça qu'on a
inventé les _fonction_s : ce sont des unités de code que le programme
peut parcourir à volonté. Afficher une chaîne à l'écran nécessite un
certain nombre de déclarations, mais si nous disposons d'une fonction |print|
il nous suffit d'écrire |print("Aleph")| et le tour est joué.

Cependant, si on voit les fonctions simplement comme des boîtes de conserve
de code on ne les considére pas à leur juste valeur. Si nécessaire, elles
peuvent jouer les rôles de fonctions pures, d'algorithmes, de détours,
d'abstractions, de moyens de décision, de modules, de prolongements, de
structures de données et de beaucoup d'autres. Être capable d'utiliser
efficacement des fonctions est une compétence nécessaire pour qui veut
programmer sérieusement. Ce chapitre propose une introduction au sujet,
le \\cfp aborde plus en profondeur les subtilités des fonctions.

---

@_fonction pure_Pour commencer, les fonctions pures sont ce que l'on appelait
« fonction » en cours de mathématiques, que vous avez, je l'espère,
suivi à un moment de votre vie. Prendre le cosinus ou la valeur absolue
d'un nombre est une fonction pure à un argument. L'addition est une fonction
pure à deux arguments.

Les propriétés qui définissent les fonctions pures sont qu'elles retournent
toujours la même valeur pour les mêmes arguments et n'ont jamais d'effet
de bord. Elles prennent des arguments, retournent une valeur basée sur ces
arguments, et ne perdent pas leur temps à faire autre chose.

En JavaScript, l'addition est un opérateur, mais elle peut être encapsulée
dans une fonction comme ceci (et aussi inutile que cela puisse sembler,
nous allons rencontrer des situations dans lesquelles ça sera vraiment utile).

> function ajouter(a, b) {
>   return a + b;
> }
>
> show(ajouter(2, 2));

|ajouter| est le nom de la fonction. |a| et |b| sont les noms des deux
arguments.

Le mot-clé _|function|_ est toujours utilisé lorsque l'on crée
une fonction. Lorsqu'il est suivi d'un nom de variable, la fonction
créée sera stockée sous ce nom. À la suite du nom, vient une liste
de noms d'_argument_s, et enfin, après celle-ci le _corps_ de la
fonction. Contrairement à ceux autour du corps d'une boucle |while| ou
d'une instruction |if|, les accolades autours du corps d'une fonction sont
obligatoires##.

## Techniquement, cela ne devrait pas être nécessaire, mais je suppose que
les concepteurs de JavaScript se sont dit que cela clarifierait les choses
si le corps des fonctions était toujours entouré d'accolades.

Le mot-clé _|return|_, suivi d'une expression, est utilisé pour déterminer
la valeur qu'une fonction renvoie. Lorsque l’exécution arrive sur une
instruction |return|, elle saute immédiatement hors de la fonction courante
et transmet la valeur retournée au code qui a appelé la fonction. Une
instruction |return| sans expression à la suite fait renvoyer |undefined|
à la fonction.

Un corps peut évidemment avoir plus d'une instruction en son sein. Voici une
fonction pour calculer des puissances (avec des exposants entiers positifs) :

> function puissance(base, exposant) {
>   var resultat = 1;
>   for (var compteur = 0; compteur < exposant; compteur++)
>     resultat *= base;
>   return resultat;
> }
>
> show(puissance(2, 10));

Si vous avez résolu l'\\epower2, cette technique utilisée pour calculer
une puissance devrait vous sembler familière.

Créer une variable (|resultat|) et la mettre à jour sont des effets de
bord. Est-ce que je ne viens pas de dire que les fonctions pures n'ont pas
d'effets de bord ?

Une variable créée à l'intérieur d'une fonction existe uniquement
à l'intérieur de celle-ci. Heureusement, sinon le programmeur devrait
trouver un nom différent pour chaque variable dont il a besoin dans un
programme. Comme |resultat| existe uniquement à l'intérieur de |puissance|,
le changement ne dure que jusqu'à ce que la fonction retourne quelque chose,
et du point de vue du code qui l'appelle, il n'y a pas d'effet de bord.

***

Écrivez une fonction appelée |absolu| qui retourne la valeur absolue du
nombre qui lui est donné en argument. La valeur absolue d'un nombre négatif
est la version positive du même nombre, et la valeur absolue d'un nombre
positif (ou zero) est le nombre lui-même.

///

> function absolu(nombre) {
>   if (nombre < 0)
>     return -nombre;
>   else
>     return nombre;
> }
>
> show(absolu(-144));

---

Les fonctions pures ont deux propriétés très sympathiques. Il est facile
de s'en souvenir et de les réutiliser.

Si une fonction est pure, un appel à celle-ci peut être considéré
comme une chose indépendante. Si vous n'êtes pas sûr qu'elle fonctionne
correctement, vous pouvez la tester en l'appelant directement depuis la
console, ce qui est facile car elle ne dépend d'aucun contexte##. Il est
facile de faire ces tests automatiquement -- d'écrire un programme qui
teste une fonction spécifique. Les fonctions non-pures peuvent renvoyer
différentes valeurs basées sur toutes sortes de facteurs, et avoir des
effets de bord qui pourraient être difficiles à tester et à prévoir.

## Techniquement, une fonction pure ne peut utiliser la valeur d'aucune
variable externe. Ces valeurs pourraient changer et cela pourrait faire
renvoyer une valeur différente pour les mêmes arguments. En pratique, le
programmeur peut considérer certaines variables comme « constantes »
-- elles ne sont pas censées changer -- et considérer les fonctions qui
utilisent uniquement des variables constantes comme des fonctions pures. Les
variables qui contiennent une fonction sont souvent de bons exemples de
variables constantes.

Comme les fonctions pures sont auto-suffisantes, elles ont tendance à
être utiles et pertinentes dans un plus grand nombre de situations que
les non-pures.
Prenez |show|, par exemple. L'utilité de cette fonction dépend de la
présence d'un espace spécial à l'écran pour afficher sa sortie. Si cet
espace n'existe pas, la fonction est inutile. Nous pouvons imaginer une
fonction analogue, appelons-la |format|, qui prend une valeur en argument
et renvoie une chaîne de caractères représentant cette valeur. Cette
fonction est utile dans plus de situations que |show|.

Bien sûr, |format| ne résout pas le même problème que |show|, et aucune
fonction pure ne sera capable de résoudre ce problème, parce que cela
nécessite des effets de bord. Dans beaucoup de cas, les fonctions non-pures
sont exactement ce dont vous avez besoin. Dans d'autres cas, un problème
peut être résolu avec une fonction pure, mais la variante non-pure est
beaucoup plus adaptée ou efficace.

Par conséquent, lorsque quelque chose peut facilement être exprimé par une
fonction pure, écrivez-le ainsi. Mais ne vous sentez pas coupable d'avoir
écrit des fonctions non-pures.

---

Les fonctions avec effets de bord ne contiennent pas obligatoirement une
instruction |return|.
Si aucune instruction |return| n'est trouvée, la fonction renvoie |undefined|

> function crier(message) {
>   alert(message + " !!");
> }
>
> crier("Yow");

---

Les noms des arguments d'une fonction sont disponibles comme variables au sein
de celle-ci. Ils feront référence aux valeurs des arguments avec lesquels est
appelée la fonction, et comme les variables normales créées à l'intérieur
d'une fonction, ils n'existent pas à l’extérieur de celle-ci. En plus
de l’_environnement global_, il y a aussi de plus petits @_environnement
local_environnements locaux créés par des appels de fonctions. Lorsque l'on
cherche une variable à l'intérieur d'une fonction, l'environnement local
est contrôlé en premier, et ensuite, seulement si la variable n'existe pas
là, on la cherche dans l'environnement global. Cela permet à une variable
à l'intérieur d'une fonction de _masquer_ une variable globale du même nom.

> function alertEstPrint(value) {
>   var alert = print;
>   alert(value);
> }
>
> alertIsPrint("Troglodytes");

Les variables dans cet environnement local sont visibles seulement pour le
code à l'intérieur de la fonction. Si cette fonction appelle une autre
fonction, la fonction nouvellement créée ne voit pas les variables à
l'intérieur de la première fonction.

> var variable = "globale";
>
> function afficherVariable() {
>   print("à l'intérieur de afficherVariable, la variable contient '" +
>         variable + "'.");
> }
>
> function test() {
>   var variable = "locale";
>   print("à l'intérieur de test, la variable contient '" + variable + "'.");
>   afficherVariable();
> }
>
> test();

Cependant, et c'est un phénomène subtil mais extrêmement utile,
lorsqu'une fonction est définie *à l'intérieur* d'une autre fonction,
son environnement local sera basé sur l'environnement local qui l'entoure
plutôt que sur l'environnement global.

> var variable = "globale";
> function fonctionParente() {
>   var variable = "locale";
>   function fonctionFille() {
>     print(variable);
>   }
>   fonctionFille();
> }
> fonctionParente();

Au final, la visibilité des variables à l'intérieur d'une fonction est
déterminée par la place de cette fonction dans le texte du programme. Toutes
les variables définies « au dessus » de la définition d'une fonction
sont visibles, ce qui signifie à la fois celles dans les corps des fonctions
qui la renferme et celles globales pour tout le programme. Cette approche
de la visibilité des variables est appelée _portée lexicale_.

---

Les gens qui ont l'expérience d'autres langages de programmation pourraient
s'attendre à ce qu'un _bloc_ de code (entre accolades) crée également
un nouvel environnement local. Pas en JavaScript. Les fonctions sont les
seules qui délimittent une nouvelle portée. Vous avez le droit d'utiliser
des blocs libres comme ceci…

> var quelqueChose = 1;
> {
>   var quelqueChose = 2;
>   print("À l'intérieur : " + quelqueChose);
> }
> print("À l'extérieur : " + quelqueChose);

… mais le |quelqueChose| à l'intérieur du bloc fait référence à la même
variable que celui à l'extérieur du bloc. En fait, bien que les blocs comme
celui-ci soient permis, ils sont parfaitement inutiles. La plupart des gens
admettent que c'est une erreur de conception des créateurs de JavaScript,
et ECMAScript Harmony ajoutera certains moyens de définir des variables
qui restent à l'intérieur des blocs (le mot-clé |let|).

---

Voici un cas qui pourrait vous surprendre :

> var variable = "globale";
> function fonctionParente() {
>   var variable = "locale";
>   function fonctionFille() {
>     print(variable);
>   }
>   return fonctionFille;
> }
>
> var fille = fonctionParente();
> fille();

|fonctionParente| *renvoie* ses fonctions internes et le code en bas de
l'appel à cette fonction. Même si |fonctionParente| a fini de s'executer
à ce moment-là, l'environnement local dans lequel |variable| a la valeur
|locale| existe toujours, et |fonctionFille| continue de l'utiliser. Ce
phénomène s'appelle une fermeture lexicale (ou _closure_ en anglais).

---

La portée lexicale permet non seulement de rendre très facile et rapide à
discerner dans quelle partie d'un programme une variable sera disponible,
mais aussi de « synthétiser » des fonctions. En utilisant certaines
des variables venant d'une fonction l'englobant, une fonction interne peut
être amenée à faire des choses différentes. Imaginez que nous ayons
besoin de plusieurs fonctions différentes mais similaires, l'une d'entre
elles ajoutant 2 à son argument, l'autre ajoutant 5 et ainsi de suite.

> function makeAddFunction(quantite) {
>   function ajouter(nombre) {
>     return nombre + quantite;
>   }
>   return ajouter;
> }
>
> var ajouterDeux = makeAddFunction(2);
> var ajouterCinq = makeAddFunction(5);
> show(ajouterDeux(1) + ajouterCinq(1));

Pour vous rendre compte de cela, vous ne devez pas considérer que les
fonctions empaquettent seulement des calculs, mais aussi un environnement. Les
fonctions de haut niveau exécutent simplement l'environnement de haut niveau,
c'est assez évident. Mais une fonction définie à l'intérieur d'une autre
fonction conserve l'accès à l'environnement existant dans cette fonction
à l'instant où elle a été définie.

Par conséquent, la fonction |add| de l'exemple au-dessus, qui est crée
lorsque |makeAddFunction| est appelée, capture un environnement dans lequel
|amount| a une certaine valeur. Il empaquette cet environnement avec le
calcul |return number + amount| à l'intérieur d'une valeur qui est alors
retournée depuis la fonction extérieur.

Lorsque cette fonction renvoyée (|addTwo| ou |addFive|) est appelée, un
nouvel environnement — dans lequel la variable |number| a une valeur —
est créé comme un sous-environnement de l'environnement capturé (dans
lequel |amount| a une valeur). Ces deux valeurs sont ajoutées, et le
résultat est renvoyé.

---

Au-delà du fait que différentes fonctions peuvent contenir des variables de
même nom sans qu'elles ne se mélangent, ces règles de portée permettent
également aux fonctions de s'appeler *elles-mêmes* sans que ça ne
pose de problèmes. Une fonction qui s'appelle elle-même est qualifiée
de récursive. @_récursion_La récursion permet de donner certaines
définitions intéressantes. Jetez un coup d'œil à cette implémentation
de |puissance| :

> function puissance(base, exposant) {
>   if (exposant == 0)
>     return 1;
>   else
>     return base * puissance(base, exposant - 1);
> }

C'est très proche de ce que les mathématiciens définissent comme
l'exponentiation et, à mes yeux, c'est du code bien plus propre que dans
la version initiale. C'est pour ainsi dire une boucle, mais sans |while|,
|for|, ni même un effet de bord visible en local. En s'appelant elle-même,
la fonction produit le même effet.

Il reste toutefois un problème important : dans la plupart des
navigateurs, cette deuxième version est à peu près dix fois plus lente
que la première. En JavaScript, faire tourner une boucle est bien plus
économique qu'appeler une fonction à de multiples reprises.

---

@_efficacité_Le dilemme entre vitesse et _élégance_ est intéressant. Il
n'apparaît pas seulement quand on décide de faire ou non une récursion. Dans
de nombreuses situations, une solution élégante, intuitive et souvent
plus courte peut être remplacée par une solution plus sophistiquée mais
plus rapide.

Dans le cas de la fonction |puissance| ci-dessus la version peu élégante est
encore suffisamment simple et facile à lire. Cela n'aurait pas d'intérêt
de la remplacer par une version récursive. Pourtant il arrive souvent que
les concepts que traite un programme deviennent si complexes qu'il devient
tentant de renoncer à un peu d'efficacité pour gagner en simplicité.

La règle de base, qui a été répétée par de nombreux programmeurs et que
j'approuve de toutes mes forces, c'est de ne pas s'inquiéter de l'efficacité
tant que le programme ne devient pas un peu trop lent. Lorsque c'est le cas,
trouvez quelles parties ralentissent l'exécution et commencez à viser
l'efficacité plutôt que l'élégance.

Bien entendu, la règle ci-dessus ne signifie pas qu'on devrait démarrer
en ignorant complètement le critère de performance. Dans de nombreux cas,
comme la fonction |puissance|, on ne gagne que très peu de simplicité
avec l'approche « élégante ». Dans d'autres cas, un programmeur
expérimenté peut voir tout de suite que la simplicité ne sera jamais
assez rapide.

La raison pour laquelle j'en fais toute une histoire est que bizarrement
beaucoup de programmeurs se concentrent fanatiquement sur l'efficacité,
y compris dans les plus détails les plus insignifiants. Résultat, les
programmes sont plus longs, plus compliqués et souvent moins corrects,
ils prennent plus de temps à écrire que leur équivalent simple et ne
s'exécutent plus vite que de façon marginale.

---

Mais revenons à nos récursions. Un concept étroitement lié à la récursion
est une chose qu'on appelle la _pile_. Quand on appelle une fonction, on
donne le contrôle au corps de cette fonction. Quand le corps est exécuté,
le code qui a appelé la fonction reprend. Pendant que le corps est exécuté,
l'ordinateur doit se souvenir du contexte à partir duquel on a appelé la
fonction pour savoir où reprendre par la suite. L'endroit où ce contexte
est stocké est appelé la pile.

Le fait qu'on l'appelle une « pile » vient du fait que, comme nous
l'avons vu, un corps de fonction peut appeler à nouveau une fonction. À
chaque fois qu'une fonction est appelée, un autre contexte doit être
stocké. On peut se le représenter comme une pile de contextes. À chaque
appel de fonction, le contexte courant est mis sur le haut de la pile. Quand
une fonction se termine, le contexte du haut de la pile en est retiré pour
être restauré.

Cette pile nécessite un espace de stockage dans la mémoire de
l'ordinateur. Quand la pile prend trop d'ampleur, l'ordinateur abandonne
l'exécution en court avec un message du genre « plus d'espace disponible
dans la pile » ou « trop de récursions ». Mieux vaut s'en souvenir
quand on écrit des fonctions récursives.

!> function poule() {
!>   return oeuf();
!> }
!> function oeuf() {
!>   return poule();
!> }
!> print(poule() + " était là en premier.");

Non seulement cet exemple nous expose une manière très intéressante
d'écrire un programme qui plante, mais il montre aussi qu'une fonction n'a
pas à s'appeler elle-même directement pour être récursive. Si elle appelle
une autre fonction qui (directement ou non) appelle à nouveau la première,
elle est quand même récursive.

---

La récursion n'est pas toujours juste une alternative moins efficace à
une boucle. Certains problèmes sont bien plus faciles à résoudre avec
une récursion qu'avec des boucles. Il s'agit le plus souvent de problèmes
qui exigent l'exploration de plusieurs « branches », chacune d'elles
pouvant à son tour se subdiviser en autres branches.

Réfléchissez à cette énigme : en partant du nombre 1 et en lui ajoutant
toujours 5 ou bien en le multipliant toujours par 3, on peut générer une
quantité infinie de nouveaux nombres. Comment écririez-vous une fonction
qui, étant donné un nombre, essaie de trouver une suite d'additions et de
multiplications qui produise ce nombre ?

Par exemple le nombre 13 peut être obtenu en multipliant d'abord 1 par 3,
puis en ajoutant deux fois 5. Par contre, on ne peut pas obtenir le nombre 15.

Voici la solution :

> function findSequence(goal) {
>   function find(start, history) {
>     if (start == goal)
>       return history;
>     else if (start > goal)
>       return null;
>     else
>       return find(start + 5, "(" + history + " + 5)") ||
>              find(start * 3, "(" + history + " * 3)");
>   }
>   return find(1, "1");
> }
>
> print(findSequence(24));

Notez que le programme ne trouve pas forcément la plus *courte* suite
d'opérations, il estime avoir rempli sa mission dès qu'il trouve une
combinaison quelconque d'opérations.

La fonction interne |find|, en s'appelant elle-même de deux façons
différentes, explore à la fois la possibilité d'ajouter 5 au nombre
courant et celle de le multiplier par 3. Quand le nombre voulu est trouvé,
elle renvoie la chaîne |history|, qui est utilisée pour enregistrer tous
les opérateurs mis en œuvre pour parvenir au résultat. Elle vérifie
également si le nombre courant est plus grand que |goal| qui est le nombre
recherché, puisque si c'est le cas, nous devons interrompre l'exploration
de cette branche car elle ne peut nous donner le nombre que nous voulons.

L'utilisation de l'opérateur |||| dans l'exemple peut être compris comme
« renvoyer la solution trouvée en ajoutant 5 à |start| et, si cela
échoue, renvoyer la solution trouvée en multipliant |start| par 3 ». On
peut aussi écrire d'une façon plus verbeuse de la façon suivante :

!> else {
!>   var found = find(start + 5, "(" + history + " + 5)");
!>   if (found == null)
!>     found = find(start * 3, history + " * 3");
!>   return found;
!> }

---

Même si les définitions de fonctions interviennent comme des instructions au
milieu du reste du programme, elles ne font pas partie de la même chronologie.

> print("On dit que dans le futur ", futur());
>
> function futur() {
>   return "nous n'aurons toujours pas de voitures volantes.";
> }

Ce qui se passe c'est que l'ordinateur examine toutes les définitions de
fonctions et les stocke dans les fonctions associées, *avant* de commencer
à exécuter le reste du programme. Il en va de même avec les fonctions qui
sont définies à l'intérieur d'autres fonctions. Quand la fonction externe
est appelée, la première chose qui se passe est que toutes les fonctions
internes sont ajoutées au nouvel environnement.

---

Il existe une autre façon de définir des valeurs de type fonction,
ressemblant davantage à la façon dont les autres valeurs sont créées. Quand
le mot-clé |function| est utilisé dans un endroit où une expression est
attendue, il est considéré comme une expression qui produit une valeur de
type fonction. Les fonctions créées de cette façon n'ont même pas besoin
d'être nommées (bien qu'il soit autorisé de le faire).

> var add = function(a, b) {
>   return a + b;
> };
> show(add(5, 5));

Notez le point-virgule après la définition de |add|. Les définitions
normales de fonctions n'en ont pas besoin, mais cette instruction a la
structure générale de |var add = 22;| et donc nécessite un point-virgule.

Ce type de valeur est appelé _fonction anonyme_, parce que la fonction
définie n'a alors pas de nom. Parfois il est inutile de donner un nom aux
fonctions, comme dans l'exemple précédant de |makeAddFunction| :

> function makeAddFunction(amount) {
>   return function (number) {
>     return number + amount;
>   };
> }

Puisque dans la première version de |makeAddFunction|, la fonction |add| n'a
servi qu'une fois, le nom n'est pas nécessaire et nous pouvons directement
retourner la valeur de la fonction.

***

Écrivez une fonction |greaterThan|, qui prend un nombre en argument
et retourne une fonction qui représente un test. Quand cette nouvelle
fonction est appelée avec un simple nombre comme argument, elle retourne
un booléen : |true| si le nombre donné est plus grand que le nombre
utilisé pour créer la fonction, et |false| sinon.

///

> function greaterThan(x) {
>   return function(y) {
>     return y > x;
>   };
> }
>
> var greaterThanTen = greaterThan(10);
> show(greaterThanTen(9));

---

Essayez cela :

> alert("Salut", "Bonsoir", "Comment allez-vous ?", "Au revoir");

La fonction |alert| n'accepte officiellement qu'un argument. Cependant,
quand vous l'appelez ainsi, l'ordinateur ne se plaint pas, il ignore juste
les autres arguments.

> show();

Vous pouvez même, apparemment, vous passer d'arguments. Quand un argument
n'est pas transmis, sa valeur dans la fonction est |undefined|.

Dans le chapitre suivant, nous verrons un moyen pour que le corps de la
fonction connaisse la liste exacte des arguments qui lui sont donnés. Cela
peut être utile, par exemple, pour réaliser une fonction qui accepte
n'importe quel nombre d'arguments : |print| se comporte comme cela.

> print("R", 2, "D", 2);

Bien sûr, un inconvénient est qu'il est aussi possible de donner un nombre
incorrect d'arguments aux fonctions qui doivent en recevoir un nombre fixe,
comme |alert|, et de ne pas en être prévenu.

=================================================
Structures de données : objets et tableaux / data
=================================================

Ce chapitre sera consacré à la résolution de quelques problèmes simples. En
chemin, nous allons étudier deux nouveaux types de valeurs, les tableaux
et les objets, et étudier quelques techniques les concernant.

Considérons la situation suivante : votre tante Émilie l'excentrique,
dont la rumeur dit qu'elle vit avec cinquante chats (en fait personne n'arrive
à les compter), vous envoie régulièrement des e-mails pour vous tenir au
courant de ses exploits. Ils sont de la forme suivante :

| Mon cher neveu,
| Ta mère m'a dit que tu as commencé à faire du parachutisme. Est-ce
| que c'est vrai ? Fais attention à toi, mon garçon ! Souviens-toi de
| ce qui est arrivé à mon mari et ce n'était que du deuxième étage !
|
| En tout cas, les choses sont très intéressantes de mon côté. J'ai
| passé toute la semaine à essayer d'obtenir l'attention de Mr. Drake,
| le sympathique monsieur qui a emménagé à côté, mais je pense qu'il a
| peur des chats. À moins qu'il n'y soit allergique ? À la prochaine
| rencontre, je vais essayer de poser Igor Le Gros sur son épaule. Je
| suis curieuse de voir le résultat.
|
| Par ailleurs, l'escroquerie dont je t'avais parlé fonctionne mieux
| que je pensais. J'ai déjà récupéré cinq « paiements » et seulement
| une seule plainte. Mais j'ai quelques remords malgré tout. Et tu as
| sans doute raison de dire que c'est probablement illégal d'une
| manière ou d'une autre.
|
| (…etc.)
|
| Grosses bises, Tante Émilie
|
| Décès le 27/04/2006 : Black Leclère
|
| Nés le 05/04/2006 (mère Lady Pénélope) : Lion Rouge,
| Docteur Hobbles III, Petit Iroquois

Pour amuser cette vieille dame, vous voudriez garder une trace de la
généalogie de ses chats, pour pouvoir ajouter des commentaires comme
« P.-S. J'espère que Docteur Hobbles II a bien fêté son anniversaire
samedi ! », ou bien « Comment va cette vieille Lady Pénélope ? Elle
a cinq ans maintenant, n'est-ce pas ? », en évitant de préférence de
demander des nouvelles des chats décédés. Vous avez une grande quantité
de vieux emails de votre tante et, par chance, elle est très constante dans
sa manière de donner les renseignements sur les naissances et décès des
chats à la fin de ses e-mails, toujours dans le même format.

Vous n'avez pas envie de parcourir à la main tous ces messages. Heureusement,
nous avions justement besoin d'un exemple, nous allons donc écrire un
programme qui va faire le travail pour nous. Pour commencer, nous allons
écrire un programme qui va nous donner la liste des chats qui sont toujours
vivants à la fin du dernier e-mail.

Avant que vous ne posiez la question, au début de cette correspondance,
la tante Émilie n'avait qu'un seul chat : Spot (elle était encore assez
conformiste à cette époque).

---

[[[eyes.png]]]

---

Il est généralement préférable d'avoir une idée de départ sur ce que
va faire un programme avant de se mettre à l'écrire… Voici le plan :

 1. Commencer avec un ensemble de noms de chats ne comprenant que « Spot ».
 2. Parcourir chaque e-mail dans l'archive dans l'ordre chronologique.
 3. Chercher les paragraphes qui commencent par « Nés le » ou « Décès le ».
 4. Ajouter les noms trouvés dans les paragraphes qui commencent par « Nés le » à l'ensemble de noms.
 5. Supprimer les noms de chats trouvés dans les paragraphes qui commencent par « Décès le » de notre ensemble.

On extraira les noms d'un paragraphe de la façon suivante :

 1. Trouver les deux-points (:) dans le paragraphe.
 2. Prendre la partie après ce signe.
 3. Dans cette partie, séparer les noms en cherchant les virgules.

Cet énoncé d'exercice peut rendre nécessaire d'oublier quelques instants
les exceptions possibles et d'accepter aveuglément que tante Émilie utilise
toujours le même format d'écriture, qu'elle n'oublie jamais un nom de chat,
ni ne fait de faute de frappe. Mais votre tante est comme ça et ça tombe
bien pour nous.

---

D'abord, je vais vous expliquer les _propriété_s. Beaucoup de valeurs en
Javascript ont d'autres valeurs qui leur sont associées. Ces associations
sont appelées propriétés. Chaque chaîne de caractères a une propriété
appelée _|length|_, (longueur), qui correspond à un nombre, la quantité
de caractères dans cette chaîne.

On peut accéder aux @_|[]|_propriétés de deux manières :

> var text = "brume pourpre";
> show(text["length"]);
> show(text.length);

La deuxième manière est un raccourci de la première et ne fonctionne
que lorsque le nom de la propriété s'écrit comme un nom de variable
-- lorsqu'il n'y a pas d'espace ou de symbole et lorsqu'elle ne commence
pas par un chiffre.

Les valeurs |null| et |undefined| n'ont pas de propriété. Essayez de lire des
propriétés de ces valeurs donnera une erreur. Essayez le code suivant, juste
pour voir le type de message d'erreur que votre navigateur va retourner dans ce
cas de figure (dans certains navigateurs, ce message sera assez mystérieux).

!> var rienDuTout = null;
!> show(rienDuTout.length);

---

Les propriétés d'une chaîne de caractères ne peuvent pas être
changées. Elles sont plus nombreuses que la seule longueur |length|,
comme nous allons le voir, mais vous ne pouvez ajouter ni supprimer aucune
propriété.

C'est différent avec les valeurs du type _object_. Leur rôle principal est
de conserver d'autres valeurs. Ils ont, en quelque sorte, leur propre jeu
de « tentacules » sous forme de propriétés. Vous pouvez les modifier,
les supprimer ou en ajouter de nouvelles.

@_|{}|_Un objet peut s'écrire de la façon suivante :

> var chat = {couleur: "gris", nom: "Spot", taille: 46};
> chat.taille = 47;
> show(chat.taille);
> delete chat.taille;
> show(chat.taille);
> show(chat);

Comme les variables, chaque propriété attachée à un objet a un nom
sous forme d'une chaîne de caractères. La première instruction crée un
objet dans lequel la propriété |"couleur"| contient la chaîne |"gris"|,
la propriété |"nom"| est liée à la chaîne |"Spot"|, et la propriété
|"taille"| fait référence au nombre |46|. La deuxième ligne modifie la
propriété |taille| en lui donnant une nouvelle valeur, ce qui se fait de
la même manière que pour la modification d'une variable.

Le mot-clé _|delete|_ supprime les propriétés. Essayez de lire une
propriété qui n'existe pas donnera la valeur |undefined|.

Si une propriété qui n'existe pas encore est affectée avec l'opérateur
_|=|_, elle est ajoutée à l'objet.

> var vide = {};
> vide.plusVraiment = 1000;
> show(vide.plusVraiment);

Les propriétés dont le nom ne pourrait pas être une variable doivent être
mises entre guillemets au moment de la création de l'objet et utilisées
avec des parenthèses :

> var truc = {"gabba gabba": "hey", "5": 10};
> show(truc["5"]);
> truc["5"] = 20;
> show(truc[2 + 3]);
> delete truc["gabba gabba"];

Comme vous pouvez le voir, on peut mettre n'importe quelle expression entre
les parenthèses. Elle sera convertie dans une chaîne pour définir le nom
de la propriété. On peut aussi utiliser des variables pour donner un nom
à une propriété :

> var nomDePropriete = "length";
> var texte = "grandeLigne ";
> show(texte[nomDePropriete]);

L'opérateur _|in|_ peut servir à tester si un objet possède une certaine
propriété. Son résultat est un booléen.

> var poupeeRusse = {};
> poupeeRusse.contenu = poupeeRusse;
> show("contenu" in poupeeRusse);
> show("contenu" in poupeeRusse.contenu);

---

Quand les valeurs d'un objet sont affichées sur la  console, on peut cliquer
à la souris pour inspecter leurs propriétés. La  fenêtre de sortie
devient une fenêtre « inspecteur ». Le petit « x » en  haut
à droite s'utilise pour retourner à la fenêtre de sortie et la  flèche
gauche permet de retourner aux propriétés de l'objet inspecté.

> show(poupeeRusse);

***

La solution pour le problème des chats passe par un ensemble de noms. Un
ensemble (ou « _set_ ») est un groupe de valeurs dans lequel aucune
valeur ne peut apparaître plus d'une fois. Si les noms de chats sont des
chaînes de caractères, pouvez-vous imaginer une façon pour qu'un objet
devienne un ensemble de noms ?

Écrivez maintenant la façon dont un nom peut être ajouté à cet ensemble,
comment on peut le supprimer et comment on peut vérifier si un certain nom
est bien présent dans l'ensemble.

///

Une solution consiste à mémoriser le contenu de l'ensemble sous la forme
de propriétés d'un objet. Pour ajouter un nom, on crée une propriété
avec ce nom en lui affectant une valeur, n'importe laquelle. Pour supprimer
un nom, on supprimera la propriété de l'objet. L'opérateur |in| sera
utilisé pour savoir si une certaine propriété fait partie de l'ensemble##.

## Il y a quelques problèmes subtils avec cette approche dont nous
parlerons et que nous résoudrons dans le \\coo. On ne s'en occupera pas
pour ce chapitre.

> var set = {"Spot": true};
> // Ajoute "Croc Blanc" à l'ensemble
> set["Croc Blanc"] = true;
> // Supprime "Spot"
> delete set["Spot"];
> // Regarde si "Asoka" est dans l'ensemble
> show("Asoka" in set);

---

Les valeurs des @_mutability_objets peuvent apparemment changer. Les types
de valeurs vues dans le \\cbasics sont toutes invariables, il n'est pas
possible de changer une valeur existante pour ces types de données. Vous
pouvez les associer ou en tirer de nouvelles valeurs, mais lorsque vous
prenez une chaîne de caractères particulière, le texte à l'intérieur
ne peut pas être modifié. Avec les objets, d'un autre côté, le contenu
d'une valeur peut être modifié en changeant ses propriétés.

Lorsque nous considérons deux nombres, |120| et |120|, il est possible dans
tous les cas pratiques de les considérer comme des nombres identiques. Avec
des objets, il y a une différence importante entre avoir deux « références
» du même objet et avoir deux objets distincts qui possèdent les mêmes
propriétés. Considérons le code suivant :

> var objet1 = {valeur: 10};
> var objet2 = objet1;
> var objet3 = {valeur: 10};
>
> show(objet1 == object2);
> show(objet1 == object3);
>
> objet1.valeur = 15;
> show(objet2.valeur);
> show(objet3.valeur);

|objet1| et |objet2| sont deux variables attachées à la *même* valeur. Il
n'y a en fait qu'un seul objet, c'est pourquoi en changeant |objet1| on
change également la valeur de |objet2|. La variable |objet3| pointe vers
un autre objet qui contient au départ la même propriété que |objet1|
mais elle a une existence distincte.

L'opérateur JavaScript _|==|_, lorsqu'il compare des objets, ne retournera
la valeur booléenne |true| que si chacune des valeurs qu'on lui donne à
comparer sont exactement les mêmes. Comparer des objets différents ayant des
contenus identiques donnera le résultat |false|. C'est utile dans certaines
situations, mais peu adapté à d'autres.

---

Les valeurs d'un objet peuvent jouer de nombreux rôles. Se comporter comme
un ensemble n'est que l'un d'entre eux. Nous allons voir d'autres utilisations
dans ce chapitre et le \\coo montrera d'autres façons importantes d'utiliser
les objets.

Dans le plan d'action pour le problème des chats — en fait, appelons-le
un *algorithme* au lieu d'un plan, cela nous donne l'impression qu'on sait
de quoi on parle — dans l'algorithme, on parle de parcourir chaque e-mail
contenu dans une archive. Mais comment se présente cette archive ? Et
d'où vient-elle ?

Ne vous inquiétez pas de la deuxième question pour le moment. Le \\cxhr
explique quelques-unes des possibilités pour importer des données dans
vos programmes. Pour l'instant, on dira que les e-mails sont déjà là,
comme par magie. La magie est parfois très facile, avec les ordinateurs.

---

La façon dont l'archive est enregistrée reste une question pertinente. Elle
contient quantité d'e-mails. Un e-mail peut être vu comme une chaîne de
caractères, c'est évident. Toute l'archive pourrait être mise dans une
énorme chaîne de caractères mais ce ne serait pas pratique. Ce qu'il nous
faut, c'est une structure de chaînes de caractères distinctes.

Les objets sont justement utilisés pour structurer des choses. On pourrait
très bien créer un objet comme celui-ci :

> var archiveMail = {"le premier e-mail": "Cher neveu, …",
>                    "le deuxième e-mail": "…"
>                    /* et ainsi de suite… */};

Mais parcourir les e-mails du début à la fin serait difficile — comment
le programme peut-il deviner le nom de ces propriétés ? La solution est
d'utiliser des noms de propriétés plus prévisibles :

> var archiveMail = {0: "Cher neveu, … (mail numéro 1)",
>                    1: "(mail numéro 2)",
>                    2: "(mail numéro 3)"};
>
> for (var courant = 0; courant in archiveMail; courant++)
>   print("Traitement de l'e-mail #", courant, ": ", archiveMail[courant]);

La chance veut qu'il existe un type d'objet particulier qui corresponde
exactement à ce type de besoin. Ce sont les @_array_tableaux et ils
fournissent des commodités très utiles, comme par exemple _|length|_
(longueur), une propriété qui contient le nombre d'éléments dans le
tableau et bien d'autres fonctions utiles pour ce type de structure.

@_|[]|_Pour créer de nouveaux tableaux on utilise des crochets (|[| et |]|):

> var archiveMail = ["mail un", "mail deux", "mail trois"];
>
> for (var courant = 0; courant < archiveMail.length; courant++)
>   print("Traitement de l'e-mail #", courant, ": ", archiveMail[courant]);

Dans cet exemple, le nombre d'éléments n'est plus spécifié
explicitement. Le premier a automatiquement le numéro 0, le deuxième le
numéro 1 et ainsi de suite.

Pourquoi commencer à 0 ? Dans la vie courante on compte d'habitude à
partir de 1. Aussi étrange que cela paraisse, la numérotation à partir
de 0 est souvent plus pratique pour programmer. Faites avec pour l'instant,
vous allez vous y faire.

Commencer par l'élément 0 veut aussi dire que dans une structure qui
a |X| éléments, le dernier élément sera trouvé à la position |X -
1|. C'est pourquoi la boucle |for| dans notre exemple teste la valeur
|current < mailArchive.length|. Il n'y a pas d'élément à la position
|mailArchive.length|, donc dès que |current| atteint cette valeur, on
arrête la boucle.

*** range

Écrivez une fonction nommée |série| qui prend un argument, un nombre
positif et retourne un tableau contenant chaque nombre de 0 jusqu'au nombre
donné en paramètre inclus.

Un tableau vide peut être créé en tapant simplement |[]|. Souvenez-vous que
pour ajouter des propriétés à un tableau, comme pour un objet, il suffit
d'affecter une valeur à la propriété avec l'opérateur |=|. La propriété
|length| est mise à jour automatiquement quand des éléments sont ajoutés.

///

> function serie(max) {
>   var resultat = [];
>   for (var i = 0; i <= max; i++)
>     resultat[i] = i;
>   return resultat;
> }
> show(serie(4));

Au lieu de nommer la variable de boucle |compteur| ou |courant|, comme je l'ai
fait jusqu'à présent, elle s'appelle désormais simplement |i|. L'utilisation
d'une seule lettre, habituellement |i|, |j| ou |k| pour les variables de boucle
est une habitude très répandue en programmation. Son origine tient presque
à de la paresse : on préfère taper un caractère que sept et des noms
comme |counter| et |current| ne donnent pas forcément plus d'informations
sur la variable.

Si un programme utilise trop souvent des variables à un seul caractère, sans
explication, il peut devenir très difficile à comprendre. Dans mes propres
programmes, j'essaie de me limiter à quelques cas de figures seulement. Les
petites boucles font partie de ces cas. Si la boucle contient une autre
boucle et que celle-ci utilise aussi une variable appelée |i|, la boucle
intérieure va modifier la variable dont se sert la première boucle, et rien
ne va fonctionner. Ou pourrait utiliser |j| pour la boucle intérieure, mais
en général, lorsque le corps d'une boucle est grand, vous devriez utiliser
un nom de variable ayant une signification utile pour la compréhension.

---

Les chaînes de caractères et les objets « tableaux » contiennent tous
deux, outre la propriété |length|, un certain nombre d'autres propriétés
qui font référence à des fonctions.

> var doh = "Doh";
> print(typeof doh.toUpperCase);
> print(doh.toUpperCase());

Chaque chaîne de caractères a une propriété _|toUpperCase|_. Lorsqu'elle
est appelée, elle retourne une copie de la chaîne, transformée avec chaque
lettre en majuscule. Il y a aussi l'équivalent _|toLowerCase|_. Devinez
le résultat…

Remarquez que même si l'appel de |toUpperCase| se fait sans arguments,
la fonction a malgré tout accès au contenu de la chaîne de caractères
|"Doh"|, la valeur dont elle est une propriété. La façon dont cela
fonctionne est décrite dans le \\coo.

Les propriétés qui se comportent comme des fonctions sont généralement
appelées @_methode_méthodes, comme pour « |toUpperCase| qui est une
méthode des objets de type chaîne de caractères ».

> var flipper = [];
> flipper.push("Flipper");
> flipper.push("le");
> flipper.push("dauphin");
> show(flipper.join(" "));
> show(flipper.pop());
> show(flipper);

La méthode _|push|_, associée aux tableaux, peut être utilisée pour
ajouter des valeurs à ceux-ci. Nous aurions pu l'utiliser dans l'exercice
précédent, à la place de |resultat[i] = i|. Il y a aussi la méthode
_|pop|_, complémentaire de |push| : elle supprime le dernier élément
d'un tableau et retourne sa valeur. _|join|_ construit une seule chaîne de
caractères à partir d'un tableau de chaînes de caractères. Le paramètre
utilisé avec cette méthode sera inséré entre chaque valeur du tableau,
avant l'assemblage de la chaîne de caractères finale.

---

Revenons à nos chats : nous savons maintenant qu'utiliser un tableau
serait une bonne idée pour ranger les archives des e-mails. Sur cette page,
la fonction |recupererMails| sera utilisée pour récupérer (magiquement)
ce tableau. Parcourir les emails qu'il contient pour les traiter un par un
devient simple comme un jeu d'enfant :

> var archiveMail = recupererMails();
>
> for (var i = 0; i < archiveMail.length; i++) {
>   var email = archiveMail[i];
>   print("Traitement de l'e-mail #", i);
>   // Faire plus de choses…
> }

Nous avons également décidé d'une manière de représenter un ensemble
de chats vivants. Le problème qui reste à traiter, cependant, est celui
de détecter des paragraphes d'un e-mail qui contiennent |"Nés le"|  ou
|"Décès le"|.

---

La première question qui vient à l'esprit est de savoir ce qu'est un
paragraphe au juste. Dans ce cas, la valeur de la chaîne elle-même n'est
pas d'une grande utilité : le concept du texte en JavaScript ne va guère
plus loin que l'idée de « suite de caractères », si bien que nous
devons définir les paragraphes de cette façon.

Nous avons vu plus haut qu'il existe une chose qui s'appelle un caractère
de fin de ligne. C'est ce que la plupart des gens utilisent pour séparer les
paragraphes. Nous considérons donc un paragraphe comme une partie de mail qui
commence par un caractère saut de ligne ou au début du contenu du message
et se termine au caractère saut de ligne suivant ou bien à la fin du contenu.

Et nous n'avons même pas à écrire nous-mêmes l'algorithme pour scinder
une chaîne en paragraphes. Les chaînes ont déjà une méthode appelée
_|split|_,  qui est (pratiquement) l'inverse de la méthode |join| pour les
tableaux. Elle découpe une chaîne en un tableau en utilisant la chaîne
fournie comme argument pour déterminer à quel endroit opérer les divisions
en paragraphes.

> var words = "Les villes de l'arrière-pays";
> show(words.split(" "));

Ainsi, découper avec des caractères saut de ligne (|"\n"|) est une méthode
utilisable pour diviser un e-mail en paragraphes.

***

|split| et |join| ne sont pas exactement l'inverse l'une de
l'autre. |string.split(x).join(x)| produit toujours la valeur originale,
mais pas  |array.join(x).split(x)|. Pouvez-vous donner un exemple de tableau
dans  lequel |.join(" ").split(" ")| produit une valeur différente ?

///

> var array = ["a", "b", "c d"];
> show(array.join(" ").split(" "));

---

Les paragraphes qui ne commencent ni par « Nés le » ni par
« Décès le » peuvent être ignorés par le programme. Comment peut-on
tester si une chaîne commence par un mot particulier ? On peut utiliser
la méthode _|charAt|_ pour obtenir un caractère particulier dans une chaîne.
|x.charAt(0)| donne le premier caractère, |1| est le deuxième et ainsi de
suite. Voici une façon de vérifier si une chaîne commence par « Nés
le» :

> var paragraphe = "Nés le  15/11/2003 (mère Spot) : Croc Blanc";
> show(paragraphe.charAt(0) == "N" && paragraphe.charAt(1) == "é" &&
>      paragraphe.charAt(2) == "s" && paragraphe.charAt(3) == " " &&
>      paragraphe.charAt(4) == "l" && paragraphe.charAt(5) == "e") ;

Mais cela devient un peu pénible -- imaginez que vous devez vérifier la
présence d'un mot de 30 caractères. On peut cependant en tirer une leçon
utile : si une ligne est démesurément longue, on peut l'étendre sur
plusieurs lignes. Le résultat peut être plus facile à lire en alignant
le début d'une nouvelle ligne avec la ligne originale jouant le même rôle

Les chaînes possèdent également une méthode nommée _|slice|_. Elle permet
de copier un morceau de la chaîne de caractères, en commençant par le
caractère à la position donnée par le premier argument, et se terminant
avant le caractère (non inclus) à la position donnée par le second
argument. Cela permet de vérifier une chaîne de caractères en peu de lignes.

> show(paragraphe.slice(0, 12) == "Nés le");

***

Écrivez une fonction nommée |startWith| qui prend deux arguments, tous les
deux des chaînes de caractères. Elle renvoie |true| quand le premier argument
commence avec les caractères du second arguments, sinon elle renvoie |false|.

///

> function startsWith(string, pattern) {
>   return string.slice(0, pattern.length) == pattern;
> }
>
> show(startsWith("rotation", "rot"));

---

Que se passe-t-il quand |charAt| ou |slice| sont utilisés pour prendre un
fragment de chaîne qui n'existe pas ? Est-ce que le |startsWith| que j'ai
montré va encore fonctionner si le la chaîne recherchée est plus longue
que celle dans laquelle on cherche ?

> show("Pip".charAt(250));
> show("Nop".slice(1, 10));

|charAt| va renvoyer |""| s'il n'existe pas de caractère à la position
donnée et |slice| va tout simplement laisser tomber la partie de la nouvelle
chaîne qui n'existe pas.

Cela confirme que cette version de |startWith| fonctionne. Quand la fonction
|startsWith("Idiots","Mes très chers collègues")| est appelée, l'appel
à |slice| renverra toujours une chaîne plus courte que |pattern|, parce
que |string| ne comporte pas assez de caractères. C'est pour cette raison
que la comparaison avec |==| renverra |false|, ce qui est correct.

C'est une bonne idée de toujours consacrer un moment pour prendre en
considération les entrées aberrantes (mais valides) dans un programme. On
les appelle en général des cas imprévus et il est très fréquent qu'un
programme qui tourne à merveille avec toutes les entrées « normales »
se plante complètement avec des cas imprévus.

---

La seule partie de notre problème de chats qui ne soit pas encore résolue
est l'extraction des noms d'un paragraphe. L'algorithme était le suivant :

 1. Trouver le deux-points (:) dans le paragraphe.
 2. Prendre la partie après ce signe.
 3. Dans cette partie, séparer les noms en cherchant les virgules.

Il faut reproduire cela à la fois pour les paragraphes qui commencent par
|Décés le| et ceux qui commencent par |Nés le|. Ce serait une bonne idée
de le mettre dans une fonction, de sorte que les deux parties de code qui
gèrent les différentes sortes de paragraphes puissent l'utiliser.

***

Savez-vous écrire une fonction |nomChats| qui prenne un paragraphe comme
argument et renvoie un tableau de noms ?

Les chaînes ont une méthode _|indexOf|_que l'on peut utiliser pour trouver la
(première) position d'un caractère ou une sous-chaîne à l'intérieur d'une
chaîne. De même si on ne donne qu'un seul argument à |slice|, elle renverra
la partie de la chaîne depuis la première position jusqu'à son extrémité.

Il peut être pratique d'utiliser la console pour « explorer » les
fonctions. Par exemple, tapez |"foo: bar".indexOf(":")| et voyez ce qui
se passe.

///

> function catNames(paragraph) {
>   var colon = paragraph.indexOf(":");
>   return paragraph.slice(colon + 2).split(", ");
> }
>
> show(catNames("Nés le 20/09/2004 (de mère Yellow Bess): " +
>               "Doctor Hobbles the 2nd, Noog"));

La partie la plus délicate qui est ignorée par la description originale
de l'algorithme, est le traitement des espaces après les deux-points
et les virgules. Le |+2|, utilisé pour le découpage de chaînes, est
nécessaire pour laisser de côté le deux-points lui-même et l'espace qui
le suit. L'argument pour |split| contient à la fois une virgule et un espace,
parce que ce sont les séparateurs de noms, plutôt que par une simple virgule.

Cette fonction n'effectue aucune vérification de problèmes éventuels. Nous
faisons comme si, dans ce cas précis, l'entrée était toujours correcte.

---

Tout ce qui nous reste à faire maintenant, c'est de rassembler les pièces
du puzzle. Voici une façon de s'y prendre :

> var mailArchive = retrieveMails();
> var livingCats = {"Spot": true};
>
> for (var mail = 0; mail < mailArchive.length; mail++) {
>   var paragraphs = mailArchive[mail].split("\n");
>   for (var paragraph = 0;
>        paragraph < paragraphs.length;
>        paragraph++) {
>     if (startsWith(paragraphs[paragraph], "Nés le")) {
>       var names = catNames(paragraphs[paragraph]);
>       for (var name = 0; name < names.length; name++)
>         livingCats[names[name]] = true;
>     }
>     else if (startsWith(paragraphs[paragraph], "Décès le")) {
>       var names = catNames(paragraphs[paragraph]);
>       for (var name = 0; name < names.length; name++)
>         delete livingCats[names[name]];
>     }
>   }
> }
>
> show(livingCats);

Voilà un bloc de code assez copieux et dense. Nous allons voir tout de
suite comment l'alléger un peu. Mais d'abord jetons un coup d'œil aux
résultats. Nous savons comment vérifier si un chat particulier a survécu :

> if ("Spot" in livingCats)
>   print("Spot est vivant !");
> else
>   print("Ce bon vieux Spot, qu'il repose en paix.");

Mais comment allons-nous faire pour dresser la liste de tous les chats
vivants ? Le mot-clé _|in|_ a une signification légèrement différente
lorsqu'il est utilisé avec |for| :

> for (var cat in livingCats)
>   print(cat);

Une boucle comme celle-là va parcourir les noms des propriétés d'un objet,
ce qui nous permettra d'énumérer tous les noms de notre ensemble.

---

Certaines parties de code ressemble à une jungle impénétrable. L'exemple
de solution pour le problème des chats souffre de ce défaut. Une façon
de ménager des clairières consiste tout simplement à ajouter des lignes
vides. Cela améliore la lisibilité, mais ne résout pas véritablement
le problème.

Ce qu'il nous faut ici, c'est casser le code. Nous avons déjà écrit deux
fonctions d'aide, |startsWith| et |catNames|, qui toutes deux résolvent
une petite partie du problème de façon compréhensible. Continuons sur
cette lancée.

> function addToSet(set, values) {
>   for (var i = 0; i < values.length; i++)
>     set[values[i]] = true;
> }
>
> function removeFromSet(set, values) {
>   for (var i = 0; i < values.length; i++)
>     delete set[values[i]];
> }

Ces deux fonctions traitent de l'ajout et de la suppression des noms dans
l'ensemble. Ce qui supprime déjà les deux plus importantes boucles internes
de la solution :

> var livingCats = {Spot: true};
>
> for (var mail = 0; mail < mailArchive.length; mail++) {
>   var paragraphs = mailArchive[mail].split("\n");
>   for (var paragraph = 0;
>        paragraph < paragraphs.length;
>        paragraph++) {
>     if (startsWith(paragraphs[paragraph], "Nés le"))
>       addToSet(livingCats, catNames(paragraphs[paragraph]));
>     else if (startsWith(paragraphs[paragraph], "Décès le"))
>       removeFromSet(livingCats, catNames(paragraphs[paragraph]));
>   }
> }

C'est un sacré progrès, si je peux me permettre.
Pourquoi |addToSet| et |removeFromSet| prennent-ils l'ensemble comme
argument ? Ils pourraient utiliser la variable |livingCats| directement,
s'ils le voulaient. La raison, c'est que de cette façon elles ne sont pas
totalement liées à notre problème. Si |addToSet| changeait directement
|livingCats|, il faudrait l'appeler |addCatsToCatSet| (ajouter des chats à
l'ensemble des chats) ou quelque chose comme ça. Tel que nous l'utilisons,
c'est un outil utile pour des cas plus généraux.

Même si nous ne devions jamais utiliser ces fonctions pour quoi que ce
soit d'autre, ce qui est très probable, il est utile de les décrire de
cette façon. Car elles se « suffisent à elles-même », on peut les
lire et les comprendre, sans avoir besoin de connaître une variable externe
nommée |livingCats|.

Les fonctions ne sont pas pures : elles modifient l'objet qui a été passé
en premier argument (|set|). Cela rend les choses un peu plus délicates
qu'avec des fonctions pures mais c'est déjà beaucoup moins perturbant que
des fonctions qui perdent les pédales et modifient les valeurs de variables
comme ça leur chante.

---

Nous continuons à découper l'algorithme en petites unités :

> function findLivingCats() {
>   var mailArchive = retrieveMails();
>   var livingCats = {"Spot": true};
>
>   function handleParagraph(paragraph) {
>     if (startsWith(paragraph, "Nés le"))
>       addToSet(livingCats, catNames(paragraph));
>     else if (startsWith(paragraph, "Décès le"))
>       removeFromSet(livingCats, catNames(paragraph));
>   }
>
>   for (var mail = 0; mail < mailArchive.length; mail++) {
>     var paragraphs = mailArchive[mail].split("\n");
>     for (var i = 0; i < paragraphs.length; i++)
>       handleParagraph(paragraphs[i]);
>   }
>   return livingCats;
> }
>
> var howMany = 0;
> for (var cat in findLivingCats())
>   howMany++;
> print("Il y a ", howMany, " chats.");

La totalité de l'algoritme est encapsulée dans une fonction. Cela signifie
qu'elle ne laisse rien traîner en vrac derrière elle après exécution :
|livingCats| est maintenant une variable locale dans la fonction et non plus
une variable globale, si bien qu'elle n'existe que pendant que la fonction
s'exécute. Le code qui a besoin de cet ensemble peut appeler |findLivingCats|
et utiliser la valeur qu'il renvoie.

Il me semble que faire de |handleParagraph| une fonction distincte peut
aussi clarifier les choses. Mais celle-ci est si étroitement liée à
l'algorithme-des-chats qu'elle n'aurait aucun sens dans une autre situation. De
plus, elle a besoin d'accéder à la variable |livingCats|. C'est donc
une candidate parfaite pour devenir une fonction à l'intérieur d'une
fonction. Quand elle existe à l'intérieur de |findLivingCats|, il est
clair qu'elle n'est pertinente que là et qu'elle a accès aux variables de
sa fonction parente.

Cette solution est en fait plus *grande* que la précédente. Mais elle est
plus propre et j'espère que vous reconnaîtrez qu'elle est plus lisible.

---

Le programme ignore encore un grand nombre d'informations qui sont incluses
dans les mails. Il s'agit des dates de naissance, de mort et des noms
des mères.

Commençons avec les dates : quelle pourrait être la meilleure façon
de stocker une date ? Nous pourrions créer un objet avec ces trois
propriétés,  |year|, |month|, et |day| et stocker ensuite des nombres
à l'intérieur.

> var when = {year: 1980, month: 2, day: 1};

Mais JavaScript fournit déjà une sorte d'objet pour cela.
Un tel objet peut être créé en utilisant le mot-clé _|new|_:

> var when = new Date(1980, 1, 1);
> show(when);

Tout comme la notation avec les accolades et les deux-points que nous avons
déjà vue, |new| est une façon de créer des valeurs d'un objet. Au lieu
de préciser tous les noms de propriétés et les valeurs, une fonction est
utilisée pour créer l'objet. Cela rend possible de définir une sorte de
procédure standard pour créer des objets. Les fonctions comme celle-là
s'appellent _constructeur_s et nous verrons comment les écrire dans \\coo.

Le constructeur  _|Date|_ peut être utilisé de différentes manières

> show(new Date());
> show(new Date(1980, 1, 1));
> show(new Date(2007, 2, 30, 8, 20, 30));

Comme vous pouvez le voir, ces objets peuvent enregistrer l'heure d'un
jour aussi bien qu'une date. Quand aucun argument n'est précisé, un objet
réprésentant l'heure et la date actuelles est créé. Des arguments peuvent
être précisés pour stocker une heure et une date précises. L'ordre des
arguments est l'année, le mois, le jour, l'heure, la minute, la seconde puis
la milliseconde. Les quatre derniers arguments sont optionnels et définis
à 0 s'il ne sont pas précisés.

Pour décrire les mois, on utilise la numérotation de 0 à 11, qui peut
provoquer une confusion. Surtout que les nombres définissant les jours
commencent eux à 1.

---

Le contenu de l'objet |Date|  peut être inspecté avec un nombre de
méthodes |get…|.

> var today = new Date();
> print("Année : ", today.getFullYear(), ", mois : ",
>       today.getMonth(), ", jour : ", today.getDate());
> print("Heure : ", today.getHours(), ", minutes : ",
>       today.getMinutes(), ", secondes: ", today.getSeconds());
> print("Jour de la semaine : ", today.getDay());

Tous ces éléments, expecté la méthode |getDay|, ont une variable |set...|
qui peut être utilisée pour modifier la valeur de l'objet date.

Dans l'objet, une date est représentée par la somme de millisecondes
cumulée depuis le 1er Janvier 1970. Vous pouvez imaginer que c'est un nombre
assez impressionnant.

> var  aujourdhui = new Date();
> show(aujourdhui.getTile());

Une chose très utile à faire avec les dates, c'est de les comparer.

> var chuteDuMur = new Date(1989, 10, 9);
> var premiereGuerreDuGolf = new Date (1990, 6, 2);
> show(chuteDuMur < premiereGuerreDuGolf);
> show(chuteDuMur == chuteDuMur);
> // mais
> show(chuteDuMur == new Date(1989, 10, 9));

Comparer les dates avec |<|, |>|, |<=| et |>=| remplit exactement l'office
que nous voulons en faire. Quand un objet date est comparé avec lui-même,
le résultat est |true|, ce qui est bien également. Mais quand _|==|_ est
utilisé pour comparer un objet date à un autre objet date différent mais
de même valeur, on obtient |false|. Etrange, non ?

Comme précisé plus tôt, |==| retournera la valeur [false| lors de la
comparaison de deux éléments différents, même si ces deux éléments
contiennent les mêmes propriétés. Ceci est un peu maladroit et sujet
à erreur, puisqu''on s'attendrait à ce que |>=| et |==| aient le même
comportement. Pour tester si deux dates sont égales, peut être fait de
cette manière :

> var chuteDuMur1 = new Date(1989, 10, 9),
chuteduMur2 = new Date(1989, 10 ,9);
> show(chuteDuMur1.getTime() == chuteDuMur2.getTime());

---

---

Au-delà de la date et l'heure, l'objet |Date| contient aussi des informations
sur le _fuseau horaire_. Quand il est une heure à Amsterdam, en fonction
de la période de l'année il peut être midi à Londres et sept heures du
matin à New York. De telles heures ne peuvent être rapprochées que si vous
prenez les fuseaux horaires en compte. La fonction _|getTimezoneOffset|_
d'une |Date| peut être utilisée pour trouver de combien de minutes elle
s'éloigne du GMT (Heure du méridien de Greenwich)

> var now = new Date();
> print(now.getTimezoneOffset());

***

] "Décès le 27/04/2006 : Black Leclère"

La partie date est toujours exactement à la mëme place du paragraphe. Comme
c'est pratique. Écrivez une fonction |extractDate| qui prend un tel paragraphe
pour argument, extrait la date et le renvoit sous la forme d'un objet date.

///

> function extractDate(paragraph) {
>   function numberAt(start, length) {
>     return Number(paragraph.slice(start, start + length));
>   }
>   return new Date(numberAt(11, 4), numberAt(8, 2) - 1,
>                   numberAt(5, 2));
> }
>
> show(extractDate("Décès le 27-04-2006 : Black Leclère"));

Cela ne marcherait pas sans les appels à |Number|, mais comme je l'ai
expliqué plus haut, je préfère ne pas utiliser de chaînes comme si elles
étaient des nombres. La fonction interne a été introduite pour éviter
d'avoir à répéter trois fois les parties |Number| et |slice|.

Notez le |-1| pour le numéro du mois. Comme la plupart des gens, tante Émilie
compte les mois à partir de 1, nous devons donc ajuster cette valeur avant
de donner la |Date| au constructeur (le numéro du jour ne relève pas du
même problème, puisque les objets |Date| compte les jours de la façon
humaine habituelle).

Dans le \\cregexp,, nous verrons une façon plus pratique et plus sûre
d'extraire des parties de chaînes qui ont une structure déterminée.

---

Stocker des chats est une opération qui va se dérouler différemment
à partir de maintenant. Au lieu de simplement mettre la valeur |true| sur
l'ensemble, nous stockons un objet avec les informations sur le chat. Lorsqu'un
chat meurt, nous ne le supprimons pas de l'ensemble, nous ajoutons simplement
la propriété |death| à l'objet pour stocker la date à laquelle le pauvre
animal a trépassé.

Cela signifie que nos fonctions |addToSet| et |removeFromSet| sont devenues
inutiles. Quelque chose de comparable est nécessaire, mais il s'agit de
stocker aussi les dates de naissance et par la suite, les noms des mères.

> function catRecord(nom, dateAnniversaire, mere) {
>   return {nom: nom, naissance: dateNaissance, mere: mere};
> }
>
> function addCats(set, noms, dateNaissance, mere) {
>   for (var i = 0; i < noms.length; i++)
>     set[names[i]] = catRecord(noms[i], dateNaissance, mere);
> }
> function deadCats(set, noms, dateDeces) {
>   for (var i = 0; i < noms.length; i++)
>     set[names[i]].deces = dateDeces;
> }

|catRecord| est une fonction distincte pour créer ces objets de stockage. Elle
pourrait être utile dans d'autres situations, telles que la création d'un
objet pour Spot. « Record » (« enregistrement » en français)
est le terme qu'on emploie couramment pour des objets de ce type, qui sont
utilisés pour regrouper un nombre limité de valeurs.

---

Essayons donc maintenant d'extraire les noms des mamans chats qui se trouvent
dans des paragraphes.

] "né le 15/11/2003 (mère : Spot): Croc Blanc"

Voici un moyen d'obtenir cela…

> function extractMother(paragraphe) {
>   var start = paragraphe.indexOf("(mère ") + "(mère ".length;
>   var end = paragraphe.indexOf(")");
>   return paragraphe.slice(start, end);
> }
>
> show(extractMother("Nés le 15/11/2003 (mère Spot): Croc Blanc"));

Notez comment la position de départ a dû être ajustée à la longueur de
|"(mère "|, parce que |indexOf| renvoie la position initiale de la chaîne
et non la finale.

***

Ce que fait |extractMother| peut être exprimé d'une façon plus
générale. Écrivez une fonction |between| qui prend trois arguments,
qui seront tous des chaînes. Elle renverra la partie du premier argument
qui apparaît entre les chaînes fournies par le deuxième et le troisième
argument.

Ainsi, |between("Nés le 15/11/2003 (mère Spot): Croc Blanc", "(mère ",
")")|  donne |"Spot"|.

|between("bu ] boo [ bah ] gzz", "[ ", " ]")| renvoie |"bah"|.

Pour faire marcher ce deuxième test, il peut être utile de savoir qu'on
peut attribuer à |indexOf| un second paramètre facultatif qui précise à
partir de quel point doit commencer la recherche.

///

> function between(string, start, end) {
>   var startAt = string.indexOf(start) + start.length;
>   var endAt = string.indexOf(end, startAt);
>   return string.slice(startAt, endAt);
> }
> show(between("bu ] boo [ bah ] gzz", "[ ", " ]"));

---

Avoir la fonction |between| rend possible l'expression de extractMother de
façon plus simple :

> function extractMother(paragraph) {
>   return between(paragraph, "(mother ", ")");
> }

---

Le nouvel algorithme à chats amélioré ressemble maintenant à ça :

> function findCats() {
>   var mailArchive = retrieveMails();
>   var cats = {"Spot": catRecord("Spot", new Date(1997, 2, 5),
>               "inconnue")};
>
>   function handleParagraph(paragraph) {
>     if (startsWith(paragraph, "Nés le"))
>       addCats(cats, catNames(paragraph), extractDate(paragraph),
>               extractMother(paragraph));
>     else if (startsWith(paragraph, "Décès le"))
>       deadCats(cats, catNames(paragraph), extractDate(paragraph));
>   }
>
>   for (var mail = 0; mail < mailArchive.length; mail++) {
>     var paragraphs = mailArchive[mail].split("\n");
>     for (var i = 0; i < paragraphs.length; i++)
>       handleParagraph(paragraphs[i]);
>   }
>   return cats;
> }
>
> var catData = findCats();

Avoir ces données supplémentaires nous permet d'avoir finalement une idée
plus précise des chats dont parle tante Émilie. Une fonction comme celle-ci
pourrait être utile :

> function formatDate(date) {
>   return date.getDate() + "/" + (date.getMonth() + 1) +
>          "/" + date.getFullYear();
> }
>
> function catInfo(data, name) {
>   if (!(name in data))
>     return "Aucun chat s'appelant " + name + " n'a été trouvé.";
>
>   var cat = data[name];
>   var message = name + ", né le " + formatDate(cat.birth) +
>                 " de la mère " + cat.mother;
>   if ("death" in cat)
>     message += ", mort le " + formatDate(cat.death);
>   return message + ".";
> }
>
> print(catInfo(catData, "Igor Le Gros"));

La première instruction |return| dans |catInfo| est utilisée comme issue de
secours. Si aucune donnée n'est fournie sur un chat particulier, le reste
de la fonction est dépourvu de sens, nous renvoyons donc immédiatement
une valeur qui empêche le reste du code de s'exécuter.

Dans le passé, certains groupes de programmeurs considéraient comme
malsaines les fonctions contenant de multiples instructions |return|. Selon
eux, cela rendait difficile de voir quel code était exécuté et quel code
ne l'était pas.
D'autres techniques, qui seront abordées dans le \\cerror, ont rendu
cet argument plus ou moins obsolète, mais vous pouvez toujours tomber à
l'occasion sur quelqu'un qui critiquera l'utilisation de raccourcis avec
l'instruction |return|.

***

La fonction |formatDate| utilisée par |catInfo| n'ajoute pas de zéro avant
la partie mois et jour quand ce sont des nombres à un seul chiffre. Écrivez
une nouvelle version qui fera cela.

///

> function formatDate(date) {
>   function pad(number) {
>     if (number < 10)
>       return "0" + number;
>     else
>       return number;
>   }
>   return pad(date.getDate()) + "/" + pad(date.getMonth() + 1) +
>              "/" + date.getFullYear();
> }
> print(formatDate(new Date(2000, 0, 1)));

***

Écrivez une fonction |oldestCat| qui, étant donné un objet ayant des
chats comme arguments, renvoie le nom du plus vieux chat vivant.

///

> function oldestCat(data) {
>   var oldest = null;
>
>   for (var name in data) {
>     var cat = data[name];
>     if (!("deces" in cat) &&
>         (oldest == null || oldest.birth > cat.birth))
>       oldest = cat;
>   }
>
>   if (oldest == null)
>     return null;
>   else
>     return oldest.name;
> }
>
> print(oldestCat(catData));

La condition donnée avec la commande |if| pourrait paraître un peu intimidante.
On peut la lire comme : «  ne stocker le chat courant dans la variable
|oldest| que s'il n'est pas mort, et |oldest| est soit |null| soit un chat
qui est né après le chat en cours ».

Notez que cette fonction renvoie |null| quand il n'existe aucun chat vivant
dans |data|. Que devient notre solution dans cas ?

---

Maintenant que vous êtes familiarisé avec les tableaux, je peux vous montrer
quelque chose de lié. Quel que soit le nom d'une fonction, une variable
spéciale nommée _|arguments|_ est ajoutée à l'environnement dans lequel
le corps de la fonction tourne. Cette variable se réfère à un objet qui
ressemble à un tableau. Il a la propriété |0| pour le premier argument,
|1| pour le second, et ainsi de suite pour chaque argument donné par la
fonction. Il possède également une propriété _|length|_.

Cependant, cet objet n'est pas véritablement un tableau, il ne possède pas
de méthodes telles que |push| et il ne met pas pas à jour automatiquement sa
propriété |length| quand vous lui ajoutez quelque chose. Pourquoi n'est-ce
pas le cas ? Je n'ai jamais vraiment compris l'utilité de tout cela, mais
c'est quelque chose dont vous devez avoir connaissance.

> function compteurArgument() {
print("Vous m'avez donné", arguments.length, "arguments.");
> }
> compteurArgument("Mort", "Famine", "Fléau");

Certaines fonctions peuvent prendre un certain nombre d'arguments, comme par
exemple la fonction |print|. Cette fonction particulière opére une boucle sur
les valeurs des |arguments| d'un objet pour en faire quelque chose. Les autres
peuvent prendre des arguments de manière optionnelle qui sont initialisés
à une valeur par défaut sensée si l'utilisateur ne fournit pas de valeur.

> function add(nombre, combien) {
>    if (arguments.length < 2)
>      combien = 1;
>    return nombre + combien ;
> }
>
> show(add(6));
> show(add(6, 4));

***

Étendez la fonction |serie| de l'\\erange pour prendre un second argument,
optionnel. Si un seul argument est donné à la fonction, elle se comporte
comme précédemment et produit une série commençant à 0 jusqu'au nombre
donné. Si deux arguments sont donnés, le premier indique le début de la
série, le second la fin.

///

> function serie(debut, fin) {
>   if (arguments.length < 2) {
>     fin = debut;
>     debut = 0;
>   }
>   var resultat = [];
>   for (var i = debut; i <= fin; i++)
>     resultat.push(i);
>   return resultat;
> }
>
> show(serie(4));
> show(serie(2, 4));

L'argument optionnel ne fonctionne pas exactement comme le premier, dans
l'exemple |add| ci-dessus. Quand il n'est pas précisé, le premier argument
prend le rôle de |fin| et |debut| devient |0|.

***

Vous devez vous rappeler de la ligne de code cité en introduction :

!> print(sum(serie(1, 10)));

Nous avons la fonction |range| maintenant. Tout ce que nous avons besoin
pour faire fonctionner cette ligne est une fonction |sum|. Cette fonction
prend un tableau de nombre en arguments et retourne leur somme. Écrivez-la,
ce devrait être simple.

///

> function sum(numbers) {
>   var total = 0;
>   for (var i = 0; i < numbers.length; i++)
>     total += numbers[i];
>   return total;
> }
>
> print(sum(serie(1, 10)));

---

Le chapitre précédent nous a permis d'étudier les fonctions |Math.max|
et |Math.min|. Avec ce que vous connaissez maintenant, vous pourrez noter
que |max| et |min| sont déjà les propriétés d'un objet enregistré sous
le nom de |Math|. Voici un autre rôle que les objets peuvent jouer :
celui d'entrepôt pour un grand nombre de valeurs liées.

Il y a beaucoup de valeurs dans |Math|, si elles avaient été placées
directement dans l'environnement global,  elles l'auraient, comme on dit,
pollué. Plus il y a de noms utilisés, plus il est probable d'écraser par
accident la valeur d'une variable. Par exemple, il n'est pas incongru de
vouloir nommer une variable |max|.

La plupart des langages vous arrêteront, ou du moins vous alerteront,
quand vous définirez une variable avec un nom déjà utilisé par
l'environnement. Pas JavaScript.

Dans tous les cas, on peut trouver tout un ensemble de fonctions mathématiques
et de constantes dans |Math|. Toutes les fonctions trigonométriques sont
présentes : |cos|, |sin|, |tan|, |acos|, |asin| et |atan|. π et e, qui sont
écrits en capitales (|PI| et |E|), ce qui était à une époque une façon
très à la mode d'indiquer que quelque chose est une constante. |pow| est un
bon moyen de substitution des fonctions |puissance| que nous avons écrites,
il accepte les exposants négatifs et fractionnels. |sqrt| extrait la racine
carrée d'un nombre. |max| et |min| peuvent donner le maximum ou le minimum de
deux valeurs. @_|Math.round|_@_|Math.floor|_@_|Math.ceil|_|round|, |floor|,
et |ceil| vont respectivement arrondir un nombre à l'entier le plus proche,
à l'entier inférieur et supérieur le plus proche.

Il existe un grand nombre d'autres valeurs dans |Math|, mais ce texte est
une introduction, pas une _référence_. Les références sont ce que vous
consultez lorsque vous soupçonnez qu'il existe quelque chose dans un langage,
mais avez besoin de savoir comment ça s'appelle ou comment ça marche au
juste. Malheureusement, il n'existe aucune référence totalement exhaustive
pour le JavaScript. C'est essentiellement parce que sa forme courante est la
résultante d'un processus chaotique pendant lequel différents navigateurs
lui ont ajouté diverses extensions à différentes périodes. Le document
standard ECMA, mentionné dans l'introduction, fournit une solide documentation
du langage de base, mais il est plus ou moins lisible. Pour les choses comme
l'objet |Math| et autres fonctions élémentaires, on peut trouver une bonne
source de référence [ici
http://www.webreference.com/javascript/reference/core_ref/contents.html].
L'ancienne documentation de Netscape, que l'on peut encore trouver sur le
[site de Sun | http://docs.sun.com/source/816-6408-10], peut encore être
utile, mais elle est dépassée et n'est plus complètement correcte.
[NdT] Le site de [Mozilla dédié aux
développeurs|https://developer.mozilla.org/en/JavaScript] regroupe de
nombreuses informations à jour.

---

Vous avez peut-être déjà pensé à un moyen de découvrir ce qui est
disponible avec l'objet |Math| :

> for (var name in Math)
>   print(name);

Mais hélas, rien n'apparaît. De même, quand vous faites ceci :

> for (var name in ["Huey", "Dewey", "Loui"])
>   print(name);

Vous ne voyez que |0|, |1|, et |2|, pas |length|, ni |push|, ou |join|,
qui s'y trouvent pourtant bel et bien. Apparemment, certaines propriétés
des objets sont cachées@_propriétés cachées_. Il y a une bonne raison à
ça : tous les objets ont quelques méthodes, par exemple  _|toString|_
qui convertit l'objet en une sorte de chaîne pertinente, mais vous ne
souhaiterez sûrement pas les voir quand vous êtes par exemple, à la
recherche des chats que vous avez stockés dans l'objet.

Pourquoi les propriétés de |Math| sont-elles cachées ? Ce n'est pas
très clair pour moi. Il y a sûrement quelqu'un qui a voulu en faire un
type d'objet mystérieux.

Toutes les propriétés que vos programmes ajoutent aux objets sont
visibles. Il n'y a pas moyen de les cacher, ce qui est regrettable parce que,
comme vous le verrez dans le \\coo, il serait sympa d'ajouter des méthodes
aux objets sans avoir à les rendre visibles dans des boucles |for|/|in|.

---

@_propriétés en lecture seule_Certaines propriétés sont en lecture seule,
vous pouvez récupérer leur valeur mais pas la modifier. Par exemple,
les propriétés d'une valeur de chaîne sont toutes en lecture seule.

> var array = ["Ciel", "Terre", "Homme"];
> array.length = 2;
> show(array);

======================
Error Handling / error
======================

Writing programs that work when everything goes as expected is a good
start. Making your programs behave properly when encountering
unexpected conditions is where it really gets challenging.

The problematic situations that a program can encounter fall into two
categories: Programmer mistakes and genuine problems. If someone
forgets to pass a required argument to a function, that is an example
of the first kind of problem. On the other hand, if a program asks the
user to enter a name and it gets back an empty string, that is
something the programmer can not prevent.

In general, one deals with programmer errors by finding and fixing
them, and with genuine errors by having the code check for them and
perform some suitable action to remedy them (for example, asking for
the name again), or at least fail in a well-defined and clean way.

---

It is important to decide into which of these categories a certain
problem falls. For example, consider our old |power| function:

> function power(base, exponent) {
>   var result = 1;
>   for (var count = 0; count < exponent; count++)
>     result *= base;
>   return result;
> }

When some geek tries to call |power("Rabbit", 4)|, that is quite
obviously a programmer error, but how about |power(9, 0.5)|? The
function can not handle fractional exponents, but, mathematically
speaking, raising a number to the halfth power is perfectly reasonable
(_|Math.pow|_ can handle it). In situations where it is not entirely
clear what kind of input a function accepts, it is often a good idea
to explicitly state the kind of arguments that are acceptable in a
comment.

---

If a function encounters a problem that it can not solve itself, what
should it do? In \\cdata we wrote the function |between|:

> function between(string, start, end) {
>   var startAt = string.indexOf(start) + start.length;
>   var endAt = string.indexOf(end, startAt);
>   return string.slice(startAt, endAt);
> }

If the given |start| and |end| do not occur in the string, |indexOf|
will return |-1| and this version of |between| will return a lot of
nonsense: |between("Your mother!", "{-", "-}")| returns |"our mother"|.

When the program is running, and the function is called like that, the
code that called it will get a string value, as it expected, and
happily continue doing something with it. But the value is wrong, so
whatever it ends up doing with it will also be wrong. And if you are
unlucky, this wrongness only causes a problem after having passed
through twenty other functions. In cases like that, it is extremely
hard to find out where the problem started.

In some cases, you will be so unconcerned about these problems that
you don't mind the function misbehaving when given incorrect input.
For example, if you know for sure the function will only be called
from a few places, and you can prove that these places give it decent
input, it is generally not worth the trouble to make the function
bigger and uglier so that it can handle problematic cases.

But most of the time, functions that fail 'silently' are hard to use,
and even dangerous. What if the code calling |between| wants to know
whether everything went well? At the moment, it can not tell, except
by re-doing all the work that |between| did and checking the result of
|between| with its own result. That is bad. One solution is to make
|between| return a special value, such as |false| or |undefined|, when
it fails.

> function between(string, start, end) {
>   var startAt = string.indexOf(start);
>   if (startAt == -1)
>     return undefined;
>   startAt += start.length;
>   var endAt = string.indexOf(end, startAt);
>   if (endAt == -1)
>     return undefined;
>
>   return string.slice(startAt, endAt);
> }

You can see that error checking does not generally make functions
prettier. But now code that calls |between| can do something like:

> var input = prompt("Tell me something", "");
> var parenthesized = between(input, "(", ")");
> if (parenthesized != undefined)
>   print("You parenthesized '", parenthesized, "'.");

---

In many cases returning a special value is a perfectly fine way to
indicate an error. It does, however, have its downsides. Firstly, what
if the function can already return every possible kind of value? For
example, consider this function that gets the last element from an
array:

> function lastElement(array) {
>   if (array.length > 0)
>     return array[array.length - 1];
>   else
>     return undefined;
> }
>
> show(lastElement([1, 2, undefined]));

So did the array have a last element? Looking at the value
|lastElement| returns, it is impossible to say.

The second issue with returning special values is that it can
sometimes lead to a whole lot of clutter. If a piece of code calls
|between| ten times, it has to check ten times whether |undefined| was
returned. Also, if a function calls |between| but does not have a
strategy to recover from a failure, it will have to check the return
value of |between|, and if it is |undefined|, this function can then
return |undefined| or some other special value to its caller, who in
turn also checks for this value.

Sometimes, when something strange occurs, it would be practical to
just stop doing what we are doing and immediately jump back to a place
that knows how to handle the problem.

Well, we are in luck, a lot of programming languages provide such a
thing. Usually, it is called _exception handling_.

---

The theory behind exception handling goes like this: It is possible
for code to _raise_ (or _throw_) an _exception_, which is a value.
Raising an exception somewhat resembles a super-charged return from a
function -- it does not just jump out of the current function, but
also out of its callers, all the way up to the top-level call that
started the current execution. This is called _unwinding the stack_.
You may remember the _stack_ of function calls that was mentioned in
\\cfunctions. An exception zooms down this stack, throwing away all
the call contexts it encounters.

If they always zoomed right down to the base of the stack, exceptions
would not be of much use, they would just provide a novel way to blow
up your program. Fortunately, it is possible to set obstacles for
exceptions along the stack. These '_catch_' the exception as it is
zooming down, and can do something with it, after which the program
continues running at the point where the exception was caught.

An example:

> function lastElement(array) {
>   if (array.length > 0)
>     return array[array.length - 1];
>   else
>     throw "Can not take the last element of an empty array.";
> }
>
> function lastElementPlusTen(array) {
>   return lastElement(array) + 10;
> }
>
> try {
>   print(lastElementPlusTen([]));
> }
> catch (error) {
>   print("Something went wrong: ", error);
> }

_|throw|_ is the keyword that is used to raise an exception. The
keyword _|try|_ sets up an obstacle for exceptions: When the code in
the block after it raises an exception, the _|catch|_ block will be
executed. The variable named in parentheses after the word |catch| is
the name given to the exception value inside this block.

Note that the function |lastElementPlusTen| completely ignores the
possibility that |lastElement| might go wrong. This is the big
advantage of exceptions -- error-handling code is only necessary at
the point where the error occurs, and the point where it is handled.
The functions in between can forget all about it.

Well, almost.

---

Consider the following: A function |processThing| wants to set a
top-level variable |currentThing| to point to a specific thing while
its body executes, so that other functions can have access to that
thing too. Normally you would of course just pass the thing as an
argument, but assume for a moment that that is not practical. When the
function finishes, |currentThing| should be set back to |null|.

> var currentThing = null;
>
> function processThing(thing) {
>   if (currentThing != null)
>     throw "Oh no! We are already processing a thing!";
>
>   currentThing = thing;
>   /* do complicated processing... */
>   currentThing = null;
> }

But what if the complicated processing raises an exception? In that
case the call to |processThing| will be thrown off the stack by the
exception, and |currentThing| will never be reset to |null|.

|try| statements can also be followed by a _|finally|_ keyword, which
means 'no matter *what* happens, run this code after trying to run the
code in the |try| block'. If a function has to clean something up, the
cleanup code should usually be put into a |finally| block:

> function processThing(thing) {
>   if (currentThing != null)
>     throw "Oh no! We are already processing a thing!";
>
>   currentThing = thing;
>   try {
>     /* do complicated processing... */
>   }
>   finally {
>     currentThing = null;
>   }
> }

---

A lot of errors in programs cause the JavaScript environment to raise
an exception. For example:

> try {
>   print(Sasquatch);
> }
> catch (error) {
>   print("Caught: " + error.message);
> }

In cases like this, special error objects are raised. These always
have a |message| property containing a description of the problem. You
can raise similar objects using the |new| keyword and the _|Error|_
constructor:

> throw new Error("Fire!");

---

When an exception goes all the way to the bottom of the stack without
being caught, it gets handled by the environment. What this means
differs between the different browsers, sometimes a description of the
error is written to some kind of log, sometimes a window pops up
describing the error.

The errors produced by entering code in the console on this page are
always caught by the console, and displayed among the other output.

---

Most programmers consider exceptions purely an error-handling
mechanism. In essence, though, they are just another way of
influencing the control flow of a program. For example, they can be
used as a kind of |break| statement in a recursive function. Here is a
slightly strange function which determines whether an object, and the
objects stored inside it, contain at least seven |true| values:

> var FoundSeven = {};
>
> function hasSevenTruths(object) {
>   var counted = 0;
>
>   function count(object) {
>     for (var name in object) {
>       if (object[name] === true) {
>         counted++;
>         if (counted == 7)
>           throw FoundSeven;
>       }
>       else if (typeof object[name] == "object") {
>         count(object[name]);
>       }
>     }
>   }
>
>   try {
>     count(object);
>     return false;
>   }
>   catch (exception) {
>     if (exception != FoundSeven)
>       throw exception;
>     return true;
>   }
> }

The inner function |count| is recursively called for every object that
is part of the argument. When the variable |counted| reaches seven,
there is no point in continuing to count, but just returning from the
current call to |count| will not necessarily stop the counting, since
there might be more calls below it. So what we do is just throw a
value, which will cause the control to jump right out of any calls to
|count|, and land at the |catch| block.

But just returning |true| in case of an exception is not correct.
Something else might be going wrong, so we first check whether the
exception is the object |FoundSeven|, created specifically for this
purpose. If it is not, this |catch| block does not know how to handle
it, so it raises it again.

This is a pattern that is also common when dealing with error
conditions -- you have to make sure that your |catch| block only
handles exceptions that it knows how to handle. Throwing string
values, as some of the examples in this chapter do, is rarely a good
idea, because it makes it hard to recognise the type of the exception.
A better idea is to use unique values, such as the |FoundSeven|
object, or to introduce a new type of objects, as described in \\coo.

===========================
Functional Programming / fp
===========================

As programs get bigger, they also become more complex and harder to
understand. We all think ourselves pretty clever, of course, but we
are mere human beings, and even a moderate amount of chaos tends to
baffle us. And then it all goes downhill. Working on something you do
not really understand is a bit like cutting random wires on those
time-activated bombs they always have in movies. If you are lucky, you
might get the right one -- especially if you are the hero of the movie
and strike a suitably dramatic pose -- but there is always the
possibility of blowing everything up.

Admittedly, in most cases, breaking a program does not cause any large
explosions. But when a program, by someone's ignorant tinkering, has
degenerated into a ramshackle mass of errors, reshaping it into
something sensible is a terrible labour -- sometimes you might just as
well start over.

@_abstraction_Thus, the programmer is always looking for ways to keep
the complexity of his programs as low as possible. An important way to
do this is to try and make code more abstract. When writing a program,
it is easy to get sidetracked into small details at every point. You
come across some little issue, and you deal with it, and then proceed
to the next little problem, and so on. This makes the code read like a
grandmother's tale.

| Yes, dear, to make pea soup you will need split peas, the dry kind.
| And you have to soak them at least for a night, or you will have to
| cook them for hours and hours. I remember one time, when my dull son
| tried to make pea soup. Would you believe he hadn't soaked the peas?
| We almost broke our teeth, all of us. Anyway, when you have soaked
| the peas, and you'll want about a cup of them per person, and pay
| attention because they will expand a bit while they are soaking, so
| if you aren't careful they will spill out of whatever you use to
| hold them, so also use plenty water to soak in, but as I said, about
| a cup of them, when they are dry, and after they are soaked you cook
| them in four cups of water per cup of dry peas. Let it simmer for
| two hours, which means you cover it and keep it barely cooking, and
| then add some diced onions, sliced celery stalk, and maybe a carrot
| or two and some ham. Let it all cook for a few minutes more, and it
| is ready to eat.

Another way to describe this recipe:

| Per person: one cup dried split peas, half a chopped onion, half a
| carrot, a celery stalk, and optionally ham.
|
| Soak peas overnight, simmer them for two hours in four cups of water
| (per person), add vegetables and ham, and cook for ten more minutes.

This is shorter, but if you don't know how to soak peas you'll surely
screw up and put them in too little water. But how to soak peas can be
looked up, and that is the trick. If you assume a certain basic
knowledge in the audience, you can talk in a language that deals with
bigger concepts, and express things in a much shorter and clearer way.
This, more or less, is what abstraction is.

How is this far-fetched recipe story relevant to programming? Well,
obviously, the recipe is the program. Furthermore, the basic knowledge
that the cook is supposed to have corresponds to the functions and
other constructs that are available to the programmer. If you remember
the introduction of this book, things like |while| make it easier to
build loops, and in \\cdata we wrote some simple functions in order to
make other functions shorter and more straightforward. Such tools,
some of them made available by the language itself, others built by
the programmer, are used to reduce the amount of uninteresting details
in the rest of the program, and thus make that program easier to work
with.

---

@_functional programming_Functional programming, which is the subject
of this chapter, produces abstraction through clever ways of combining
functions. A programmer armed with a repertoire of fundamental
functions and, more importantly, the knowledge on how to use them, is
much more effective than one who starts from scratch. Unfortunately, a
standard JavaScript environment comes with deplorably few essential
functions, so we have to write them ourselves or, which is often
preferable, make use of somebody else's code (more on that in
\\cmodularity).

There are other popular approaches to abstraction, most notably
object-oriented programming, the subject of \\coo.

---

One ugly detail that, if you have any good taste at all, must be
starting to bother you is the endlessly repeated |for| loop going over
an array: |for (var i = 0; i < something.length; i++) ...|. Can this
be abstracted?

The problem is that, whereas most functions just take some values,
combine them, and return something, such a loop contains a piece of
code that it must execute. It is easy to write a function that goes
over an array and prints out every element:

> function printArray(array) {
>   for (var i = 0; i < array.length; i++)
>     print(array[i]);
> }

But what if we want to do something else than print? Since 'doing
something' can be represented as a function, and functions are also
values, we can pass our action as a function value:

> function forEach(array, action) {
>   for (var i = 0; i < array.length; i++)
>     action(array[i]);
> }
>
> forEach(["Wampeter", "Foma", "Granfalloon"], print);

And by making use of an anonymous function, something just like a
|for| loop can be written with less useless details:

> function sum(numbers) {
>   var total = 0;
>   forEach(numbers, function (number) {
>     total += number;
>   });
>   return total;
> }
> show(sum([1, 10, 100]));

Note that the variable |total| is visible inside the anonymous
function because of the lexical scoping rules. Also note that this
version is hardly shorter than the |for| loop and requires a rather
clunky |});| at its end -- the brace closes the body of the anonymous
function, the parenthesis closes the function call to _|forEach|_, and
the semicolon is needed because this call is a statement.

You do get a variable bound to the current element in the array,
|number|, so there is no need to use |numbers[i]| anymore, and when
this array is created by evaluating some expression, there is no need
to store it in a variable, because it can be passed to |forEach|
directly.

The cat-code in \\cdata contains a piece like this:

!> var paragraphs = mailArchive[mail].split("\n");
!> for (var i = 0; i < paragraphs.length; i++)
!>   handleParagraph(paragraphs[i]);

This can now be written as...

!> forEach(mailArchive[mail].split("\n"), handleParagraph);

On the whole, using more abstract (or 'higher level') constructs
results in more information and less noise: The code in |sum| reads
'*for each number in numbers add that number to the total*', instead
of... '*there is this variable that starts at zero, and it counts
upward to the length of the array called numbers, and for every value
of this variable we look up the corresponding element in the array and
add this to the total*'.

---

What |forEach| does is take an algorithm, in this case 'going over an
array', and abstract it. The 'gaps' in the algorithm, in this case,
what to do for each of these elements, are filled by functions which
are passed to the algorithm function.

Functions that operate on other functions are called _higher-order
function_s. By operating on functions, they can talk about actions on
a whole new level. The |makeAddFunction| function from \\cfunctions is
also a higher-order function. Instead of taking a function value as an
argument, it produces a new function.

Higher-order functions can be used to generalise many algorithms that
regular functions can not easily describe. When you have a repertoire
of these functions at your disposal, it can help you think about your
code in a clearer way: Instead of a messy set of variables and loops,
you can decompose algorithms into a combination of a few fundamental
algorithms, which are invoked by name, and do not have to be typed out
again and again.

Being able to write *what* we want to do instead of *how* we do it
means we are working at a higher level of abstraction. In practice,
this means shorter, clearer, and more pleasant code.

---

Another useful type of higher-order function *modifies* the function
value it is given:

> function negate(func) {
>   return function(x) {
>     return !func(x);
>   };
> }
> var isNotNaN = negate(isNaN);
> show(isNotNaN(NaN));

The function returned by |negate| feeds the argument it is given to
the original function |func|, and then negates the result. But what if
the function you want to negate takes more than one argument? You can
get access to any arguments passed to a function with the |arguments|
array, but how do you call a function when you do not know how many
arguments you have?

Functions have a method called _|apply|_, which is used for situations
like this. It takes two arguments. The role of the first argument will
be discussed in \\coo, for now we just use |null| there. The second
argument is an array containing the arguments that the function must
be applied to.

> show(Math.min.apply(null, [5, 6]));
>
> function negate(func) {
>   return function() {
>     return !func.apply(null, arguments);
>   };
> }

Unfortunately, on the Internet Explorer browser a lot of built-in
functions, such as |alert|, are not *really* functions... or
something. They report their type as |"object"| when given to the
|typeof| operator, and they do not have an |apply| method. Your own
functions do not suffer from this, they are always real functions.

---

Let us look at a few more basic algorithms related to arrays. The
|sum| function is really a variant of an algorithm which is usually
called _|reduce|_ or |fold|:

> function reduce(combine, base, array) {
>   forEach(array, function (element) {
>     base = combine(base, element);
>   });
>   return base;
> }
>
> function add(a, b) {
>   return a + b;
> }
>
> function sum(numbers) {
>   return reduce(add, 0, numbers);
> }

|reduce| combines an array into a single value by repeatedly using a
function that combines an element of the array with a base value. This
is exactly what |sum| did, so it can be made shorter by using
|reduce|... except that addition is an operator and not a function in
JavaScript, so we first had to put it into a function.

The reason |reduce| takes the function as its first argument instead
of its last, as in |forEach|, is partly that this is tradition --
other languages do it like that -- and partly that this allows us to
use a particular trick, which will be discussed at the end of this
chapter. It does mean that, when calling |reduce|, writing the
reducing function as an anonymous function looks a bit weirder,
because now the other arguments follow after the function, and the
resemblance to a normal |for| block is lost entirely.

***

Write a function |countZeroes|, which takes an array of numbers as its
argument and returns the amount of zeroes that occur in it. Use
|reduce|.

Then, write the higher-order function |count|, which takes an array
and a test function as arguments, and returns the amount of elements
in the array for which the test function returned |true|. Re-implement
|countZeroes| using this function.

///

> function countZeroes(array) {
>   function counter(total, element) {
>     return total + (element === 0 ? 1 : 0);
>   }
>   return reduce(counter, 0, array);
> }

@_|?:|_The weird part, with the question mark and the colon, uses a
new operator. In \\cbasics we have seen unary and binary operators.
This one is ternary -- it acts on three values. Its effect resembles
that of |if|/|else|, except that, where |if| conditionally executes
statements, this one conditionally chooses expressions. The first
part, before the question mark, is the condition. If this condition is
|true|, the expression after the question mark is chosen, |1| in this
case. If it is |false|, the part after the colon, |0| in this case, is
chosen.

Use of this operator can make some pieces of code much shorter. When
the expressions inside it get very big, or you have to make more
decisions inside the conditional parts, just using plain |if| and
|else| is usually more readable.

Here is the solution that uses a |count| function, with a function
that produces equality-testers included to make the final
|countZeroes| function even shorter:

> function count(test, array) {
>   return reduce(function(total, element) {
>     return total + (test(element) ? 1 : 0);
>   }, 0, array);
> }
>
> function equals(x) {
>   return function(element) {return x === element;};
> }
>
> function countZeroes(array) {
>   return count(equals(0), array);
> }

---

One other generally useful 'fundamental algorithm' related to arrays
is called _|map|_. It goes over an array, applying a function to every
element, just like |forEach|. But instead of discarding the values
returned by function, it builds up a new array from these values.

> function map(func, array) {
>   var result = [];
>   forEach(array, function (element) {
>     result.push(func(element));
>   });
>   return result;
> }
>
> show(map(Math.round, [0.01, 2, 9.89, Math.PI]));

Note that the first argument is called |func|, not |function|, this
is because |function| is a keyword and thus not a valid variable name.

---

There once was, living in the deep mountain forests of Transylvania, a
recluse. Most of the time, he just wandered around his mountain,
talking to trees and laughing with birds. But now and then, when the
pouring rain trapped him in his little hut, and the howling wind made
him feel unbearably small, the recluse felt an urge to write
something, wanted to pour some thoughts out onto paper, where they
could maybe grow bigger than he himself was.

After failing miserably at poetry, fiction, and philosophy, the
recluse finally decided to write a technical book. In his youth, he
had done some computer programming, and he figured that if he could
just write a good book about that, fame and recognition would surely
follow.

So he wrote. At first he used fragments of tree bark, but that turned
out not to be very practical. He went down to the nearest village and
bought himself a laptop computer. After a few chapters, he realised he
wanted to put the book in HTML format, in order to put it on his
web-page...

---

Are you familiar with HTML? It is the method used to add mark-up to
pages on the web, and we will be using it a few times in this book, so
it would be nice if you know how it works, at least generally. If you
are a good student, you could go search the web for a good
introduction to HTML now, and come back here when you have read it.
Most of you probably are lousy students, so I will just give a short
explanation and hope it is enough.

_HTML_ stands for 'HyperText Mark-up Language'. An HTML document is
all text. Because it must be able to express the structure of this
text, information about which text is a heading, which text is purple,
and so on, a few characters have a special meaning, somewhat like
backslashes in JavaScript strings. The 'less than' and 'greater than'
characters are used to create '_tag_s'. A tag gives extra information
about the text in the document. It can stand on its own, for example
to mark the place where a picture should appear in the page, or it can
contain text and other tags, for example when it marks the start and
end of a paragraph.

Some tags are compulsory, a whole HTML document must always be
contained in between |html| tags. Here is an example of an HTML
document:

] <html>
]   <head>
]     <title>A quote</title>
]   </head>
]   <body>
]     <h1>A quote</h1>
]     <blockquote>
]       <p>The connection between the language in which we
]       think/program and the problems and solutions we can imagine
]       is very close.  For this reason restricting language
]       features with the intent of eliminating programmer errors is
]       at best dangerous.</p>
]       <p>-- Bjarne Stroustrup</p>
]     </blockquote>
]     <p>Mr. Stroustrup is the inventor of the C++ programming
]     language, but quite an insightful person nevertheless.</p>
]     <p>Also, here is a picture of an ostrich:</p>
]     <img src="img/ostrich.png"/>
]   </body>
] </html>

Elements that contain text or other tags are first opened with
|<tagname>|, and afterwards finished with |</tagname>|. The |html|
element always contains two children: |head| and |body|. The first
contains information *about* the document, the second contains the
actual document.

Most tag names are cryptic abbreviations. |h1| stands for 'heading 1',
the biggest kind of heading. There are also |h2| to |h6| for
successively smaller headings. |p| means 'paragraph', and |img| stands
for 'image'. The |img| element does not contain any text or other
tags, but it does have some extra information,
|src="img/ostrich.png"|, which is called an '_attribute_'. In this
case, it contains information about the image file that should be
shown here.

Because |<| and |>| have a special meaning in HTML documents, they can
not be written directly in the text of the document. If you want to
say '|5 < 10|' in an HTML document, you have to write '|5 &lt; 10|',
where '|lt|' stands for 'less than'. '|&gt;|' is used for '|>|', and
because these codes also give the ampersand character a special
meaning, a plain '|&|' is written as '|&amp;|'.

Now, those are only the bare basics of HTML, but they should be enough
to make it through this chapter, and later chapters that deal with
HTML documents, without getting entirely confused.

---

The JavaScript console has a function |viewHTML| that can be used to
look at HTML documents. I stored the example document above in the
variable |stroustrupQuote|, so you can view it by executing the
following code:

> viewHTML(stroustrupQuote);

If you have some kind of pop-up blocker installed or integrated in
your browser, it will probably interfere with |viewHTML|, which tries
to show the HTML document in a new window or tab. Try to configure the
blocker to allow pop-ups from this site.

---

So, picking up the story again, the recluse wanted to have his book in
HTML format. At first he just wrote all the tags directly into his
manuscript, but typing all those less-than and greater-than signs made
his fingers hurt, and he constantly forgot to write |&amp;| when he
needed an |&|. This gave him a headache. Next, he tried to write the
book in Microsoft Word, and then save it as HTML. But the HTML that
came out of that was fifteen times bigger and more complicated than it
had to be. And besides, Microsoft Word gave him a headache.

The solution that he eventually came up with was this: He would write
the book as plain text, following some simple rules about the way
paragraphs were separated and the way headings looked. Then, he would
write a program to convert this text into precisely the HTML that he
wanted.

The rules are this:

 1. Paragraphs are separated by blank lines.
 2. A paragraph that starts with a '%' symbol is a header. The more '%' symbols, the smaller the header.
 3. Inside paragraphs, pieces of text can be emphasised by putting them between asterisks.
 4. Footnotes are written between braces.

---

After he had struggled painfully with his book for six months, the
recluse had still only finished a few paragraphs. At this point, his
hut was struck by lightning, killing him, and forever putting his
writing ambitions to rest. From the charred remains of his laptop, I
could recover the following file:

] % The Book of Programming
] 
] %% The Two Aspects
] 
] Below the surface of the machine, the program moves. Without effort,
] it expands and contracts. In great harmony, electrons scatter and
] regroup. The forms on the monitor are but ripples on the water. The
] essence stays invisibly below.
] 
] When the creators built the machine, they put in the processor and the
] memory. From these arise the two aspects of the program.
] 
] The aspect of the processor is the active substance. It is called
] Control. The aspect of the memory is the passive substance. It is
] called Data.
] 
] Data is made of merely bits, yet it takes complex forms. Control
] consists only of simple instructions, yet it performs difficult
] tasks. From the small and trivial, the large and complex arise.
] 
] The program source is Data. Control arises from it. The Control
] proceeds to create new Data. The one is born from the other, the
] other is useless without the one. This is the harmonious cycle of
] Data and Control.
] 
] Of themselves, Data and Control are without structure. The programmers
] of old moulded their programs out of this raw substance. Over time,
] the amorphous Data has crystallised into data types, and the chaotic
] Control was restricted into control structures and functions.
] 
] %% Short Sayings
] 
] When a student asked Fu-Tzu about the nature of the cycle of Data and
] Control, Fu-Tzu replied 'Think of a compiler, compiling itself.'
] 
] A student asked 'The programmers of old used only simple machines and
] no programming languages, yet they made beautiful programs. Why do we
] use complicated machines and programming languages?'. Fu-Tzu replied
] 'The builders of old used only sticks and clay, yet they made
] beautiful huts.'
] 
] A hermit spent ten years writing a program. 'My program can compute
] the motion of the stars on a 286-computer running MS DOS', he proudly
] announced. 'Nobody owns a 286-computer or uses MS DOS anymore.',
] Fu-Tzu responded.
] 
] Fu-Tzu had written a small program that was full of global state and
] dubious shortcuts. Reading it, a student asked 'You warned us against
] these techniques, yet I find them in your program. How can this be?'
] Fu-Tzu said 'There is no need to fetch a water hose when the house is
] not on fire.'{This is not to be read as an encouragement of sloppy
] programming, but rather as a warning against neurotic adherence to
] rules of thumb.}
] 
] %% Wisdom
] 
] A student was complaining about digital numbers. 'When I take the root
] of two and then square it again, the result is already inaccurate!'.
] Overhearing him, Fu-Tzu laughed. 'Here is a sheet of paper. Write down
] the precise value of the square root of two for me.'
] 
] Fu-Tzu said 'When you cut against the grain of the wood, much strength
] is needed. When you program against the grain of a problem, much code
] is needed.'
] 
] Tzu-li and Tzu-ssu were boasting about the size of their latest
] programs. 'Two-hundred thousand lines', said Tzu-li, 'not counting
] comments!'. 'Psah', said Tzu-ssu, 'mine is almost a *million* lines
] already.' Fu-Tzu said 'My best program has five hundred lines.'
] Hearing this, Tzu-li and Tzu-ssu were enlightened.
] 
] A student had been sitting motionless behind his computer for hours,
] frowning darkly. He was trying to write a beautiful solution to a
] difficult problem, but could not find the right approach. Fu-Tzu hit
] him on the back of his head and shouted '*Type something!*' The student
] started writing an ugly solution. After he had finished, he suddenly
] understood the beautiful solution.
] 
] %% Progression
] 
] A beginning programmer writes his programs like an ant builds her
] hill, one piece at a time, without thought for the bigger structure.
] His programs will be like loose sand. They may stand for a while, but
] growing too big they fall apart{Referring to the danger of internal
] inconsistency and duplicated structure in unorganised code.}.
] 
] Realising this problem, the programmer will start to spend a lot of
] time thinking about structure. His programs will be rigidly
] structured, like rock sculptures. They are solid, but when they must
] change, violence must be done to them{Referring to the fact that
] structure tends to put restrictions on the evolution of a program.}.
] 
] The master programmer knows when to apply structure and when to leave
] things in their simple form. His programs are like clay, solid yet
] malleable.
] 
] %% Language
] 
] When a programming language is created, it is given syntax and
] semantics. The syntax describes the form of the program, the semantics
] describe the function. When the syntax is beautiful and the semantics
] are clear, the program will be like a stately tree. When the syntax is
] clumsy and the semantics confusing, the program will be like a bramble
] bush.
] 
] Tzu-ssu was asked to write a program in the language called Java,
] which takes a very primitive approach to functions. Every morning, as
] he sat down in front of his computer, he started complaining. All day
] he cursed, blaming the language for all that went wrong. Fu-Tzu
] listened for a while, and then reproached him, saying 'Every language
] has its own way. Follow its form, do not try to program as if you
] were using another language.'

---

To honour the memory of our good recluse, I would like to finish his
HTML-generating program for him. A good approach to this problem goes
like this:

 1. Split the file into paragraphs by cutting it at every empty line.
 2. Remove the '%' characters from header paragraphs and mark them as headers.
 3. Process the text of the paragraphs themselves, splitting them into normal parts, emphasised parts, and footnotes.
 4. Move all the footnotes to the bottom of the document, leaving numbers## in their place.
 5. Wrap each piece into the correct HTML tags.
 6. Combine everything into a single HTML document.

## Like this...

This approach does not allow footnotes inside emphasised text, or vice
versa. This is kind of arbitrary, but helps keep the example code
simple. If, at the end of the chapter, you feel like an extra
challenge, you can try to revise the program to support 'nested'
mark-up.

The whole manuscript, as a string value, is available on this page
by calling |recluseFile| function.

---

Step 1 of the algorithm is trivial. A blank line is what you get when
you have two newlines in a row, and if you remember the |split| method
that strings have, which we saw in \\cdata, you will realise that this
will do the trick:

> var paragraphs = recluseFile().split("\n\n");
> print("Found ", paragraphs.length, " paragraphs.");

***

Write a function |processParagraph| that, when given a paragraph
string as its argument, checks whether this paragraph is a header. If
it is, it strips off the '%' characters and counts their number. Then,
it returns an object with two properties, |content|, which contains
the text inside the paragraph, and |type|, which contains the tag that
this paragraph must be wrapped in, |"p"| for regular paragraphs,
|"h1"| for headers with one '%', and |"hX"| for headers with |X| '%'
characters.

Remember that strings have a |charAt| method that can be used to look
at a specific character inside them.

///

> function processParagraph(paragraph) {
>   var header = 0;
>   while (paragraph.charAt(0) == "%") {
>     paragraph = paragraph.slice(1);
>     header++;
>   }
>
>   return {type: (header == 0 ? "p" : "h" + header),
>           content: paragraph};
> }
>
> show(processParagraph(paragraphs[0]));

---

This is where we can try out the |map| function we saw earlier.

> var paragraphs = map(processParagraph,
>                      recluseFile().split("\n\n"));

And *bang*, we have an array of nicely categorised paragraph objects.
We are getting ahead of ourselves though, we forgot step 3 of the
algorithm:

| Process the text of the paragraphs themselves, splitting them into
| normal parts, emphasised parts, and footnotes.

Which can be decomposed into:

 1. If the paragraph starts with an asterisk, take off the emphasised part and store it.
 2. If the paragraph starts with an opening brace, take off the footnote and store it.
 3. Otherwise, take off the part until the first emphasised part or footnote, or until the end of the string, and store it as normal text.
 4. If there is anything left in the paragraph, start at 1 again.

***

Build a function |splitParagraph| which, given a paragraph string,
returns an array of paragraph fragments. Think of a good way to
represent the fragments.

The method |indexOf|, which searches for a character or sub-string in
a string and returns its position, or |-1| if not found, will probably
be useful in some way here.

This is a tricky algorithm, and there are many not-quite-correct or
way-too-long ways to describe it. If you run into problems, just think
about it for a minute. Try to write inner functions that perform the
smaller actions that make up the algorithm.

///

Here is one possible solution:

> function splitParagraph(text) {
>   function indexOrEnd(character) {
>     var index = text.indexOf(character);
>     return index == -1 ? text.length : index;
>   }
>
>   function takeNormal() {
>     var end = reduce(Math.min, text.length,
>                      map(indexOrEnd, ["*", "{"]));
>     var part = text.slice(0, end);
>     text = text.slice(end);
>     return part;
>   }
>
>   function takeUpTo(character) {
>     var end = text.indexOf(character, 1);
>     if (end == -1)
>       throw new Error("Missing closing '" + character + "'");
>     var part = text.slice(1, end);
>     text = text.slice(end + 1);
>     return part;
>   }
>
>   var fragments = [];
>
>   while (text != "") {
>     if (text.charAt(0) == "*")
>       fragments.push({type: "emphasised",
>                       content: takeUpTo("*")});
>     else if (text.charAt(0) == "{")
>       fragments.push({type: "footnote",
>                       content: takeUpTo("}")});
>     else
>       fragments.push({type: "normal",
>                       content: takeNormal()});
>   }
>   return fragments;
> }

Note the over-eager use of |map| and |reduce| in the |takeNormal|
function. This is a chapter about functional programming, so program
functionally we will! Can you see how this works? The |map| produces
an array of positions where the given characters were found, or the
end of the string if they were not found, and the |reduce| takes the
minimum of them, which is the next point in the string that we have to
look at.

If you'd write that out without mapping and reducing you'd get
something like this:

!> var nextAsterisk = text.indexOf("*");
!> var nextBrace = text.indexOf("{");
!> var end = text.length;
!> if (nextAsterisk != -1)
!>   end = nextAsterisk;
!> if (nextBrace != -1 && nextBrace < end)
!>   end = nextBrace;

Which is even more hideous. Most of the time, when a decision has to
be made based on a series of things, even if there are only two of
them, writing it as array operations is nicer than handling every
value in a separate |if| statement. (Fortunately, \\cregexp describes
an easier way to ask for the first occurrence of 'this or that
character' in a string.)

If you wrote a |splitParagraph| that stored fragments in a different
way than the solution above, you might want to adjust it, because the
functions in the rest of the chapter assume that fragments are objects
with |type| and |content| properties.

---

We can now wire |processParagraph| to also split the text inside the
paragraphs, my version can be modified like this:

> function processParagraph(paragraph) {
>   var header = 0;
>   while (paragraph.charAt(0) == "%") {
>     paragraph = paragraph.slice(1);
>     header++;
>   }
>
>   return {type: (header == 0 ? "p" : "h" + header),
>           content: splitParagraph(paragraph)};
> }

Mapping that over the array of paragraphs gives us an array of
paragraph objects, which in turn contain arrays of fragment objects.
The next thing to do is to take out the footnotes, and put references
to them in their place. Something like this:

> function extractFootnotes(paragraphs) {
>   var footnotes = [];
>   var currentNote = 0;
>
>   function replaceFootnote(fragment) {
>     if (fragment.type == "footnote") {
>       currentNote++;
>       footnotes.push(fragment);
>       fragment.number = currentNote;
>       return {type: "reference", number: currentNote};
>     }
>     else {
>       return fragment;
>     }
>   }
>
>   forEach(paragraphs, function(paragraph) {
>     paragraph.content = map(replaceFootnote,
>                             paragraph.content);
>   });
>
>   return footnotes;
> }     

The |replaceFootnote| function is called on every fragment. When it
gets a fragment that should stay where it is, it just returns it, but
when it gets a footnote, it stores this footnote in the |footnotes|
array, and returns a reference to it instead. In the process, every
footnote and reference is also numbered.

---

That gives us enough tools to extract the information we need from the
file. All that is left now is generating the correct HTML.

A lot of people think that concatenating strings is a great way to
produce HTML. When they need a link to, for example, a site where you
can play the game of Go, they will do:

> var url = "http://www.gokgs.com/";
> var text = "Play Go!";
> var linkText = "<a href=\"" + url + "\">" + text + "</a>";
> print(linkText);

(Where |a| is the tag used to create links in HTML documents.) ... Not
only is this clumsy, but when the string |text| happens to include an
angular bracket or an ampersand, it is also wrong. Weird things will
happen on your website, and you will look embarrassingly amateurish.
We wouldn't want that to happen. A few simple HTML-generating
functions are easy to write. So let us write them.

---

The secret to successful HTML generation is to treat your HTML
document as a data structure instead of a flat piece of text.
JavaScript's objects provide a very easy way to model this:

> var linkObject = {name: "a",
>                   attributes: {href: "http://www.gokgs.com/"},
>                   content: ["Play Go!"]};

Each HTML element contains a |name| property, giving the name of the
tag it represents. When it has attributes, it also contains an
|attributes| property, which contains an object in which the
attributes are stored. When it has content, there is a |content|
property, containing an array of other elements contained in this
element. Strings play the role of pieces of text in our HTML document,
so the array |["Play Go!"]| means that this link has only one element
inside it, which is a simple piece of text.

Typing in these objects directly is clumsy, but we don't have to do
that. We provide a shortcut function to do this for us:

> function tag(name, content, attributes) {
>   return {name: name, attributes: attributes, content: content};
> }

Note that, since we allow the |attributes| and |content| of an element
to be undefined if they are not applicable, the second and third
argument to this function can be left off when they are not needed.

|tag| is still rather primitive, so we write shortcuts for common
types of elements, such as links, or the outer structure of a simple
document:

> function link(target, text) {
>   return tag("a", [text], {href: target});
> }
>
> function htmlDoc(title, bodyContent) {
>   return tag("html", [tag("head", [tag("title", [title])]),
>                       tag("body", bodyContent)]);
> }

***

Looking back at the example HTML document if necessary, write an
|image| function which, when given the location of an image file, will
create an |img| HTML element.

///

> function image(src) {
>   return tag("img", [], {src: src});
> }

---

When we have created a document, it will have to be reduced to a
string. But building this string from the data structures we have been
producing is very straightforward. The important thing is to remember
to transform the special characters in the text of our document...

> function escapeHTML(text) {
>   var replacements = [[/&/g, "&amp;"], [/"/g, "&quot;"],
>                       [/</g, "&lt;"], [/>/g, "&gt;"]];
>   forEach(replacements, function(replace) {
>     text = text.replace(replace[0], replace[1]);
>   });
>   return text;
> }

The |replace| method of strings creates a new string in which all
occurrences of the pattern in the first argument are replaced by the
second argument, so |"Borobudur".replace(/r/g, "k")| gives
|"Bokobuduk"|. Don't worry about the pattern syntax here -- we'll get
to that in \\cregexp. The |escapeHTML| function puts the different
replacements that have to be made into an array, so that it can loop
over them and apply them to the argument one by one.

Double quotes are also replaced, because we will also be using this
function for the text inside the attributes of HTML tags. Those will
be surrounded by double quotes, and thus must not have any double
quotes inside of them.

Calling replace four times means the computer has to go over the whole
string four times to check and replace its content. This is not very
efficient. If we cared enough, we could write a more complex version
of this function, something that resembles the |splitParagraph|
function we saw earlier, to go over it only once. For now, we are too
lazy for this. Again, \\cregexp shows a much better way to do this.

---

To turn an HTML element object into a string, we can use a recursive
function like this:

> function renderHTML(element) {
>   var pieces = [];
>
>   function renderAttributes(attributes) {
>     var result = [];
>     if (attributes) {
>       for (var name in attributes) 
>         result.push(" " + name + "=\"" +
>                     escapeHTML(attributes[name]) + "\"");
>     }
>     return result.join("");
>   }
>
>   function render(element) {
>     // Text node
>     if (typeof element == "string") {
>       pieces.push(escapeHTML(element));
>     }
>     // Empty tag
>     else if (!element.content || element.content.length == 0) {
>       pieces.push("<" + element.name +
>                   renderAttributes(element.attributes) + "/>");
>     }
>     // Tag with content
>     else {
>       pieces.push("<" + element.name +
>                   renderAttributes(element.attributes) + ">");
>       forEach(element.content, render);
>       pieces.push("</" + element.name + ">");
>     }
>   }
>
>   render(element);
>   return pieces.join("");
> }

Note the |in| loop that extracts the properties from a JavaScript
object in order to make HTML tag attributes out of them. Also note
that in two places, arrays are being used to accumulate strings, which
are then joined into a single result string. Why didn't I just start
with an empty string and then add the content to it with the |+=|
operator?

It turns out that creating new strings, especially big strings, is
quite a lot of work. Remember that JavaScript string values never
change. If you concatenate something to them, a new string is created,
the old ones stay intact. If we build up a big string by concatenating
lots of little strings, new strings have to be created at every step,
only to be thrown away when the next piece is concatenated to them.
If, on the other hand, we store all the little strings in an array and
then join them, only *one* big string has to be created.

---

So, let us try out this HTML generating system...

> print(renderHTML(link("http://www.nedroid.com", "Drawings!")));

That seems to work.

> var body = [tag("h1", ["The Test"]),
>             tag("p", ["Here is a paragraph, and an image..."]),
>             image("img/sheep.png")];
> var doc = htmlDoc("The Test", body);
> viewHTML(renderHTML(doc));

Now, I should probably warn you that this approach is not perfect.
What it actually renders is _XML_, which is similar to HTML, but more
structured. In simple cases, such as the above, this does not cause
any problems. However, there are some things, which are correct XML,
but not proper HTML, and these might confuse a browser that is trying
to show the documents we create. For example, if you have an empty
|script| tag (used to put JavaScript into a page) in your document,
browsers will not realise that it is empty and think that everything
after it is JavaScript. (In this case, the problem can be fixed by
putting a single space inside of the tag, so that it is no longer
empty, and gets a proper closing tag.)

***

Write a function |renderFragment|, and use that to implement another
function |renderParagraph|, which takes a paragraph object (with the
footnotes already filtered out), and produces the correct HTML element
(which might be a paragraph or a header, depending on the |type|
property of the paragraph object).

This function might come in useful for rendering the footnote
references:

> function footnote(number) {
>   return tag("sup", [link("#footnote" + number,
>                           String(number))]);
> }

A |sup| tag will show its content as 'superscript', which means it
will be smaller and a little higher than other text. The target of the
link will be something like |"#footnote1"|. Links that contain a '#'
character refer to 'anchors' within a page, and in this case we will
use them to make it so that clicking on the footnote link will take
the reader to the bottom of the page, where the footnotes live.

The tag to render emphasised fragments with is |em|, and normal text
can be rendered without any extra tags.

///

> function renderParagraph(paragraph) {
>   return tag(paragraph.type, map(renderFragment,
>                                  paragraph.content));
> }
>
> function renderFragment(fragment) {
>   if (fragment.type == "reference")
>     return footnote(fragment.number);
>   else if (fragment.type == "emphasised")
>     return tag("em", [fragment.content]);
>   else if (fragment.type == "normal")
>     return fragment.content;
> }

---

We are almost finished. The only thing that we do not have a rendering
function for yet are the footnotes. To make the |"#footnote1"| links
work, an anchor must be included with every footnote. In HTML, an
anchor is specified with an |a| element, which is also used for links.
In this case, it needs a |name| attribute, instead of an |href|.

> function renderFootnote(footnote) {
>   var anchor = tag("a", [], {name: "footnote" + footnote.number});
>   var number = "[" + footnote.number + "] ";
>   return tag("p", [tag("small", [anchor, number,
>                                  footnote.content])]);
> }

Here, then, is the function which, when given a file in the correct
format and a document title, returns an HTML document:

> function renderFile(file, title) {
>   var paragraphs = map(processParagraph, file.split("\n\n"));
>   var footnotes = map(renderFootnote,
>                       extractFootnotes(paragraphs));
>   var body = map(renderParagraph, paragraphs).concat(footnotes);
>   return renderHTML(htmlDoc(title, body));
> }
>
> viewHTML(renderFile(recluseFile(), "The Book of Programming"));

The _|concat|_ method of an array can be used to concatenate another
array to it, similar to what the |+| operator does with strings.

---

In the chapters after this one, elementary higher-order functions like
|map| and |reduce| will always be available and will be used by code
examples. Now and then, a new useful tool is added to this. In
\\cmodularity, we develop a more structured approach to this set of
'basic' functions.

---

When using higher-order functions, it is often annoying that operators
are not functions in JavaScript. We have needed |add| or |equals|
functions at several points. Rewriting these every time, you will
agree, is a pain. From now on, we will assume the existence of an
object called |op|, which contains these functions:

> var op = {
>   "+": function(a, b){return a + b;},
>   "==": function(a, b){return a == b;},
>   "===": function(a, b){return a === b;},
>   "!": function(a){return !a;}
>   /* and so on */
> };

So we can write |reduce(op["+"], 0, [1, 2, 3, 4, 5])| to sum an array.
But what if we need something like |equals| or |makeAddFunction|, in
which one of the arguments already has a value? In that case we are
back to writing a new function again.

For cases like that, something called '_partial application_' is
useful. You want to create a new function that already knows some of
its arguments, and treats any additional arguments it is passed as
coming after these fixed arguments. This can be done by making
creative use of the |apply| method of a function:

> function asArray(quasiArray, start) {
>   var result = [];
>   for (var i = (start || 0); i < quasiArray.length; i++)
>     result.push(quasiArray[i]);
>   return result;
> }
>
> function partial(func) {
>   var fixedArgs = asArray(arguments, 1);
>   return function(){
>     return func.apply(null, fixedArgs.concat(asArray(arguments)));
>   };
> }

We want to allow binding multiple arguments at the same time, so the
|asArray| function is necessary to make normal arrays out of the
|arguments| objects. It copies their content into a real array, so
that the |concat| method can be used on it. It also takes an optional
second argument, which can be used to leave out some arguments at the
start.

Also note that it is necessary to store the |arguments| of the outer
function (|partial|) into a variable with another name, because
otherwise the inner function can not see them -- it has its own
|arguments| variable, which shadows the one of the outer function.

Now |equals(10)| can be written as |partial(op["=="], 10)|.

> show(map(partial(op["+"], 1), [0, 2, 4, 6, 8, 10]));

The reason |map| takes its function argument before its array argument
is that it is often useful to partially apply map by giving it a
function. This 'lifts' the function from operating on a single value
to operating on an array of values. For example, if you have an array
of arrays of numbers, and you want to square them all, you do this:

> function square(x) {return x * x;}
>
> show(map(partial(map, square), [[10, 100], [12, 16], [0, 1]]));

---

One last trick that can be useful when you want to combine functions
is _function composition_. At the start of this chapter I showed a
function |negate|, which applies the boolean *not* operator to the
result of calling a function:

> function negate(func) {
>   return function() {
>     return !func.apply(null, arguments);
>   };
> }

This is a special case of a general pattern: call function A, and then
apply function B to the result. Composition is a common concept in
mathematics. @_|compose|_It can be caught in a higher-order function
like this:

> function compose(func1, func2) {
>   return function() {
>     return func1(func2.apply(null, arguments));
>   };
> }
>
> var isUndefined = partial(op["==="], undefined);
> var isDefined = compose(op["!"], isUndefined);
> show(isDefined(Math.PI));
> show(isDefined(Math.PIE));

Here we are defining new functions without using the |function|
keyword at all. This can be useful when you need to create a simple
function to give to, for example, |map| or |reduce|. However, when a
function becomes more complex than these examples, it is usually
shorter (not to mention more efficient) to just write it out with
|function|.

==================
Searching / search
==================

This chapter does not introduce any new JavaScript-specific concepts.
Instead, we will go through the solution to two problems, discussing
some interesting algorithms and techniques along the way. If this does
not sound interesting to you, it is safe to skip to the next chapter.

---

Let me introduce our first problem. Take a look at this map. It shows
Hiva Oa, a small tropical island in the Pacific Ocean.

[[Hiva Oa.png]]

The grey lines are roads, and the numbers next to them are the lengths
of these roads. Imagine we need a program that finds the shortest
route between two points on Hiva Oa. How could we approach that? Think
about this for a moment.

No really. Don't just steamroll on to the next paragraph. Try to
seriously think of some ways you could do this, and consider the
issues you would come up against. When reading a technical book, it is
way too easy to just zoom over the text, nod solemnly, and promptly
forget what you have read. If you make a sincere effort to solve a
problem, it becomes *your* problem, and its solution will be more
meaningful.

---

The first aspect of this problem is, again, representing our data. The
information in the picture does not mean much to our computer. We
could try writing a program that looks at the map and extracts the
information in it... but that can get complicated. If we had
twenty-thousand maps to interpret, this would be a good idea, in this
case we will do the interpretation ourself and transcribe the map into
a more computer-friendly format.

What does our program need to know? It has to be able to look up which
locations are connected, and how long the roads between them are. The
places and roads on the island form a _graph_, as mathematicians call
it. There are many ways to store graphs. A simple possibility is to
just store an array of road objects, each of which contains properties
naming its two endpoints and its length...

> var roads = [{point1: "Point Kiukiu", point2: "Hanaiapa", length: 19},
>              {point1: "Point Kiukiu", point2: "Mt Feani", length: 15}
>              /* and so on */];

However, it turns out that the program, as it is working out a route,
will very often need to get a list of all the roads that start at a
certain location, like a person standing on a crossroads will look at
a signpost and read "Hanaiapa: 19km, Mount Feani: 15km". It would be
nice if this was easy (and quick) to do.

With the representation given above, we have to sift through the whole
list of roads, picking out the relevant ones, every time we want this
signpost list. A better approach would be to store this list directly.
For example, use an object that associates place-names with signpost
lists:

> var roads = {"Point Kiukiu": [{to: "Hanaiapa", distance: 19},
>                               {to: "Mt Feani", distance: 15},
>                               {to: "Taaoa", distance: 15}],
>              "Taaoa": [/* et cetera */]};

When we have this object, getting the roads that leave from Point
Kiukiu is just a matter of looking at |roads["Point Kiukiu"]|.

---

However, this new representation does contain duplicate information:
The road between A and B is listed both under A and under B. The first
representation was already a lot of work to type in, this one is even
worse.

Fortunately, we have at our command the computer's talent for
repetitive work. We can specify the roads once, and have the correct
data structure be generated by the computer. First, initialise an
empty object called |roads|, and write a function |makeRoad|:

> var roads = {};
> function makeRoad(from, to, length) {
>   function addRoad(from, to) {
>     if (!(from in roads))
>       roads[from] = [];
>     roads[from].push({to: to, distance: length});
>   }
>   addRoad(from, to);
>   addRoad(to, from);
> }

Nice, huh? Notice how the inner function, |addRoad|, uses the same
names (|from|, |to|) for its parameters as the outer function. These
will not interfere: inside |addRoad| they refer to |addRoad|'s
parameters, and outside it they refer to |makeRoad|'s parameters.

The |if| statement in |addRoad| makes sure that there is an array of
destinations associated with the location named by |from|, if there
isn't already one it puts in an empty array. This way, the next line
can assume there is such an array and safely push the new road onto
it.

Now the map information looks like this:

> makeRoad("Point Kiukiu", "Hanaiapa", 19);
> makeRoad("Point Kiukiu", "Mt Feani", 15);
> makeRoad("Point Kiukiu", "Taaoa", 15);
> // ...

***

In the above description, the string |"Point Kiukiu"| still occurs
three times in a row. We could make our description even more succinct
by allowing multiple roads to be specified in one line.

Write a function |makeRoads| that takes any uneven number of
arguments. The first argument is always the starting point of the
roads, and every pair of arguments after that gives an ending point
and a distance.

Do not duplicate the functionality of |makeRoad|, but have |makeRoads|
call |makeRoad| to do the actual road-making.

///

> function makeRoads(start) {
>   for (var i = 1; i < arguments.length; i += 2)
>     makeRoad(start, arguments[i], arguments[i + 1]);
> }

This function uses one named parameter, |start|, and gets the other
parameters from the |arguments| (quasi-) array. |i| starts at |1|
because it has to skip this first parameter. |i += 2| is short for |i
= i + 2|, as you might recall.

> var roads = {};
> makeRoads("Point Kiukiu", "Hanaiapa", 19,
>           "Mt Feani", 15, "Taaoa", 15);
> makeRoads("Airport", "Hanaiapa", 6, "Mt Feani", 5,
>           "Atuona", 4, "Mt Ootua", 11);
> makeRoads("Mt Temetiu", "Mt Feani", 8, "Taaoa", 4);
> makeRoads("Atuona", "Taaoa", 3, "Hanakee pearl lodge", 1);
> makeRoads("Cemetery", "Hanakee pearl lodge", 6, "Mt Ootua", 5);
> makeRoads("Hanapaoa", "Mt Ootua", 3);
> makeRoads("Puamua", "Mt Ootua", 13, "Point Teohotepapapa", 14);
>
> show(roads["Airport"]);

---

We managed to considerably shorten our description of the
road-information by defining some convenient operations. You could say
we expressed the information more succinctly by expanding our
vocabulary. @_domain-specific language_Defining a 'little language'
like this is often a very powerful technique -- when, at any time, you
find yourself writing repetitive or redundant code, stop and try to
come up with a vocabulary that makes it shorter and denser.

Redundant code is not only a bore to write, it is also error-prone,
people pay less attention when doing something that doesn't require
them to think. On top of that, repetitive code is hard to change,
because structure that is repeated a hundred times has to be changed a
hundred times when it turns out to be incorrect or suboptimal.

---

If you ran all the pieces of code above, you should now have a
variable named |roads| that contains all the roads on the island. When
we need the roads starting from a certain place, we could just do
|roads[place]|. But then, when someone makes a typo in a place name,
which is not unlikely with these names, he will get |undefined|
instead of the array he expects, and strange errors will follow.
Instead, we will use a function that retrieves the road arrays, and
yells at us when we give it an unknown place name:

> function roadsFrom(place) {
>   var found = roads[place];
>   if (found == undefined)
>     throw new Error("No place named '" + place + "' found.");
>   else
>     return found;
> }
>
> show(roadsFrom("Puamua"));

---

Here is a first stab at a path-finding algorithm, the gambler's method:

> function gamblerPath(from, to) {
>   function randomInteger(below) {
>     return Math.floor(Math.random() * below);
>   }
>   function randomDirection(from) {
>     var options = roadsFrom(from);
>     return options[randomInteger(options.length)].to;
>   }
>
>   var path = [];
>   while (true) {
>     path.push(from);
>     if (from == to)
>       break;
>     from = randomDirection(from);
>   }
>   return path;
> }
>
> show(gamblerPath("Hanaiapa", "Mt Feani"));

At every split in the road, the gambler rolls his dice to decide which
road he shall take. If the dice sends him back the way he came, so be
it. Sooner or later, he will arrive at his destination, since all
places on the island are connected by roads.

The most confusing line is probably the one containing
_|Math.random|_. This function returns a pseudo-random## number
between 0 and 1. Try calling it a few times from the console, it will
(most likely) give you a different number every time. The function
|randomInteger| multiplies this number by the argument it is given,
and rounds the result down with |Math.floor|. Thus, for example,
|randomInteger(3)| will produce the number |0|, |1|, or |2|.

## Computers are deterministic machines: They always react in the same
way to the input they receive, so they can not produce truly random
values. Therefore, we have to make do with series of numbers that look
random, but are in fact the result of some complicated deterministic
computation.

---

The gambler's method is the way to go for those who abhor structure
and planning, who desperately search for adventure. We set out to
write a program that could find the *shortest* route between places
though, so something else will be needed.

A very straightforward approach to solving such a problem is called
'_generate and test_'. It goes like this:

 1. Generate all possible routes.
 2. In this set, find the shortest one that actually connects the start point to the end point.

Step two is not hard. Step one is a little problematic. If you allow
routes with circles in them, there is an infinite amount of routes. Of
course, routes with circles in them are unlikely to be the shortest
route to anywhere, and routes that do not start at the start point do
not have to be considered either. For a small graph like Hiva Oa, it
should be possible to generate all non-cyclic (circle-free) routes
starting from a certain point.

---

But first, we will need some new tools. The first is a function named
|member|, which is used to determine whether an element is found
within an array. The route will be kept as an array of names, and when
arriving at a new place, the algorithm calls |member| to check whether
we have been at that place already. It could look like this:

> function member(array, value) {
>   var found = false;
>   forEach(array, function(element) {
>     if (element === value)
>       found = true;
>   });
>   return found;
> }
>
> print(member([6, 7, "Bordeaux"], 7));

However, this will go over the whole array, even if the value is found
immediately at the first position. What wastefulness. When using a
|for| loop, you can use the |break| statement to jump out of it, but
in a |forEach| construct this will not work, because the body of the
loop is a function, and |break| statements do not jump out of
functions. One solution could be to adjust |forEach| to recognise a
certain kind of exceptions as signalling a break.

> var Break = {toString: function() {return "Break";}};
>
> function forEach(array, action) {
>   try {
>     for (var i = 0; i < array.length; i++)
>       action(array[i]);
>   }
>   catch (exception) {
>     if (exception != Break)
>       throw exception;
>   }
> }

Now, if the |action| function throws |Break|, |forEach| will absorb
the exception and stop looping. The object stored in the variable
|Break| is used purely as a thing to compare with. The only reason I
gave it a |toString| property is that this might be useful to figure
out what kind of strange value you are dealing with if you somehow end
up with a |Break| exception outside of a |forEach|.

---

Having a way to break out of |forEach| loops can be very useful, but
in the case of the |member| function the result is still rather ugly,
because you need to specifically store the result and later return it.
We could add yet another kind of exception, |Return|, which can be
given a |value| property, and have |forEach| return this value when
such an exception is thrown, but this would be terribly ad-hoc and
messy. What we really need is a whole new higher-order function,
called _|any|_ (or sometimes |some|). It looks like this:

> function any(test, array) {
>   for (var i = 0; i < array.length; i++) {
>     var found = test(array[i]);
>     if (found)
>       return found;
>   }
>   return false;
> }
>
> function member(array, value) {
>   return any(partial(op["==="], value), array);
> }
>
> print(member(["Fear", "Loathing"], "Denial"));

|any| goes over the elements in an array, from left to right, and
applies the test function to them. The first time this returns a
true-ish value, it returns that value. If no true-ish value is found,
|false| is returned. Calling |any(test, array)| is more or less
equivalent to doing |test(array[0]) || test(array[1]) || ...|
etcetera.

---

Just like |&&| is the companion of ||||, |any| has a companion called
_|every|_:

> function every(test, array) {
>   for (var i = 0; i < array.length; i++) {
>     var found = test(array[i]);
>     if (!found)
>       return found;
>   }
>   return true;
> }
>
> show(every(partial(op["!="], 0), [1, 2, -1]));

---

Another function we will need is |flatten|. This function takes an
array of arrays, and puts the elements of the arrays together in one
big array.

>   function flatten(arrays) {
>     var result = [];
>     forEach(arrays, function (array) {
>       forEach(array, function (element){result.push(element);});
>     });
>     return result;
>   }

The same could have been done using the |concat| method and some kind
of |reduce|, but this would be less efficient. Just like repeatedly
concatenating strings together is slower than putting them into an
array and then calling |join|, repeatedly concatenating arrays
produces a lot of unnecessary intermediary array values.

***

Before starting to generate routes, we need one more higher-order
function. This one is called _|filter|_. Like |map|, it takes a
function and an array as arguments, and produces a new array, but
instead of putting the results of calling the function in the new
array, it produces an array with only those values from the old array
for which the given function returns a true-like value. Write this
function.

///

> function filter(test, array) {
>   var result = [];
>   forEach(array, function (element) {
>     if (test(element))
>       result.push(element);
>   });
>   return result;
> }
>
> show(filter(partial(op[">"], 5), [0, 4, 8, 12]));

(If the result of that application of |filter| surprises you, remember
that the argument given to |partial| is used as the *first* argument
of the function, so it ends up to the left of the |>|.)

---

Imagine what an algorithm to generate routes would look like -- it
starts at the starting location, and starts to generate a route for
every road leaving there. At the end of each of these roads it
continues to generate more routes. It doesn't run along one road, it
branches out. Because of this, _recursion_ is a natural way to model
it.

> function possibleRoutes(from, to) {
>   function findRoutes(route) {
>     function notVisited(road) {
>       return !member(route.places, road.to);
>     }
>     function continueRoute(road) {
>       return findRoutes({places: route.places.concat([road.to]),
>                          length: route.length + road.distance});
>     }
>
>     var end = route.places[route.places.length - 1];
>     if (end == to)
>       return [route];
>     else
>       return flatten(map(continueRoute, filter(notVisited,
>                                                roadsFrom(end))));
>   }
>   return findRoutes({places: [from], length: 0});
> }
>
> show(possibleRoutes("Point Teohotepapapa", "Point Kiukiu").length);
> show(possibleRoutes("Hanapaoa", "Mt Ootua"));

The function returns an array of route objects, each of which contains
an array of places that the route passes, and a length. |findRoutes|
recursively continues a route, returning an array with every possible
extension of that route. When the end of a route is the place where we
want to go, it just returns that route, since continuing past that
place would be pointless. If it is another place, we must go on. The
|flatten|/|map|/|filter| line is probably the hardest to read. This is
what it says: 'Take all the roads going from the current location,
discard the ones that go to places that this route has already
visited. Continue each of these roads, which will give an array of
finished routes for each of them, then put all these routes into a
single big array that we return.'

That line does a lot. This is why good abstractions help: They allow
you to say complicated things without typing screenfulls of code.

Doesn't this recurse forever, seeing how it keeps calling itself (via
|continueRoute|)? No, at some point, all outgoing roads will go to
places that a route has already passed, and the result of |filter|
will be an empty array. Mapping over an empty array produces an empty
array, and flattening that still gives an empty array. So calling
|findRoutes| on a dead end produces an empty array, meaning 'there are
no ways to continue this route'.

Notice that places are appended to routes by using _|concat|_, not
_|push|_. The |concat| method creates a new array, while |push|
modifies the existing array. Because the function might branch off
several routes from a single partial route, we must not modify the
array that represents the original route, because it must be used
several times.

***

Now that we have all possible routes, let us try to find the shortest
one. Write a function |shortestRoute| that, like |possibleRoutes|,
takes the names of a starting and ending location as arguments. It
returns a single route object, of the type that |possibleRoutes|
produces.

///

> function shortestRoute(from, to) {
>   var currentShortest = null;
>   forEach(possibleRoutes(from, to), function(route) {
>     if (!currentShortest || currentShortest.length > route.length)
>       currentShortest = route;
>   });
>   return currentShortest;
> }

The tricky thing in 'minimising' or 'maximising' algorithms is to not
screw up when given an empty array. In this case, we happen to know
that there is at least one road between every two places, so we could
just ignore it. But that would be a bit lame. What if the road from
Puamua to Mount Ootua, which is steep and muddy, is washed away by a
rainstorm? It would be a shame if this caused our function to break as
well, so it takes care to return |null| when no routes are found.

Then, the very functional, abstract-everything-we-can approach:

> function minimise(func, array) {
>   var minScore = null;
>   var found = null;
>   forEach(array, function(element) {
>     var score = func(element);
>     if (minScore == null || score < minScore) {
>       minScore = score;
>       found = element;
>     }
>   });
>   return found;
> }
>
> function getProperty(propName) {
>   return function(object) {
>     return object[propName];
>   };
> }
>
> function shortestRoute(from, to) {
>   return minimise(getProperty("length"), possibleRoutes(from, to));
> }

Unfortunately, it is three times longer than the other version. In
programs where you need to minimise several things it might be a good
idea to write the generic algorithm like this, so you can re-use it.
In most cases the first version is probably good enough.

Note the _|getProperty|_ function though, it is often useful when
doing functional programming with objects.

---

Let us see what route our algorithm comes up with between Point Kiukiu
and Point Teohotepapapa...

> show(shortestRoute("Point Kiukiu", "Point Teohotepapapa").places);

---

On a small island like Hiva Oa, it is not too much work to generate
all possible routes. If you try to do that on a reasonably detailed
map of, say, Belgium, it is going to take an absurdly long time, not
to mention an absurd amount of memory. Still, you have probably seen
those online route-planners. These give you a more or less optimal
route through a gigantic maze of roads in just a few seconds. How do
they do it?

If you are paying attention, you may have noticed that it is not
necessary to generate all routes all the way to the end. If we start
comparing routes *while* we are building them, we can avoid building
this big set of routes, and, as soon as we have found a single route
to our destination, we can stop extending routes that are already
longer than that route.

---

To try this out, we will use a 20 by 20 grid as our map:

[[height.png]]

What you see here is an elevation map of a mountain landscape. The
yellow spots are the peaks, and the blue spots the valleys. The area
is divided into squares with a size of a hundred meters. We have at
our disposal a function |heightAt|, which can give us the height, in
meters, of any square on that map, where squares are represented by
objects with |x| and |y| properties.

> print(heightAt({x: 0, y: 0}));
> print(heightAt({x: 11, y: 18}));

---

We want to cross this landscape, on foot, from the top left to the
bottom right. A grid can be approached like a graph. Every square is a
node, which is connected to the squares around it.

We do not like wasting energy, so we would prefer to take the easiest
route possible. Going uphill is heavier than going downhill, and going
downhill is heavier than going level##. This function calculates the
amount of 'weighted meters', between two adjacent squares, which
represents how tired you get from walking (or climbing) between them.
Going uphill is counted as twice as heavy as going downhill.

## No really, it is.

> function weightedDistance(pointA, pointB) {
>   var heightDifference = heightAt(pointB) - heightAt(pointA);
>   var climbFactor = (heightDifference < 0 ? 1 : 2);
>   var flatDistance = (pointA.x == pointB.x || pointA.y == pointB.y ? 100 : 141);
>   return flatDistance + climbFactor * Math.abs(heightDifference);
> }

Note the |flatDistance| calculation. If the two points are on the same
row or column, they are right next to each other, and the distance
between them is a hundred meters. Otherwise, they are assumed to
be diagonally adjacent, and the diagonal distance between two
squares of this size is a hundred times the square root of two, which
is approximately |141|. One is not allowed to call this function for
squares that are further than one step apart. (It could double-check
this... but it is too lazy.)

---

Points on the map are represented by objects containing |x| and |y|
properties. These three functions are useful when working with such
objects:

> function point(x, y) {
>   return {x: x, y: y};
> }
>
> function addPoints(a, b) {
>   return point(a.x + b.x, a.y + b.y);
> }
>
> function samePoint(a, b) {
>   return a.x == b.x && a.y == b.y;
> }
>
> show(samePoint(addPoints(point(10, 10), point(4, -2)),
>                point(14, 8)));

***

If we are going to find routes through this map, we will again need a
function to create 'signposts', lists of directions that can be taken
from a given point. Write a function |possibleDirections|, which takes
a point object as argument and returns an array of nearby points. We
can only move to adjacent points, both straight and diagonally, so
squares have a maximum of eight neighbours. Take care not to return
squares that lie outside of the map. For all we know the edge of the
map might be the edge of the world.

///

> function possibleDirections(from) {
>   var mapSize = 20;
>   function insideMap(point) {
>     return point.x >= 0 && point.x < mapSize &&
>            point.y >= 0 && point.y < mapSize;
>   }
>
>   var directions = [point(-1, 0), point(1, 0), point(0, -1),
>                     point(0, 1), point(-1, -1), point(-1, 1),
>                     point(1, 1), point(1, -1)];
>   return filter(insideMap, map(partial(addPoints, from),
>                                directions));
> }
>
> show(possibleDirections(point(0, 0)));

I created a variable |mapSize|, for the sole purpose of not having to
write |20| two times. If, at some other time, we want to use this same
function for another map, it would be clumsy if the code was full of
|20|s, which all have to be changed. We could even go as far as making
the |mapSize| an argument to |possibleDirections|, so we can use the
function for different maps without changing it. I judged that that
was not necessary in this case though, such things can always be
changed when the need arises.

Then why didn't I also add a variable to hold the |0|, which also
occurs two times? I assumed that maps always start at |0|, so this one
is unlikely to ever change, and using a variable for it only adds
noise.

---

To find a route on this map without having our browser cut off the
program because it takes too long to finish, we have to stop our
amateurish attempts and implement a serious algorithm. A lot of work
has gone into problems like this in the past, and many solutions have
been designed (some brilliant, others useless). A very popular and
efficient one is called _A*_ (pronounced A-star). We will spend the
rest of the chapter implementing an A* route-finding function for our
map.

Before I get to the algorithm itself, let me tell you a bit more about
the problem it solves. The trouble with searching routes through
graphs is that, in big graphs, there are an awful lot of them. Our
Hiva Oa path-finder showed that, when the graph is small, all we needed
to do was to make sure our paths didn't revisit points they had
already passed. On our new map, this is not enough anymore.

The fundamental problem is that there is too much room for going in
the wrong direction. Unless we somehow manage to steer our exploration
of paths towards the goal, a choice we make for continuing a given
path is more likely to go in the wrong direction than in the right
direction. If you keep generating paths like that, you end up with an
enormous amount of paths, and even if one of them accidentally reaches
the end point, you do not know whether that is the shortest path.

So what you want to do is explore directions that are likely to get
you to the end point first. On a grid like our map, you can get a
rough estimate of how good a path is by checking how long it is and
how close its end is to the end point. By adding path length and an
estimate of the distance it still has to go, you can get a rough idea
of which paths are promising. If you extend promising paths first, you
are less likely to waste time on useless ones.

---

But that still is not enough. If our map was of a perfectly flat
plane, the path that looked promising would almost always be the best
one, and we could use the above method to walk right to our goal. But
we have valleys and hillsides blocking our paths, so it is hard to
tell in advance which direction will be the most efficient path.
Because of this, we still end up having to explore way too many paths.

To correct this, we can make clever use of the fact that we are
constantly exploring the most promising path first. Once we have
determined that path A is the best way to get to point X, we can
remember that. When, later on, path B also gets to point X, we know
that it is not the best route, so we do not have to explore it
further. This can prevent our program from building a lot of pointless
paths.

---

The algorithm, then, goes something like this...

There are two pieces of data to keep track of. The first one is called
the open list, it contains the partial routes that must still be
explored. Each route has a score, which is calculated by adding its
length to its estimated distance from the goal. This estimate must
always be optimistic, it should never overestimate the distance. The
second is a set of nodes that we have seen, together with the shortest
partial route that got us there. This one we will call the reached
list. We start by adding a route that contains only the starting node
to the open list, and recording it in the reached list.

Then, as long as there are any nodes in the open list, we take out the
one that has the lowest (best) score, and find the ways in which it
can be continued (by calling |possibleDirections|). For each of the
nodes this returns, we create a new route by appending it to our
original route, and adjusting the length of the route using
|weightedDistance|. The endpoint of each of these new routes is then
looked up in the reached list.

If the node is not in the reached list yet, it means we have not seen
it before, and we add the new route to the open list and record it in
the reached list. If we *had* seen it before, we compare the score of
the new route to the score of the route in the reached list. If the
new route is shorter, we replace the existing route with the new one.
Otherwise, we discard the new route, since we have already seen a
better way to get to that point.

We continue doing this until the route we fetch from the open list
ends at the goal node, in which case we have found our route, or until
the open list is empty, in which case we have found out that there is
no route. In our case the map contains no unsurmountable obstacles, so
there is always a route.

How do we know that the first full route that we get from the open
list is also the shortest one? This is a result of the fact that we
only look at a route when it has the lowest score. The score of a
route is its actual length plus an *optimistic* estimate of the
remaining length. This means that if a route has the lowest score in
the open list, it is always the best route to its current endpoint --
it is impossible for another route to later find a better way to that
point, because if it were better, its score would have been lower.

---

Try not to get frustrated when the fine points of why this works are
still eluding you. When thinking about algorithms like this, having
seen 'something like it' before helps a lot, it gives you a point of
reference to compare the approach to. Beginning programmers have to do
without such a point of reference, which makes it rather easy to get
lost. Just realise that this is advanced stuff, globally read over the
rest of the chapter, and come back to it later when you feel like a
challenge.

---

I am afraid that, for one aspect of the algorithm, I'm going to have
to invoke magic again. The open list needs to be able to hold a large
amount of routes, and to quickly find the route with the lowest score
among them. Storing them in a normal array, and searching through this
array every time, is way too slow, so I give you a data structure
called a _binary heap_. You create them with |new|, just like |Date|
objects, giving them a function that is used to 'score' its elements
as argument. The resulting object has the methods |push| and |pop|,
just like an array, but |pop| always gives you the element with the
lowest score, instead of the one that was |push|ed last.

> function identity(x) {
>   return x;
> }
>
> var heap = new BinaryHeap(identity);
> forEach([2, 4, 5, 1, 6, 3], function(number) {
>   heap.push(number);
> });
> while (heap.size() > 0)
>   show(heap.pop());

\\Cbinaryheap discusses the implementation of this data structure,
which is quite interesting. After you have read \\coo, you might want
to take a look at it.

---

The need to squeeze out as much efficiency as we can has another
effect. The Hiva Oa algorithm used arrays of locations to store
routes, and copied them with the |concat| method when it extended
them. This time, we can not afford to copy arrays, since we will be
exploring lots and lots of routes. Instead, we use a 'chain' of
objects to store a route. Every object in the chain has some
properties, such as a point on the map, and the length of the route so
far, and it also has a property that points at the previous object in
the chain. Something like this:

[[objectchain.png]]

Where the cyan circles are the relevant objects, and the lines
represent properties -- the end with the dot points at the value of
the property. Object |A| is the start of a route here. Object |B| is
used to build a new route, which continues from |A|. It has a
property, which we will call |from|, pointing at the route it is based
on. When we need to reconstruct a route later, we can follow these
properties to find all the points that the route passed. Note that
object |B| is part of two routes, one that ends in |D| and one that
ends in |E|. When there are a lot of routes, this can save us much
storage space -- every new route only needs one new object for itself,
the rest is shared with other routes that started the same way.

***

Write a function |estimatedDistance| that gives an optimistic estimate
of the distance between two points. It does not have to look at the
height data, but can assume a flat map. Remember that we are only
travelling straight and diagonally, and that we are counting the
diagonal distance between two squares as |141|.

///

> function estimatedDistance(pointA, pointB) {
>   var dx = Math.abs(pointA.x - pointB.x),
>       dy = Math.abs(pointA.y - pointB.y);
>   if (dx > dy)
>     return (dx - dy) * 100 + dy * 141;
>   else
>     return (dy - dx) * 100 + dx * 141;
> }

The strange formulae are used to decompose the path into a straight
and a diagonal part. If you have a path like this...

[[diagonalpath.png]]

... the path is |8| squares wide and |4| high, so you get |8 - 4 = 4|
straight moves, and |4| diagonal ones.

If you wrote a function that just computes the straight 'Pythagorean'
distance between the points, that would also work. What we need is an
optimistic estimate, and assuming you can go straight to the goal is
certainly optimistic. However, the closer the estimate is to the real
distance, the less useless paths our program has to try out.

***

We will use a binary heap for the open list. What would be a good data
structure for the reached list? This one will be used to look up
routes, given a pair of |x|, |y| coordinates. Preferably in a way that
is fast. Write three functions, |makeReachedList|, |storeReached|, and
|findReached|. The first one creates your data structure, the second
one, given a reached list, a point, and a route, stores a route in it,
and the last one, given a reached list and point, retrieves a route or
returns |undefined| to indicate that no route was found for that
point.

///

One reasonable idea would be to use an object with objects in it. One
of the coordinates in the points, say |x|, is used as a property name
for the outer object, and the other, |y|, for the inner object. This
does require some bookkeeping to handle the fact that, sometimes, the
inner object we are looking for is not there (yet).

> function makeReachedList() {
>   return {};
> }
>
> function storeReached(list, point, route) {
>   var inner = list[point.x];
>   if (inner == undefined) {
>     inner = {};
>     list[point.x] = inner;
>   }
>   inner[point.y] = route;
> }
>
> function findReached(list, point) {
>   var inner = list[point.x];
>   if (inner == undefined)
>     return undefined;
>   else
>     return inner[point.y];
> }

Another possibility is to merge the |x| and |y| of the point into a
single property name, and use that to store routes in a single object.

> function pointID(point) {
>   return point.x + "-" + point.y;
> }
>
> function makeReachedList() {
>   return {};
> }
>
> function storeReached(list, point, route) {
>   list[pointID(point)] = route;
> }
>
> function findReached(list, point) {
>   return list[pointID(point)];
> }

---

@_encapsulation_Defining a type of data structure by providing a set
of functions to create and manipulate such structures is a useful
technique. It makes it possible to 'isolate' the code that makes use
of the structure from the details of the structure itself. Note that,
no matter which of the above two implementations is used, code that
needs a reached list works in exactly the same way. It doesn't care
what kind of objects are used, as long as it gets the results it
expected.

This will be discussed in much more detail in \\coo, where we will
learn to make object types like |BinaryHeap|, which are created using
|new| and have methods to manipulate them.

---

Here we finally have the actual path-finding function:

> function findRoute(from, to) {
>   var open = new BinaryHeap(routeScore);
>   var reached = makeReachedList();
> 
>   function routeScore(route) {
>     if (route.score == undefined)
>       route.score = estimatedDistance(route.point, to) +
>                     route.length;
>     return route.score;
>   }
>   function addOpenRoute(route) {
>     open.push(route);
>     storeReached(reached, route.point, route);
>   }
>   addOpenRoute({point: from, length: 0});
> 
>   while (open.size() > 0) {
>     var route = open.pop();
>     if (samePoint(route.point, to))
>       return route;
>     
>     forEach(possibleDirections(route.point), function(direction) {
>       var known = findReached(reached, direction);
>       var newLength = route.length +
>                       weightedDistance(route.point, direction);
>       if (!known || known.length > newLength){
>         if (known)
>           open.remove(known);        
>         addOpenRoute({point: direction,
>                       from: route,
>                       length: newLength});
>       }
>     });
>   }
>   return null;
> }

First, it creates the data structures it needs, one open list and one
reached list. |routeScore| is the scoring function given to the binary
heap. Note how it stores its result in the route object, to prevent
having to re-calculate it multiple times.

|addOpenRoute| is a convenience function that adds a new route to both
the open list and the reached list. It is immediately used to add the
start of the route. Note that route objects always have the properties
|point|, which holds the point at the end of the route, and |length|,
which holds the current length of the route. Routes which are more
than one square long also have a |from| property, which points at
their predecessors.

The |while| loop, as was described in the algorithm, keeps taking the
lowest-scoring route from the open list and checks whether this gets
us to the goal point. If it does not, we must continue by expanding
it. This is what the |forEach| takes care of. It looks up this new
point in the reached list. If it is not found there, or the node found
has a longer length that the new route, a new route object is created
and added to the open list and reached list, and the existing route
(if any) is removed from the open list.

What if the route in |known| is not on the open list? It has to be,
because routes are only removed from the open list when they have been
found to be the most optimal route to their endpoint. If we try to
remove a value from a binary heap that is not on it, it will throw an
exception, so if my reasoning is wrong, we will probably see an
exception when running the function.

When code gets complex enough to make you doubt certain things about
it, it is a good idea to add some checks that raise exceptions when
something goes wrong. That way, you know that there are no weird
things happening 'silently', and when you break something, you
immediately see what you broke.

---

Note that this algorithm does not use recursion, but still manages to
explore all those branches. The open list more or less takes over the
role that the function call stack played in the recursive solution to
the Hiva Oa problem -- it keeps track of the paths that still have to
be explored. Every recursive algorithm can be rewritten in a
non-recursive way by using a data structure to store the 'things that
must still be done'.

---

Well, let us try our path-finder:

> var route = findRoute(point(0, 0), point(19, 19));

If you ran all the code above, and did not introduce any errors, that
call, though it might take a few seconds to run, should give us a
route object. This object is rather hard to read. That can be helped
by using the |showRoute| function which, if your console is big
enough, will show a route on a map.

> showRoute(route);

You can also pass multiple routes to |showRoute|, which can be useful
when you are, for example, trying to plan a scenic route, which must
include the beautiful viewpoint at |11|, |17|.

> showRoute(findRoute(point(0, 0), point(11, 17)),
>           findRoute(point(11, 17), point(19, 19)));

---

Variations on the theme of _search_ing an optimal route through a
graph can be applied to many problems, many of which are not at all
related to finding a physical path. For example, a program that needs
to solve a puzzle of fitting a number of blocks into a limited space
could do this by exploring the various 'paths' it gets by trying to
put a certain block in a certain place. The paths that ends up with
insufficient room for the last blocks are dead ends, and the path that
manages to fit in all blocks is the solution.

================================
Object-oriented Programming / oo
================================

In the early nineties, a thing called _object-oriented programming_
stirred up the software industry. Most of the ideas behind it were not
really new at the time, but they had finally gained enough momentum to
start rolling, to become fashionable. Books were being written,
courses given, programming languages developed. All of a sudden,
everybody was extolling the virtues of object-orientation,
enthusiastically applying it to every problem, convincing themselves
they had finally found the *right way to write programs*.

These things happen a lot. When a process is hard and confusing,
people are always on the lookout for a magic solution. When something
looking like such a solution presents itself, they are prepared to
become devoted followers. For many programmers, even today,
object-orientation (or their view of it) is the gospel. When a program
is not 'truly object-oriented', whatever that means, it is considered
decidedly inferior.

Few fads have managed to stay popular for as long as this one, though.
Object-orientation's longevity can largely be explained by the fact
that the ideas at its core are very solid and useful. In this chapter,
we will discuss these ideas, along with JavaScript's (rather
eccentric) take on them. The above paragraphs are by no means meant to
discredit these ideas. What I want to do is warn the reader against
developing an unhealthy attachment to them.

---

As the name suggests, object-oriented programming is related to
objects. So far, we have used objects as loose aggregations of values,
adding and altering their properties whenever we saw fit. In an
object-oriented approach, objects are viewed as little worlds of their
own, and the outside world may touch them only through a limited and
well-defined _interface_, a number of specific methods and properties.
The 'reached list' we used at the end of \\csearch is an example of
this: We used only three functions, |makeReachedList|, |storeReached|,
and |findReached| to interact with it. These three functions form an
interface for such objects.

The |Date|, |Error|, and |BinaryHeap| objects we have seen also work
like this. Instead of providing regular functions for working with the
objects, they provide a way to create such objects, using the |new|
keyword, and a number of methods and properties that provide the rest
of the interface.

---

One way to give an object methods is to simply attach function values
to it.

> var rabbit = {};
> rabbit.speak = function(line) {
>   print("The rabbit says '", line, "'");
> };
>
> rabbit.speak("Well, now you're asking me.");

In most cases, the method will need to know *who* it should act on.
For example, if there are different rabbits, the |speak| method must
indicate which rabbit is speaking. For this purpose, there is a
special variable called _|this|_, which is always present when a
function is called, and which points at the relevant object when the
function is called as a method. A function is called as a method when
it is looked up as a property, and immediately called, as in
|object.method()|.

> function speak(line) {
>   print("The ", this.adjective, " rabbit says '", line, "'");
> }
> var whiteRabbit = {adjective: "white", speak: speak};
> var fatRabbit = {adjective: "fat", speak: speak};
>
> whiteRabbit.speak("Oh my ears and whiskers, how late it's getting!");
> fatRabbit.speak("I could sure use a carrot right now.");

---

I can now clarify the mysterious first argument to the _|apply|_
method, for which we always used |null| in \\cfp. This argument can be
used to specify the object that the function must be applied to. For
non-method functions, this is irrelevant, hence the |null|.

> speak.apply(fatRabbit, ["Yum."]);

Functions also have a _|call|_ method, which is similar to |apply|,
but you can give the arguments for the function separately instead of
as an array:

> speak.call(fatRabbit, "Burp.");

---

The _|new|_ keyword provides a convenient way of creating new objects.
When a function is called with the word |new| in front of it, its
_|this|_ variable will point at a *new* object, which it will
automatically return (unless it explicitly returns something else).
Functions used to create new objects like this are called
_constructor_s. Here is a constructor for rabbits:

> function Rabbit(adjective) {
>   this.adjective = adjective;
>   this.speak = function(line) {
>     print("The ", this.adjective, " rabbit says '", line, "'");
>   };
> }
>
> var killerRabbit = new Rabbit("killer");
> killerRabbit.speak("GRAAAAAAAAAH!");

It is a convention, among JavaScript programmers, to start the names
of constructors with a capital letter. This makes it easy to
distinguish them from other functions.

Why is the |new| keyword even necessary? After all, we could have
simply written this:

> function makeRabbit(adjective) {
>   return {
>     adjective: adjective,
>     speak: function(line) {/*etc*/}
>   };
> }
>
> var blackRabbit = makeRabbit("black");

But that is not entirely the same. |new| does a few things behind the
scenes. For one thing, our |killerRabbit| has a property called
_|constructor|_, which points at the |Rabbit| function that created
it. |blackRabbit| also has such a property, but it points at the
_|Object|_ function.

> show(killerRabbit.constructor);
> show(blackRabbit.constructor);

---

Where did the |constructor| property come from? It is part of the
_prototype_ of a rabbit. Prototypes are a powerful, if somewhat
confusing, part of the way JavaScript objects work. Every object is
based on a prototype, which gives it a set of inherent properties. The
simple objects we have used so far are based on the most basic
prototype, which is associated with the |Object| constructor. In fact,
typing |{}| is equivalent to typing |new Object()|.

> var simpleObject = {};
> show(simpleObject.constructor);
> show(simpleObject.toString);

_|toString|_ is a method that is part of the |Object| prototype. This
means that all simple objects have a |toString| method, which converts
them to a string. Our rabbit objects are based on the prototype
associated with the |Rabbit| constructor. You can use a constructor's
|prototype| property to get access to, well, their prototype:

> show(Rabbit.prototype);
> show(Rabbit.prototype.constructor);

Every function automatically gets a |prototype| property, whose
|constructor| property points back at the function. Because the rabbit
prototype is itself an object, it is based on the |Object| prototype,
and shares its |toString| method.

> show(killerRabbit.toString == simpleObject.toString);

---

Even though objects seem to share the properties of their prototype,
this sharing is one-way. The properties of the prototype influence the
object based on it, but the properties of this object never change the
prototype.

The precise rules are this: When looking up the value of a property,
JavaScript first looks at the properties that the object *itself* has.
If there is a property that has the name we are looking for, that is
the value we get. If there is no such property, it continues searching
the prototype of the object, and then the prototype of the prototype,
and so on. If no property is found, the value |undefined| is given. On
the other hand, when *setting* the value of a property, JavaScript
never goes to the prototype, but always sets the property in the
object itself.

> Rabbit.prototype.teeth = "small";
> show(killerRabbit.teeth);
> killerRabbit.teeth = "long, sharp, and bloody";
> show(killerRabbit.teeth);
> show(Rabbit.prototype.teeth);

This does mean that the prototype can be be used at any time to add
new properties and methods to all objects based on it. For example, it
might become necessary for our rabbits to dance.

> Rabbit.prototype.dance = function() {
>   print("The ", this.adjective, " rabbit dances a jig.");
> };
>
> killerRabbit.dance();

And, as you might have guessed, the prototypical rabbit is the perfect
place for values that all rabbits have in common, such as the |speak|
method. Here is a new approach to the |Rabbit| constructor:

> function Rabbit(adjective) {
>   this.adjective = adjective;
> }
> Rabbit.prototype.speak = function(line) {
>   print("The ", this.adjective, " rabbit says '", line, "'");
> };
>
> var hazelRabbit = new Rabbit("hazel");
> hazelRabbit.speak("Good Frith!");

---

The fact that all objects have a prototype and receive some properties
from this prototype can be tricky. It means that using an object to
store a set of things, such as the cats from \\cdata, can go wrong.
If, for example, we wondered whether there is a cat called
|"constructor"|, we would have checked it like this:

> var noCatsAtAll = {};
> if ("constructor" in noCatsAtAll)
>   print("Yes, there definitely is a cat called 'constructor'.");

This is problematic. A related problem is that it can often be
practical to extend the prototypes of standard constructors such as
|Object| and |Array| with new useful functions. For example, we could
give all objects a method called |properties|, which returns an array
with the names of the (non-hidden) properties that the object has:

> Object.prototype.properties = function() {
>   var result = [];
>   for (var property in this)
>     result.push(property);
>   return result;
> };
>
> var test = {x: 10, y: 3};
> show(test.properties());

And that immediately shows the problem. Now that the |Object|
prototype has a property called |properties|, looping over the
properties of any object, using |for| and _|in|_, will also give us
that shared property, which is generally not what we want. We are
interested only in the properties that the object itself has.

Fortunately, there is a way to find out whether a property belongs to
the object itself or to one of its prototypes. Unfortunately, it does
make looping over the properties of an object a bit clumsier. Every
object has a method called _|hasOwnProperty|_, which tells us whether
the object has a property with a given name. Using this, we could
rewrite our |properties| method like this:

> Object.prototype.properties = function() {
>   var result = [];
>   for (var property in this) {
>     if (this.hasOwnProperty(property))
>       result.push(property);
>   }
>   return result;
> };
>
> var test = {"Fat Igor": true, "Fireball": true};
> show(test.properties());

@_|forEachIn|_And of course, we can abstract that into a higher-order
function. Note that the |action| function is called with both the name
of the property and the value it has in the object.

> function forEachIn(object, action) {
>   for (var property in object) {
>     if (object.hasOwnProperty(property))
>       action(property, object[property]);
>   }
> }
>
> var chimera = {head: "lion", body: "goat", tail: "snake"};
> forEachIn(chimera, function(name, value) {
>   print("The ", name, " of a ", value, ".");
> });

But, what if we find a cat named |hasOwnProperty|? (You never know.)
It will be stored in the object, and the next time we want to go over
the collection of cats, calling |object.hasOwnProperty| will fail,
because that property no longer points at a function value. This can
be solved by doing something even uglier:

> function forEachIn(object, action) {
>   for (var property in object) {
>     if (Object.prototype.hasOwnProperty.call(object, property))
>       action(property, object[property]);
>   }
> }
>
> var test = {name: "Mordecai", hasOwnProperty: "Uh-oh"};
> forEachIn(test, function(name, value) {
>   print("Property ", name, " = ", value);
> });

(Note: This example does not currently work correctly in Internet
Explorer 8, which apparently has some problems with overriding
built-in prototype properties.)

Here, instead of using the method found in the object itself, we get
the method from the |Object| prototype, and then use |call| to apply
it to the right object. Unless someone actually messes with the method
in |Object.prototype| (don't do that), this should work correctly.

---

|hasOwnProperty| can also be used in those situations where we have
been using the _|in|_ operator to see whether an object has a specific
property. There is one more catch, however. We saw in \\cdata that
some properties, such as |toString|, are 'hidden', and do not show up
when going over properties with |for|/|in|. It turns out that browsers
in the Gecko family (Firefox, most importantly) give every object a
hidden property named |__proto__|, which points to the prototype of
that object. |hasOwnProperty| will return |true| for this one, even
though the program did not explicitly add it. Having access to the
prototype of an object can be very convenient, but making it a
property like that was not a very good idea. Still, Firefox is a
widely used browser, so when you write a program for the web you have
to be careful with this. There is a method _|propertyIsEnumerable|_,
which returns |false| for hidden properties, and which can be used to
filter out strange things like |__proto__|. An expression such as this
one can be used to reliably work around this:

> var object = {foo: "bar"};
> show(Object.prototype.hasOwnProperty.call(object, "foo") &&
>      Object.prototype.propertyIsEnumerable.call(object, "foo"));

Nice and simple, no? This is one of the not-so-well-designed aspects
of JavaScript. Objects play both the role of 'values with methods',
for which prototypes work great, and 'sets of properties', for which
prototypes only get in the way.

---

Writing the above expression every time you need to check whether a
property is present in an object is unworkable. We could put it into a
function, but an even better approach is to write a constructor and a
prototype specifically for situations like this, where we want to
approach an object as just a set of properties. Because you can use it
to look things up by name, we will call it a _|Dictionary|_.

> function Dictionary(startValues) {
>   this.values = startValues || {};
> }
> Dictionary.prototype.store = function(name, value) {
>   this.values[name] = value;
> };
> Dictionary.prototype.lookup = function(name) {
>   return this.values[name];
> };
> Dictionary.prototype.contains = function(name) {
>   return Object.prototype.hasOwnProperty.call(this.values, name) &&
>     Object.prototype.propertyIsEnumerable.call(this.values, name);
> };
> Dictionary.prototype.each = function(action) {
>   forEachIn(this.values, action);
> };
>
> var colours = new Dictionary({Grover: "blue",
>                               Elmo: "orange",
>                               Bert: "yellow"});
> show(colours.contains("Grover"));
> show(colours.contains("constructor"));
> colours.each(function(name, colour) {
>   print(name, " is ", colour);
> });

Now the whole mess related to approaching objects as plain sets of
properties has been 'encapsulated' in a convenient interface: one
constructor and four methods. Note that the |values| property of a
|Dictionary| object is not part of this interface, it is an internal
detail, and when you are using |Dictionary| objects you do not need to
directly use it.

Whenever you write an interface, it is a good idea to add a comment
with a quick sketch of what it does and how it should be used. This
way, when someone, possibly yourself three months after you wrote it,
wants to work with the interface, they can quickly see how to use it,
and do not have to study the whole program.

Most of the time, when you are designing an interface, you will soon
find some limitations and problems in whatever you came up with, and
change it. To prevent wasting your time, it is advisable to document
your interfaces only *after* they have been used in a few real
situations and proven themselves to be practical. -- Of course, this
might make it tempting to forget about documentation altogether.
Personally, I treat writing documentation as a 'finishing touch' to
add to a system. When it feels ready, it is time to write something
about it, and to see if it sounds as good in English (or whatever
language) as it does in JavaScript (or whatever programming language).

---

The distinction between the external interface of an object and its
internal details is important for two reasons. Firstly, having a
small, clearly described interface makes an object easier to use. You
only have to keep the interface in mind, and do not have to worry
about the rest unless you are changing the object itself.

Secondly, it often turns out to be necessary or practical to change
something about the internal implementation of an object type##, to
make it more efficient, for example, or to fix some problem. When
outside code is accessing every single property and detail in the
object, you can not change any of them without also updating a lot of
other code. If outside code only uses a small interface, you can do
what you want, as long as you do not change the interface.

## Such types are usually called 'classes' in other programming
languages.

Some people go very far in this. They will, for example, never include
properties in the interface of object, only methods -- if their object
type has a length, it will be accessible with the |getLength| method,
not the |length| property. This way, if they ever want to change their
object in such a way that it no longer has a |length| property, for
example because it now has some internal array whose length it must
return, they can update the function without changing the interface.

My own take is that in most cases this is not worth it. Adding a
|getLength| method which only contains |return this.length;| mostly
just adds meaningless code, and, in most situations, I consider
meaningless code a bigger problem than the risk of having to
occasionally change the interface to my objects.

---

Adding new methods to existing prototypes can be very convenient.
Especially the |Array| and |String| prototypes in JavaScript could use
a few more basic methods. We could, for example, replace |forEach| and
|map| with methods on arrays, and make the |startsWith| function we
wrote in \\cdata a method on strings.

However, if your program has to run on the same web-page as another
program (either written by you or by someone else) which uses
|for|/|in| naively -- the way we have been using it so far -- then
adding things to prototypes, especially the |Object| and |Array|
prototype, will definitely break something, because these loops will
suddenly start seeing those new properties. For this reason, some
people prefer not to touch these prototypes at all. Of course, if you
are careful, and you do not expect your code to have to coexist with
badly-written code, adding methods to standard prototypes is a
perfectly good technique.

---

In this chapter we are going to build a virtual terrarium, a tank with
insects moving around in it. There will be some objects involved (this
is, after all, the chapter on object-oriented programming). We will
take a rather simple approach, and make the terrarium a
two-dimensional grid, like the second map in \\csearch. On this grid
there are a number of bugs. When the terrarium is active, all the bugs
get a chance to take an action, such as moving, every half second.

Thus, we chop both time and space into units with a fixed size --
squares for space, half seconds for time. This usually makes things
easier to model in a program, but of course has the drawback of being
wildly inaccurate. Fortunately, this terrarium-simulator is not
required to be accurate in any way, so we can get away with it.

---

A terrarium can be defined with a 'plan', which is an array of
strings. We could have used a single string, but because JavaScript
strings must stay on a single line it would have been a lot harder to
type.

> var thePlan =
>   ["############################",
>    "#      #    #      o      ##",
>    "#                          #",
>    "#          #####           #",
>    "##         #   #    ##     #",
>    "###           ##     #     #",
>    "#           ###      #     #",
>    "#   ####                   #",
>    "#   ##       o             #",
>    "# o  #         o       ### #",
>    "#    #                     #",
>    "############################"];

The |"#"| characters are used to represent the walls of the terrarium
(and the ornamental rocks lying in it), the |"o"|s represent bugs, and
the spaces are, as you might have guessed, empty space.

Such a plan-array can be used to create a terrarium-object. This
object keeps track of the shape and content of the terrarium, and lets
the bugs inside move. It has four methods: Firstly |toString|, which
converts the terrarium back to a string similar to the plan it was
based on, so that you can see what is going on inside it. Then there
is |step|, which allows all the bugs in the terrarium to move one
step, if they so desire. And finally, there are |start| and |stop|,
which control whether the terrarium is 'running'. When it is running,
|step| is automatically called every half second, so the bugs keep
moving.

***

@_|Point|_The points on the grid will be represented by objects again.
In \\csearch we used three functions, |point|, |addPoints|, and
|samePoint| to work with points. This time, we will use a constructor
and two methods. Write the constructor |Point|, which takes two
arguments, the x and y coordinates of the point, and produces an
object with |x| and |y| properties. Give the prototype of this
constructor a method |add|, which takes another point as argument and
returns a *new* point whose |x| and |y| are the sum of the |x| and |y|
of the two given points. Also add a method |isEqualTo|, which takes a
point and returns a boolean indicating whether the |this| point refers
to the same coordinates as the given point.

Apart from the two methods, the |x| and |y| properties are also part
of the interface of this type of objects: Code which uses point
objects may freely retrieve and modify |x| and |y|.

///

> function Point(x, y) {
>   this.x = x;
>   this.y = y;
> }
> Point.prototype.add = function(other) {
>   return new Point(this.x + other.x, this.y + other.y);
> };
> Point.prototype.isEqualTo = function(other) {
>   return this.x == other.x && this.y == other.y;
> };
>
> show((new Point(3, 1)).add(new Point(2, 4)));

Make sure your version of |add| leaves the |this| point intact and
produces a new point object. A method which changes the current point
instead would be similar to the |+=| operator, whereas this one is
like the |+| operator.

---

When writing objects to implement a certain program, it is not always
very clear which functionality goes where. Some things are best
written as methods of your objects, other things are better expressed
as separate functions, and some things are best implemented by adding
a new type of object. To keep things clear and organised, it is
important to keep the amount of methods and responsibilities that an
object type has as small as possible. When an object does too much, it
becomes a big mess of functionality, and a formidable source of
confusion.

I said above that the terrarium object will be responsible for storing
its contents and for letting the bugs inside it move. Firstly, note
that it *lets* them move, it doesn't *make* them move. The bugs
themselves will also be objects, and these objects are responsible for
deciding what they want to do. The terrarium merely provides the
infrastructure that asks them what to do every half second, and if
they decide to move, it makes sure this happens.

Storing the grid on which the content of the terrarium is kept can get
quite complex. It has to define some kind of representation, ways to
access this representation, a way to initialise the grid from a 'plan'
array, a way to write the content of the grid to a string for the
|toString| method, and the movement of the bugs on the grid. It would
be nice if part of this could be moved into another object, so that
the terrarium object itself doesn't get too big and complex.

---

Whenever you find yourself about to mix data representation and
problem-specific code in one object, it is a good idea to try and put
the data representation code into a separate type of object. In this
case, we need to represent a grid of values, so I wrote a |Grid| type,
which supports the operations that the terrarium will need.

To store the values on the grid, there are two options. One can use an
array of arrays, like this:

> var grid = [["0,0", "1,0", "2,0"],
>             ["0,1", "1,1", "2,1"]];
> show(grid[1][2]);

Or the values can all be put into a single array. In this case, the
element at |x|,|y| can be found by getting the element at position |x
+ y * width| in the array, where |width| is the width of the grid.

> var grid = ["0,0", "1,0", "2,0",
>             "0,1", "1,1", "2,1"];
> show(grid[2 + 1 * 3]);

@_|Array|_I chose the second representation, because it makes it much
easier to initialise the array. |new Array(x)| produces a new array of
length |x|, filled with |undefined| values.

> function Grid(width, height) {
>   this.width = width;
>   this.height = height;
>   this.cells = new Array(width * height);
> }
> Grid.prototype.valueAt = function(point) {
>   return this.cells[point.y * this.width + point.x];
> };
> Grid.prototype.setValueAt = function(point, value) {
>   this.cells[point.y * this.width + point.x] = value;
> };
> Grid.prototype.isInside = function(point) {
>   return point.x >= 0 && point.y >= 0 &&
>          point.x < this.width && point.y < this.height;
> };
> Grid.prototype.moveValue = function(from, to) {
>   this.setValueAt(to, this.valueAt(from));
>   this.setValueAt(from, undefined);
> };

***

We will also need to go over all the elements of the grid, to find the
bugs we need to move, or to convert the whole thing to a string. To
make this easy, we can use a higher-order function that takes an
action as its argument. Add the method |each| to the prototype of
|Grid|, which takes a function of two arguments as its argument. It
calls this function for every point on the grid, giving it the point
object for that point as its first argument, and the value that is on
the grid at that point as second argument.

Go over the points starting at |0|,|0|, one row at a time, so that
|1|,|0| is handled before |0|,|1|. This will make it easier to write
the |toString| function of the terrarium later. (Hint: Put a |for|
loop for the |x| coordinate inside a loop for the |y| coordinate.)

It is advisable not to muck about in the |cells| property of the grid
object directly, but use |valueAt| to get at the values. This way, if
we decide (for some reason) to use a different method for storing the
values, we only have to rewrite |valueAt| and |setValueAt|, and the
other methods can stay untouched.

///

> Grid.prototype.each = function(action) {
>   for (var y = 0; y < this.height; y++) {
>     for (var x = 0; x < this.width; x++) {
>       var point = new Point(x, y);
>       action(point, this.valueAt(point));
>     }
>   }
> };

---

Finally, to test the grid:

> var testGrid = new Grid(3, 2);
> testGrid.setValueAt(new Point(1, 0), "#");
> testGrid.setValueAt(new Point(1, 1), "o");
> testGrid.each(function(point, value) {
>   print(point.x, ",", point.y, ": ", value);
> });

---

Before we can start to write a |Terrarium| constructor, we will have
to get a bit more specific about these 'bug objects' that will be
living inside it. Earlier, I mentioned that the terrarium will ask the
bugs what action they want to take. This will work as follows: Each
bug object has an |act| method which, when called, returns an
'action'. An action is an object with a |type| property, which names
the type of action the bug wants to take, for example |"move"|. For
most actions, the action also contains extra information, such as the
direction the bug wants to go.

Bugs are terribly myopic, they can only see the squares directly
around them on the grid. But these they can use to base their action
on. When the |act| method is called, it is given an object with
information about the surroundings of the bug in question. For each of
the eight directions, it contains a property. The property indicating
what is above the bug is called |"n"|, for North, the one
indicating what is above and to the left |"ne"|, for North-East, and
so on. To look up the direction these names refer to, the following
dictionary object is useful:

> var directions = new Dictionary(
>   {"n":  new Point( 0, -1),
>    "ne": new Point( 1, -1),
>    "e":  new Point( 1,  0),
>    "se": new Point( 1,  1),
>    "s":  new Point( 0,  1),
>    "sw": new Point(-1,  1),
>    "w":  new Point(-1,  0),
>    "nw": new Point(-1, -1)});
>
> show(new Point(4, 4).add(directions.lookup("se")));

When a bug decides to move, he indicates in which direction he wants
to go by giving the resulting action object a |direction| property
that names one of these directions. We can make a simple, stupid bug
that always just goes south, 'towards the light', like this:

> function StupidBug() {};
> StupidBug.prototype.act = function(surroundings) {
>   return {type: "move", direction: "s"};
> };

---

Now we can start on the |Terrarium| object type itself. First, its
constructor, which takes a plan (an array of strings) as argument, and
initialises its grid.

> var wall = {};
>
> function Terrarium(plan) {
>   var grid = new Grid(plan[0].length, plan.length);
>   for (var y = 0; y < plan.length; y++) {
>     var line = plan[y];
>     for (var x = 0; x < line.length; x++) {
>       grid.setValueAt(new Point(x, y),
>                       elementFromCharacter(line.charAt(x)));
>     }
>   }
>   this.grid = grid;
> }
>
> function elementFromCharacter(character) {
>   if (character == " ")
>     return undefined;
>   else if (character == "#")
>     return wall;
>   else if (character == "o")
>     return new StupidBug();
> }

|wall| is an object that is used to mark the location of walls on the
grid. Like a real wall, it doesn't do much, it just sits there and
takes up space.

---

The most straightforward method of a terrarium object is |toString|,
which transforms a terrarium into a string. To make this easier, we
mark both the |wall| and the prototype of the |StupidBug| with a
property |character|, which holds the character that represents them.

> wall.character = "#";
> StupidBug.prototype.character = "o";
>
> function characterFromElement(element) {
>   if (element == undefined)
>     return " ";
>   else
>     return element.character;
> }
>
> show(characterFromElement(wall));

***

Now we can use the |each| method of the |Grid| object to build up a
string. But to make the result readable, it would be nice to have a
newline at the end of every row. The |x| coordinate of the positions
on the grid can be used to determine when the end of a line is
reached. Add a method |toString|, which takes no arguments and returns
a string which, when given to |print|, shows a nice two-dimensional
view of the terrarium.

///

> Terrarium.prototype.toString = function() {
>   var characters = [];
>   var endOfLine = this.grid.width - 1;
>   this.grid.each(function(point, value) {
>     characters.push(characterFromElement(value));
>     if (point.x == endOfLine)
>       characters.push("\n");
>   });
>   return characters.join("");
> };

And to try it out...

> var terrarium = new Terrarium(thePlan);
> print(terrarium.toString());

---

It is possible that, when trying to solve the above exercise, you have
tried to access |this.grid| inside the function that you pass as an
argument to the grid's |each| method. This will not work. Calling a
function always results in a new |this| being defined inside that
function, even when it is not used as a method. Thus, any |this|
variable outside of the function will not be visible.

Sometimes it is straightforward to work around this by storing the
information you need in a variable, like |endOfLine|, which *is*
visible in the inner function. If you need access to the whole |this|
object, you can store that in a variable too. The name |self| (or
|that|) is often used for such a variable.

But all these extra variables can get messy. Another good solution is
to use a function similar to |partial| from \\cfp. Instead of adding
arguments to a function, this one adds a |this| object, using the
first argument to the function's |apply| method:

> function bind(func, object) {
>   return function(){
>     return func.apply(object, arguments);
>   };
> }
>
> var testArray = [];
> var pushTest = bind(testArray.push, testArray);
> pushTest("A");
> pushTest("B");
> show(testArray);

This way, you can |bind| an inner function to |this|, and it will have
the same |this| as the outer function.

***

In the expression |bind(testArray.push, testArray)| the name
|testArray| still occurs twice. Can you design a function _|method|_,
which allows you to bind an object to one of its methods *without*
naming the object twice?

///

It is possible to give the name of the method as a string. This way, the
|method| function can look up the correct function value for itself.

> function method(object, name) {
>   return function() {
>     object[name].apply(object, arguments);
>   };
> }
>
> var pushTest = method(testArray, "push");

---

We will need |bind| (or |method|) when implementing the |step| method
of a terrarium. This method has to go over all the bugs on the grid,
ask them for an action, and execute the given action. You might be
tempted to use |each| on the grid, and just handle the bugs we come
across. But then, when a bug moves South or East, we will come across
it again in the same turn, and allow it to move again.

Instead, we first gather all the bugs into an array, and then process
them. This method gathers bugs, or other things that have an |act|
method, and stores them in objects that also contain their current
position:

> Terrarium.prototype.listActingCreatures = function() {
>   var found = [];
>   this.grid.each(function(point, value) {
>     if (value != undefined && value.act)
>       found.push({object: value, point: point});
>   });
>   return found;
> };

***

When asking a bug to act, we must pass it an object with information
about its current surroundings. This object will use the direction
names we saw earlier (|"n"|, |"ne"|, etcetera) as property names. Each
property holds a string of one character, as returned by
|characterFromElement|, indicating what the bug can see in that
direction.

Add a method |listSurroundings| to the |Terrarium| prototype. It takes
one argument, the point at which the bug is currently standing, and
returns an object with information about the surroundings of that
point. When the point is at the edge of the grid, use |"#"| for the
directions that go outside of the grid, so the bug will not try to
move there.

Hint: Do not write out all the directions, use the |each| method on
the |directions| dictionary.

///

> Terrarium.prototype.listSurroundings = function(center) {
>   var result = {};
>   var grid = this.grid;
>   directions.each(function(name, direction) {
>     var place = center.add(direction);
>     if (grid.isInside(place))
>       result[name] = characterFromElement(grid.valueAt(place));
>     else
>       result[name] = "#";
>   });
>   return result;
> };

Note the use of the |grid| variable to work around the |this| problem.

---

Both above methods are not part of the external interface of a
|Terrarium| object, they are internal details. Some languages provide
ways to explicitly declare certain methods and properties 'private',
and make it an error to use them from outside the object. JavaScript
does not, so you will have to rely on comments to describe the
interface to an object. Sometimes it can be useful to use some kind of
naming scheme to distinguish between external and internal properties,
for example by prefixing all internal ones with an underscore ('|_|').
This will make accidental uses of properties that are not part of an
object's interface easier to spot.

---

Next is one more internal method, the one that will ask a bug for an
action and carry it out. It takes an object with |object| and |point|
properties, as returned by |listActingCreatures|, as argument. For now,
it only knows about the |"move"| action:

> Terrarium.prototype.processCreature = function(creature) {
>   var surroundings = this.listSurroundings(creature.point);
>   var action = creature.object.act(surroundings);
>   if (action.type == "move" && directions.contains(action.direction)) {
>     var to = creature.point.add(directions.lookup(action.direction));
>     if (this.grid.isInside(to) && this.grid.valueAt(to) == undefined)
>       this.grid.moveValue(creature.point, to);
>   }
>   else {
>     throw new Error("Unsupported action: " + action.type);
>   }
> };

Note that it checks whether the chosen direction is inside of the grid
and empty, and ignores it otherwise. This way, the bugs can ask for
any action they like -- the action will only be carried out if it is
actually possible. This acts as a layer of insulation between the bugs
and the terrarium, and allows us to be less precise when writing the
bugs' |act| methods -- for example the |StupidBug| just always travels
South, regardless of any walls that might stand in its way.

---

These three internal methods then finally allow us to write the |step|
method, which gives all bugs a chance to do something (all elements
with an |act| method -- we could also give the |wall| object one if we
so desired, and make the walls walk).

> Terrarium.prototype.step = function() {
>   forEach(this.listActingCreatures(),
>           bind(this.processCreature, this));
> };

Now, let us make a terrarium and see whether the bugs move...

> var terrarium = new Terrarium(thePlan);
> print(terrarium);
> terrarium.step();
> print(terrarium);

---

Wait, how come the above calls |print(terrarium)| and ends up
displaying the output of our _|toString|_ method? |print| turns its
arguments to strings using the |String| function. Objects are turned
to strings by calling their |toString| method, so giving your own
object types a meaningful |toString| is a good way to make them
readable when printed out.

> Point.prototype.toString = function() {
>   return "(" + this.x + "," + this.y + ")";
> };
> print(new Point(5, 5));

---

As promised, |Terrarium| objects also get |start| and |stop| methods
to start or stop their simulation. For this, we will use two functions
provided by the browser, called _|setInterval|_ and _|clearInterval|_.
The first is used to cause its first argument (a function, or a string
containing JavaScript code) to be executed periodically. Its second
argument gives the amount of milliseconds (1/1000 second) between
invocations. It returns a value that can be given to |clearInterval|
to stop its effect.

> var annoy = setInterval(function() {print("What?");}, 400);

And...

> clearInterval(annoy);

There are similar functions for one-shot time-based actions.
_|setTimeout|_ causes a function or string to be executed after a
given amount of milliseconds, and _|clearTimeout|_ cancels such an
action.

---

> Terrarium.prototype.start = function() {
>   if (!this.running)
>     this.running = setInterval(bind(this.step, this), 500);
> };
>
> Terrarium.prototype.stop = function() {
>   if (this.running) {
>     clearInterval(this.running);
>     this.running = null;
>   }
> };

---

Now we have a terrarium with some simple-minded bugs, and we can run
it. But to see what is going on, we have to repeatedly do
|print(terrarium)|, or we won't see what is going on. That is not very
practical. It would be nicer if it would print automatically. It would
also look better if, instead of printing a thousand terraria below
each other, we could update a single printout of the terrarium. For
that second problem, this page conveniently provides a function called
|inPlacePrinter|. It returns a function like |print| which, instead of
adding to the output, replaces its previous output.

> var printHere = inPlacePrinter();
> printHere("Now you see it.");
> setTimeout(partial(printHere, "Now you don't."), 1000);

To cause the terrarium to be re-printed every time it changes, we can
modify the |step| method as follows:

> Terrarium.prototype.step = function() {
>   forEach(this.listActingCreatures(),
>           bind(this.processCreature, this));
>   if (this.onStep)
>     this.onStep();
> };

Now, when an |onStep| property has been added to a terrarium, it will
be called on every step.

> var terrarium = new Terrarium(thePlan);
> terrarium.onStep = partial(inPlacePrinter(), terrarium);
> terrarium.start();

Note the use of |partial| -- it produces an in-place printer applied
to the terrarium. Such a printer only takes one argument, so after
partially applying it there are no arguments left, and it becomes a
function of zero arguments. That is exactly what we need for the
|onStep| property.

Don't forget to stop the terrarium when it is no longer interesting
(which should be pretty soon), so that it does not keep wasting your
computer's resources:

> terrarium.stop();

---

But who wants a terrarium with just one kind of bug, and a stupid bug
at that? Not me. It would be nice if we could add different kinds of
bugs. Fortunately, all we have to is to make the
|elementFromCharacter| function more general. Right now it contains
three cases which are typed in directly, or 'hard-coded':

> function elementFromCharacter(character) {
>   if (character == " ")
>     return undefined;
>   else if (character == "#")
>     return wall;
>   else if (character == "o")
>     return new StupidBug();
> }

The first two cases we can leave intact, but the last one is way too
specific. A better approach would be to store the characters and the
corresponding bug-constructors in a dictionary, and look for them
there:

> var creatureTypes = new Dictionary();
> creatureTypes.register = function(constructor) {
>   this.store(constructor.prototype.character, constructor);
> };
>
> function elementFromCharacter(character) {
>   if (character == " ")
>     return undefined;
>   else if (character == "#")
>     return wall;
>   else if (creatureTypes.contains(character))
>     return new (creatureTypes.lookup(character))();
>   else
>     throw new Error("Unknown character: " + character);
> }

Note how the |register| method is added to |creatureTypes| -- this is
a dictionary object, but there is no reason why it shouldn't support
an additional method. This method looks up the character associated
with a constructor, and stores it in the dictionary. It should only be
called on constructors whose prototype does actually have a
|character| property.

|elementFromCharacter| now looks up the character it is given in
|creatureTypes|, and raises an exception when it comes across an
unknown character.

---

Here is a new bug type, and the call to register its character in
|creatureTypes|:

> function BouncingBug() {
>   this.direction = "ne";
> }
> BouncingBug.prototype.act = function(surroundings) {
>   if (surroundings[this.direction] != " ")
>     this.direction = (this.direction == "ne" ? "sw" : "ne");
>   return {type: "move", direction: this.direction};
> };
> BouncingBug.prototype.character = "%";
>
> creatureTypes.register(BouncingBug);

Can you figure out what it does?

*** drunkbug

Create a bug type called |DrunkBug| which tries to move in a random
direction every turn, never mind whether there is a wall there.
Remember the |Math.random| trick from \\csearch.

///

To pick a random direction, we will need an array of direction names.
We could of course just type |["n", "ne", ...]|, but that duplicates
information, and duplicated information makes me nervous. We could
also use the |each| method in |directions| to build the array, which
is better already.

But there is clearly a generality to be discovered here. Getting a
list of the property names in a dictionary sounds like a useful tool
to have, so we add it to the |Dictionary| prototype.

> Dictionary.prototype.names = function() {
>   var names = [];
>   this.each(function(name, value) {names.push(name);});
>   return names;
> };
>
> show(directions.names());

A real neurotic programmer would immediately restore symmetry by also
adding a |values| method, which returns a list of the values stored in
the dictionary. But I guess that can wait until we [need it |
http://www.c2.com/cgi/wiki?YouArentGonnaNeedIt].

Here is a way to take a random element from an array:

> function randomElement(array) {
>   if (array.length == 0)
>     throw new Error("The array is empty.");
>   return array[Math.floor(Math.random() * array.length)];
> }
>
> show(randomElement(["heads", "tails"]));

And the bug itself:

> function DrunkBug() {};
> DrunkBug.prototype.act = function(surroundings) {
>   return {type: "move",
>           direction: randomElement(directions.names())};
> };
> DrunkBug.prototype.character = "~";
>
> creatureTypes.register(DrunkBug);

---

So, let us test out our new bugs:

> var newPlan =
>   ["############################",
>    "#                      #####",
>    "#    ##                 ####",
>    "#   ####     ~ ~          ##",
>    "#    ##       ~            #",
>    "#                          #",
>    "#                ###       #",
>    "#               #####      #",
>    "#                ###       #",
>    "# %        ###        %    #",
>    "#        #######           #",
>    "############################"];
>
> var terrarium = new Terrarium(newPlan);
> terrarium.onStep = partial(inPlacePrinter(), terrarium);
> terrarium.start();

Notice the bouncing bugs bouncing off the drunk ones? Pure drama.
Anyway, when you are done watching this fascinating show, shut it
down:

> terrarium.stop();

---

We now have two kinds of objects that both have an |act| method and a
|character| property. Because they share these traits, the terrarium
can approach them in the same way. This allows us to have all kinds of
bugs, without changing anything about the terrarium code. This
technique is called _polymorphism_, and it is arguably the most
powerful aspect of object-oriented programming.

The basic idea of polymorphism is that when a piece of code is written
to work with objects that have a certain interface, any kind of object
that happens to support this interface can be plugged into the code,
and it will just work. We already saw simple examples of this, like
the |toString| method on objects. All objects that have a meaningful
|toString| method can be given to |print| and other functions that
need to convert values to strings, and the correct string will be
produced, no matter how their |toString| method chooses to build this
string.

Similarly, |forEach| works on both real arrays and the pseudo-arrays
found in the |arguments| variable, because all it needs is a |length|
property and properties called |0|, |1|, and so on, for the elements
of the array.

---

To make life in the terrarium more life-like, we will add to it the
concepts of food and reproduction. Each living thing in the terrarium
gets a new property, |energy|, which is reduced by performing actions,
and increased by eating things. When it has enough energy, a thing can
reproduce##, generating a new creature of the same kind.

## To keep things reasonably simple, the creatures in our terrarium
reproduce asexually, all by themselves.

If there are only bugs, wasting energy by moving around and eating
each other, a terrarium will soon succumb to the forces of entropy,
run out of energy, and become a lifeless wasteland. To prevent this
from happening (too quickly, at least), we add lichen to the
terrarium. Lichen do not move, they just use photo-synthesis to
gather energy, and reproduce.

To make this work, we will need a terrarium with a different
|processCreature| method. We could just replace the method of to the
|Terrarium| prototype, but we have become very attached to the
simulation of the bouncing and drunk bugs, and we would hate to break
our old terrarium.

What we can do is create a new constructor, |LifeLikeTerrarium|, whose
prototype is based on the |Terrarium| prototype, but which has a
different |processCreature| method.

---

There are a few ways to do this. We could go over the properties of
|Terrarium.prototype|, and add them one by one to
|LifeLikeTerrarium.prototype|. This is easy to do, and in some cases
it is the best solution, but in this case there is a cleaner way. If
we make the old prototype object the prototype of the new prototype
object (you may have to re-read that a few times), it will
automatically have all its properties.

@_|clone|_Unfortunately, JavaScript does not have a straightforward
way to create an object whose prototype is a certain other object. It
is possible to write a function that does this, though, by using the
following trick:

> function clone(object) {
>   function OneShotConstructor(){}
>   OneShotConstructor.prototype = object;
>   return new OneShotConstructor();
> }

This function uses an empty one-shot constructor, whose prototype is
the given object. When using |new| on this constructor, it will create
a new object based on the given object.

> function LifeLikeTerrarium(plan) {
>   Terrarium.call(this, plan);
> }
> LifeLikeTerrarium.prototype = clone(Terrarium.prototype);
> LifeLikeTerrarium.prototype.constructor = LifeLikeTerrarium;

The new constructor doesn't need to do anything different from the old
one, so it just calls the old one on the |this| object. We also have
to restore the |constructor| property in the new prototype, or it
would claim its constructor is |Terrarium| (which, of course, is only
really a problem when we make use of this property, which we don't).

---

It is now possible to replace some of the methods of the
|LifeLikeTerrarium| object, or add new ones. We have based a new
object type on an old one, which saved us the work of re-writing all
the methods which are the same in |Terrarium| and |LifeLikeTerrarium|.
This technique is called '_inheritance_'. The new type inherits the
properties of the old type. In most cases, this means the new type
will still support the interface of the old type, though it might also
support a few methods that the old type does not have. This way,
objects of the new type can be (polymorphically) used in all the
places where objects of the old type could be used.

In most programming languages with explicit support for
object-oriented programming, inheritance is a very straightforward
thing. In JavaScript, the language doesn't really specify a simple way
to do it. Because of this, JavaScript programmers have invented many
different approaches to inheritance. Unfortunately, none of them is
quite perfect. Fortunately, such a broad range of approaches allows a
programmer to choose the most suitable one for the problem he is
solving, and allows certain tricks that would be utterly impossible in
other languages.

At the end of this chapter, I will show a few other ways to do
inheritance, and the issues they have.

---

Here is the new |processCreature| method. It is big.

> LifeLikeTerrarium.prototype.processCreature = function(creature) {
>   var surroundings = this.listSurroundings(creature.point);
>   var action = creature.object.act(surroundings);
>
>   var target = undefined;
>   var valueAtTarget = undefined;
>   if (action.direction && directions.contains(action.direction)) {
>     var direction = directions.lookup(action.direction);
>     var maybe = creature.point.add(direction);
>     if (this.grid.isInside(maybe)) {
>       target = maybe;
>       valueAtTarget = this.grid.valueAt(target);
>     }
>   }
>
>   if (action.type == "move") {
>     if (target && !valueAtTarget) {
>       this.grid.moveValue(creature.point, target);
>       creature.point = target;
>       creature.object.energy -= 1;
>     }
>   }
>   else if (action.type == "eat") {
>     if (valueAtTarget && valueAtTarget.energy) {
>       this.grid.setValueAt(target, undefined);
>       creature.object.energy += valueAtTarget.energy;
>     }
>   }
>   else if (action.type == "photosynthese") {
>     creature.object.energy += 1;
>   }
>   else if (action.type == "reproduce") {
>     if (target && !valueAtTarget) {
>       var species = characterFromElement(creature.object);
>       var baby = elementFromCharacter(species);
>       creature.object.energy -= baby.energy * 2;
>       if (creature.object.energy > 0)
>         this.grid.setValueAt(target, baby);
>     }
>   }
>   else if (action.type == "wait") {
>     creature.object.energy -= 0.2;
>   }
>   else {
>     throw new Error("Unsupported action: " + action.type);
>   }
>
>   if (creature.object.energy <= 0)
>     this.grid.setValueAt(creature.point, undefined);
> };

The function still starts by asking the creature for an action. Then,
if the action has a |direction| property, it immediately computes
which point on the grid this direction points to and which value is
currently sitting there. Three of the five supported actions need to
know this, and the code would be even uglier if they all computed it
separately. If there is no |direction| property, or an invalid one, it
leaves the variables |target| and |valueAtTarget| undefined.

After this, it goes over all the actions. Some actions require
additional checking before they are executed, this is done with a
separate |if| so that if a creature, for example, tries to walk
through a wall, we do not generate an |"Unsupported action"|
exception.

Note that, in the |"reproduce"| action, the parent creature loses
twice the energy that the newborn creature gets (childbearing is not
easy), and the new creature is only placed on the grid if the parent
had enough energy to produce it.

After the action has been performed, we check whether the creature is
out of energy. If it is, it dies, and we remove it.

---

Lichen is not a very complex organism. We will use the character |"*"|
to represent it. Make sure you have defined the |randomElement|
function from \\edrunkbug, because it is used again here.

> function Lichen() {
>   this.energy = 5;
> }
> Lichen.prototype.act = function(surroundings) {
>   var emptySpace = findDirections(surroundings, " ");
>   if (this.energy >= 13 && emptySpace.length > 0)
>     return {type: "reproduce", direction: randomElement(emptySpace)};
>   else if (this.energy < 20)
>     return {type: "photosynthese"};
>   else
>     return {type: "wait"};
> };
> Lichen.prototype.character = "*";
>
> creatureTypes.register(Lichen);
>
> function findDirections(surroundings, wanted) {
>   var found = [];
>   directions.each(function(name) {
>     if (surroundings[name] == wanted)
>       found.push(name);
>   });
>   return found;
> }

Lichen do not grow bigger than 20 energy, or they would get *huge*
when they are surrounded by other lichen and have no room to
reproduce.

***

Create a |LichenEater| creature. It starts with an energy of |10|, and
behaves in the following way:

 * When it has an energy of 30 or more, and there is room near it, it reproduces.
 * Otherwise, if there are lichen nearby, it eats a random one.
 * Otherwise, if there is space to move, it moves into a random nearby empty square.
 * Otherwise, it waits.

Use |findDirections| and |randomElement| to check the surroundings and
to pick directions. Give the lichen-eater |"c"| as its character
(pac-man).

///

> function LichenEater() {
>   this.energy = 10;
> }
> LichenEater.prototype.act = function(surroundings) {
>   var emptySpace = findDirections(surroundings, " ");
>   var lichen = findDirections(surroundings, "*");
>
>   if (this.energy >= 30 && emptySpace.length > 0)
>     return {type: "reproduce", direction: randomElement(emptySpace)};
>   else if (lichen.length > 0)
>     return {type: "eat", direction: randomElement(lichen)};
>   else if (emptySpace.length > 0)
>     return {type: "move", direction: randomElement(emptySpace)};
>   else
>     return {type: "wait"};
> };
> LichenEater.prototype.character = "c";
>
> creatureTypes.register(LichenEater);

---

And try it out.

> var lichenPlan =
>   ["############################",
>    "#                     ######",
>    "#    ***                **##",
>    "#   *##**         **  c  *##",
>    "#    ***     c    ##**    *#",
>    "#       c         ##***   *#",
>    "#                 ##**    *#",
>    "#   c       #*            *#",
>    "#*          #**       c   *#",
>    "#***        ##**    c    **#",
>    "#*****     ###***       *###",
>    "############################"];
>
> var terrarium = new LifeLikeTerrarium(lichenPlan);
> terrarium.onStep = partial(inPlacePrinter(), terrarium);
> terrarium.start();

Most likely, you will see the lichen quickly over-grow a large part of
the terrarium, after which the abundance of food makes the eaters so
numerous that they wipe out all the lichen, and thus themselves. Ah,
tragedy of nature.

> terrarium.stop();

---

Having the inhabitants of your terrarium go extinct after a few
minutes is kind of depressing. To deal with this, we have to teach our
lichen-eaters about long-term sustainable farming. By making them only
eat if they see at least two lichen nearby, no matter how hungry they
are, they will never exterminate the lichen. This requires some
discipline, but the result is a biotope that does not destroy itself.
Here is a new |act| method -- the only change is that it now only eats
when |lichen.length| is at least two.

> LichenEater.prototype.act = function(surroundings) {
>   var emptySpace = findDirections(surroundings, " ");
>   var lichen = findDirections(surroundings, "*");
>
>   if (this.energy >= 30 && emptySpace.length > 0)
>     return {type: "reproduce", direction: randomElement(emptySpace)};
>   else if (lichen.length > 1)
>     return {type: "eat", direction: randomElement(lichen)};
>   else if (emptySpace.length > 0)
>     return {type: "move", direction: randomElement(emptySpace)};
>   else
>     return {type: "wait"};
> };

Run the above |lichenPlan| terrarium again, and see how it goes.
Unless you are very lucky, the lichen-eaters will probably still go
extinct after a while, because, in a time of mass starvation, they
crawl aimlessly back and forth through empty space, instead of finding
the lichen that is sitting just around the corner.

***

Find a way to modify the |LichenEater| to be more likely to survive.
Do not cheat -- |this.energy += 100| is cheating. If you rewrite the
constructor, do not forget to re-register it in the |creatureTypes|
dictionary, or the terrarium will continue to use the old constructor.

///

One approach would be to reduce the randomness of its movement. By
always picking a random direction, it will often move back and forth
without getting anywhere. By remembering the last direction it went,
and preferring that direction, the eater will waste less time, and
find food faster.

> function CleverLichenEater() {
>   this.energy = 10;
>   this.direction = "ne";
> }
> CleverLichenEater.prototype.act = function(surroundings) {
>   var emptySpace = findDirections(surroundings, " ");
>   var lichen = findDirections(surroundings, "*");
>
>   if (this.energy >= 30 && emptySpace.length > 0) {
>     return {type: "reproduce",
>             direction: randomElement(emptySpace)};
>   }
>   else if (lichen.length > 1) {
>     return {type: "eat",
>             direction: randomElement(lichen)};
>   }
>   else if (emptySpace.length > 0) {
>     if (surroundings[this.direction] != " ")
>       this.direction = randomElement(emptySpace);
>     return {type: "move",
>             direction: this.direction};
>   }
>   else {
>     return {type: "wait"};
>   }
> };
> CleverLichenEater.prototype.character = "c";
>
> creatureTypes.register(CleverLichenEater);

Try it out using the previous terrarium-plan.

***

A one-link food chain is still a bit rudimentary. Can you write a new
creature, |LichenEaterEater| (character |"@"|), which survives by
eating lichen-eaters? Try to find a way to make it fit in the
ecosystem without dying out too quickly. Modify the |lichenPlan| array
to include a few of these, and try them out.

///

You are on your own here. I failed to find a really good way to
prevent these creatures from either going extinct right away or
gobbling up all lichen-eaters and then going extinct. The trick of
only eating when it spots two pieces of food doesn't work very well
for them, because their food moves around so much it is rare to find
two in one place. What does seem to help is making the eater-eater
really fat (high energy), so that it can survive times when
lichen-eaters are scarce, and only reproduces slowly, which prevents
it from exterminating its food source too quickly.

The lichen and eaters go through a periodic movement -- sometimes
lichen are abundant, which causes a lot of eaters to be born, which
causes the lichen to become scarce, which causes the eaters to starve,
which causes the lichen to become abundant, and so on. You could try
to make the lichen-eater-eaters 'hibernate' (use the |"wait"| action
for a while), when they fail to find food for a few turns. If you
choose the right amount of turns for this hibernation, or have them
wake up automatically when they smell lots of food, this could be a
good strategy.

---

That concludes our discussion of terraria. The rest of the chapter is
devoted to a more in-depth look at inheritance, and the problems
related to inheritance in JavaScript.

---

First, some theory. Students of object-oriented programming can often
be heard having lengthy, subtle discussions about correct and
incorrect uses of inheritance. It is important to bear in mind that
inheritance, in the end, is just a trick that allows lazy##
programmers to write less code. Thus, the question of whether
inheritance is being used correctly boils down to the question of
whether the resulting code works correctly and avoids useless
repetitions. Still, the principles used by these students provide a
good way to start thinking about inheritance.

## Laziness, for a programmer, is not necessarily a sin. The kind of
people who will industriously do the same thing over and over again
tend to make great assembly-line workers and lousy programmers.

Inheritance is the creation of a new type of objects, the
'_sub-type_', based on an existing type, the '_super-type_'. The
sub-type starts with all the properties and methods of the super-type,
it inherits them, and then modifies a few of these, and optionally
adds new ones. Inheritance is best used when the thing modelled by the
sub-type can be said to *be* an object of the super-type.

Thus, a |Piano| type could be a sub-type of an |Instrument| type,
because a piano *is* an instrument. Because a piano has a whole array
of keys, one might be tempted to make |Piano| a sub-type of |Array|,
but a piano *is* no array, and implementing it like that is bound to
lead to all kinds of silliness. For example, a piano also has pedals.
Why would |piano[0]| give me the first key, and not the first pedal?
The situation is, of course, that a piano *has* keys, so it would be
better to give it a property |keys|, and possibly another property
|pedals|, both holding arrays.

It is possible for a sub-type to be the super-type of yet another
sub-type. Some problems are best solved by building a complex family
tree of types. You have to take care not to get too inheritance-happy,
though. Overuse of inheritance is a great way to make a program into a
big ugly mess.

---

The working of the |new| keyword and the |prototype| property of
constructors suggest a certain way of using objects. For simple
objects, such as the terrarium-creatures, this way works rather well.
Unfortunately, when a program starts to make serious use of
inheritance, this approach to objects quickly becomes clumsy. Adding
some functions to take care of common operations can make things a
little smoother. Many people define, for example, |inherit| and
|method| methods on objects.

> Object.prototype.inherit = function(baseConstructor) {
>   this.prototype = clone(baseConstructor.prototype);
>   this.prototype.constructor = this;
> };
> Object.prototype.method = function(name, func) {
>   this.prototype[name] = func;
> };
>
> function StrangeArray(){}
> StrangeArray.inherit(Array);
> StrangeArray.method("push", function(value) {
>   Array.prototype.push.call(this, value);
>   Array.prototype.push.call(this, value);
> });
>
> var strange = new StrangeArray();
> strange.push(4);
> show(strange);

If you search the web for the words 'JavaScript' and 'inheritance',
you will come across scores of different variations on this, some of
them quite a lot more complex and clever than the above.

Note how the |push| method written here uses the |push| method from
the prototype of its parent type. This is something that is done often
when using inheritance -- a method in the sub-type internally uses a
method of the super-type, but extends it somehow.

---

The biggest problem with this basic approach is the duality between
constructors and prototypes. Constructors take a very central role,
they are the things that give an object type its name, and when you
need to get at a prototype, you have to go to the constructor and take
its |prototype| property.

Not only does this lead to a *lot* of typing (|"prototype"| is 9
letters), it is also confusing. We had to write an empty, useless
constructor for |StrangeArray| in the example above. Quite a few
times, I have found myself accidentally adding methods to a
constructor instead of its prototype, or trying to call |Array.slice|
when I really meant |Array.prototype.slice|. As far as I am concerned,
the prototype itself is the most important aspect of an object type,
and the constructor is just an extension of that, a special kind of
method.

---

With a few simple helper methods added to |Object.prototype|, it is
possible to create an alternative approach to objects and inheritance.
In this approach, a type is represented by its prototype, and we will
use capitalised variables to store these prototypes. When it needs to
do any 'constructing' work, this is done by a method called
|construct|. We add a method called |create| to the |Object|
prototype, which is used in place of the |new| keyword. It clones the
object, and calls its |construct| method, if there is such a method,
giving it the arguments that were passed to |create|.

> Object.prototype.create = function() {
>   var object = clone(this);
>   if (typeof object.construct == "function")
>     object.construct.apply(object, arguments);
>   return object;
> };

Inheritance can be done by cloning a prototype object and adding or
replacing some of its properties. We also provide a convenient
shorthand for this, an |extend| method, which clones the object it is
applied to and adds to this clone the properties in the object that it
is given as an argument.

> Object.prototype.extend = function(properties) {
>   var result = clone(this);
>   forEachIn(properties, function(name, value) {
>     result[name] = value;
>   });
>   return result;
> };

In a case where it is not safe to mess with the |Object| prototype,
these can of course be implemented as regular (non-method) functions.

---

An example. If you are old enough, you may at one time have played a
'text adventure' game, where you move through a virtual world by
typing commands, and get textual descriptions of the things around you
and the actions you perform. Now those were games!

We could write the prototype for an item in such a game like this.

> var Item = {
>   construct: function(name) {
>     this.name = name;
>   },
>   inspect: function() {
>     print("it is ", this.name, ".");
>   },
>   kick: function() {
>     print("klunk!");
>   },
>   take: function() {
>     print("you can not lift ", this.name, ".");
>   }
> };
>
> var lantern = Item.create("the brass lantern");
> lantern.kick();

Inherit from it like this...

> var DetailedItem = Item.extend({
>   construct: function(name, details) {
>     Item.construct.call(this, name);
>     this.details = details;
>   },
>   inspect: function() {
>     print("you see ", this.name, ", ", this.details, ".");
>   }
> });
>
> var giantSloth = DetailedItem.create(
>   "the giant sloth",
>   "it is quietly hanging from a tree, munching leaves");
> giantSloth.inspect();

Leaving out the compulsory |prototype| part makes things like calling
|Item.construct| from |DetailedItem|'s constructor slightly simpler.
Note that it would be a bad idea to just do |this.name = name| in
|DetailedItem.construct|. This duplicates a line. Sure, duplicating
the line is shorter than calling the |Item.construct| function, but if
we end up adding something to this constructor later, we have to add
it in two places.

---

Most of the time, a sub-type's constructor should start by calling the
constructor of the super-type. This way, it starts with a valid object
of the super-type, which it can then extend. In this new approach to
prototypes, types that need no constructor can leave it out. They will
automatically inherit the constructor of their super-type.

> var SmallItem = Item.extend({
>   kick: function() {
>     print(this.name, " flies across the room.");
>   },
>   take: function() {
>     // (imagine some code that moves the item to your pocket here)
>     print("you take ", this.name, ".");
>   }
> });
>
> var pencil = SmallItem.create("the red pencil");
> pencil.take();

Even though |SmallItem| does not define its own constructor, creating
it with a |name| argument works, because it inherited the constructor
from the |Item| prototype.

---

JavaScript has an operator called _|instanceof|_, which can be used to
determine whether an object is based on a certain prototype. You give
it the object on the left hand side, and a constructor on the right
hand side, and it returns a boolean, |true| if the constructor's
|prototype| property is the direct or indirect prototype of the
object, and |false| otherwise.

When you are not using regular constructors, using this operator
becomes rather clumsy -- it expects a constructor function as its
second argument, but we only have prototypes. A trick similar to the
|clone| function can be used to get around it: We use a 'fake
constructor', and apply |instanceof| to it.

> Object.prototype.hasPrototype = function(prototype) {
>   function DummyConstructor() {}
>   DummyConstructor.prototype = prototype;
>   return this instanceof DummyConstructor;
> };
>
> show(pencil.hasPrototype(Item));
> show(pencil.hasPrototype(DetailedItem));

---

Next, we want to make a small item that has a detailed description. It
seems like this item would have to inherit both from |DetailedItem|
and |SmallItem|. JavaScript does not allow an object to have multiple
prototypes, and even if it did, the problem would not be quite that
easy to solve. For example, if |SmallItem| would, for some reason,
also define an |inspect| method, which |inspect| method should the new
prototype use?

Deriving an object type from more than one parent type is called
_multiple inheritance_. Some languages chicken out and forbid it
altogether, others define complicated schemes for making it work in a
well-defined and practical way. It is possible to implement a decent
multiple-inheritance framework in JavaScript. In fact there are, as
usual, multiple good approaches to this. But they all are too complex
to be discussed here. Instead, I will show a very simple approach
which suffices in most cases.

---

A _mix-in_ is a specific kind of prototype which can be 'mixed into'
other prototypes. |SmallItem| can be seen as such a prototype. By
copying its |kick| and |take| methods into another prototype, we mix
smallness into this prototype.

> function mixInto(object, mixIn) {
>   forEachIn(mixIn, function(name, value) {
>     object[name] = value;
>   });
> };
>
> var SmallDetailedItem = clone(DetailedItem);
> mixInto(SmallDetailedItem, SmallItem);
>
> var deadMouse = SmallDetailedItem.create(
>   "Fred the mouse",
>   "he is dead");
> deadMouse.inspect();
> deadMouse.kick();

Remember that |forEachIn| only goes over the object's *own*
properties, so it will copy |kick| and |take|, but not the constructor
that |SmallItem| inherited from |Item|.

---

Mixing prototypes gets more complex when the mix-in has a constructor,
or when some of its methods 'clash' with methods in the prototype that
it is mixed into. Sometimes, it is workable to do a 'manual mix-in'.
Say we have a prototype |Monster|, which has its own constructor, and
we want to mix that with |DetailedItem|.

> var Monster = Item.extend({
>   construct: function(name, dangerous) {
>     Item.construct.call(this, name);
>     this.dangerous = dangerous;
>   },
>   kick: function() {
>     if (this.dangerous)
>       print(this.name, " bites your head off.");
>     else
>       print(this.name, " runs away, weeping.");
>   }
> });
>
> var DetailedMonster = DetailedItem.extend({
>   construct: function(name, description, dangerous) {
>     DetailedItem.construct.call(this, name, description);
>     Monster.construct.call(this, name, dangerous);
>   },
>   kick: Monster.kick
> });
>
> var giantSloth = DetailedMonster.create(
>   "the giant sloth",
>   "it is quietly hanging from a tree, munching leaves",
>   true);
> giantSloth.kick();

But note that this causes |Item| constructor to be called twice when
creating a |DetailedMonster| -- once through the |DetailedItem|
constructor, and once through the |Monster| constructor. In this case
there is not much harm done, but there are situations where this would
cause a problem.

---

But don't let those complications discourage you from making use of
inheritance. Multiple inheritance, though extremely useful in some
situations, can be safely ignored most of the time. This is why
languages like Java get away with forbidding multiple inheritance. And
if, at some point, you find that you really need it, you can search
the web, do some research, and figure out an approach that works for
your situation.

Now that I think about it, JavaScript would probably be a great
environment for building a text adventure. The ability to change the
behaviour of objects at will, which is what prototypical inheritance
gives us, is very well suited for this. If you have an object
|hedgehog|, which has the unique habit of rolling up when it is
kicked, you can just change its |kick| method.

Unfortunately, the text adventure went the way of the vinyl record
and, while once very popular, is nowadays only played by a small
population of [enthusiasts | http://groups.google.com/group/rec.arts.int-fiction/topics].

=======================
Modularity / modularity
=======================

This chapter deals with the process of organising programs. In small
programs, organisation rarely becomes a problem. As a program grows,
however, it can reach a size where its structure and interpretation
become hard to keep track of. Easily enough, such a program starts to
look like a bowl of spaghetti, an amorphous mass in which everything
seems to be connected to everything else.

When structuring a program, we do two things. We separate it into
smaller parts, called _module_s, each of which has a specific role,
and we specify the relations between these parts.

In \\coo, while developing a terrarium, we made use of a number of
functions described in \\cfp. The chapter also defined a few new
concepts that had nothing in particular to do with terraria, such as
|clone| and the |Dictionary| type. All these things were haphazardly
added to the environment. One way to split this program into modules
would be:

 * A module |FunctionalTools|, which contains the functions from \\cfp, and depends on nothing.
 * Then |ObjectTools|, which contains things like |clone| and |create|, and depends on |FunctionalTools|.
 * |Dictionary|, containing the dictionary type, and depending on |FunctionalTools|.
 * And finally the |Terrarium| module, which depends on |ObjectTools| and |Dictionary|.

When a module _depend_s on another module, it uses functions or
variables from that module, and will only work when this module is
loaded.

It is a good idea to make sure dependencies never form a circle. Not
only do circular dependencies create a practical problem (if module
|A| and |B| depend on each other, which one should be loaded first?),
it also makes the relation between the modules less straightforward,
and can result in a modularised version of the spaghetti I mentioned
earlier.

---

Most modern programming languages have some kind of module system
built in. Not JavaScript. Once again, we have to invent something
ourselves. The most obvious way to start is to put every module in a
different file. This makes it clear which code belongs to which
module.

@_|script|_Browsers load JavaScript files when they find a |<script>|
tag with an |src| attribute in the HTML of the web-page. The extension
|.js| is usually used for files containing JavaScript code. On the
console, a shortcut for loading files is provided by the |load|
function.

> load("FunctionalTools.js");

---

In some cases, giving load commands in the wrong order will result in
errors. If a module tries to create a |Dictionary| object, but the
|Dictionary| module has not been loaded yet, it will be unable to find
the constructor, and will fail.

One would imagine this to be easy to solve. Just put some calls to
|load| at the top of the file for a module, to load all the modules it
depends on. Unfortunately, because of the way browsers work, calling
|load| does not immediately cause the given file to be loaded. The
file will be loaded *after* the current file has finished executing.
Which is too late, usually.

In most cases, the practical solution is to just manage dependencies
by hand: Put the |script| tags in your HTML documents in the right
order.

---

There are two ways to (partially) automate dependency management. The
first is to keep a separate file with information about the
dependencies between modules. This can be loaded first, and used to
determine the order in which to load the files. The second way is to
not use a |script| tag (|load| internally creates and adds such a
tag), but to fetch the content of the file directly (see \\cxhr), and
then use the |eval| function to execute it. This makes script loading
instantaneous, and thus easier to deal with.

_|eval|_, short for 'evaluate', is an interesting function. You give
it a string value, and it will execute the content of the string as
JavaScript code.

> eval("print(\"I am a string inside a string!\");");

You can imagine that |eval| can be used to do some interesting things.
Code can build new code, and run it. In most cases, however, problems
that can be solved with creative uses of |eval| can also be solved
with creative uses of anonymous functions, and the latter is less
likely to cause strange problems.

When |eval| is called inside a function, all new variables will become
local to that function. Thus, when a variation of the |load| would use
|eval| internally, loading the |Dictionary| module would create a
|Dictionary| constructor inside of the |load| function, which would be
lost as soon as the function returned. There are ways to work around
this, but they are rather clumsy.

---

Let us quickly go over the first variant of dependency management. It
requires a special file for dependency information, which could look
something like this:

> var dependencies =
>   {"ObjectTools.js": ["FunctionalTools.js"],
>    "Dictionary.js":  ["ObjectTools.js"],
>    "TestModule.js":  ["FunctionalTools.js", "Dictionary.js"]};

The |dependencies| object contains a property for each file that
depends on other files. The values of the properties are arrays of
file names. Note that we could not use a |Dictionary| object here,
because we can not be sure that the |Dictionary| module has been
loaded yet. Because all the properties in this object will end in
|".js"|, they are unlikely to interfere with hidden properties like
|__proto__| or |hasOwnProperty|, and a regular object will work fine.

The dependency manager must do two things. Firstly it must make sure
that files are loaded in the correct order, by loading a file's
dependencies before the file itself. And secondly, it must make sure
that no file is loaded twice. Loading the same file twice might cause
problems, and is definitely a waste of time.

> var loadedFiles = {};
>
> function require(file) {
>   if (dependencies[file]) {
>     var files = dependencies[file];
>     for (var i = 0; i < files.length; i++)
>       require(files[i]);
>   }
>   if (!loadedFiles[file]) {
>     loadedFiles[file] = true;
>     load(file);
>   }
> }

The _|require|_ function can now be used to load a file and all its
dependencies. Note how it recursively calls itself to take care of
dependencies (and possible dependencies of that dependency).

> require("TestModule.js");

> test();

---

Building a program as a set of nice, small modules often means the
program will use a lot of different files. When programming for the
web, having lots of small JavaScript files on a page tends to make the
page slower to load. This does not have to be a problem though. You
can write and test your program as a number of small files, and put
them all into a single big file when 'publishing' the program to the
web.

---

Just like an object type, a module has an interface. In simple
collection-of-functions modules such as |FunctionalTools|, the
interface usually consists of all the functions that are defined in
the module. In other cases, the interface of the module is only a
small part of the functions defined inside it. For example, our
manuscript-to-HTML system from \\cfp only needs an interface of a
single function, |renderFile|. (The sub-system for building HTML would
be a separate module.)

For modules which only define a single type of object, such as
|Dictionary|, the object's interface is the same as the module's
interface.

---

In JavaScript, 'top-level' variables all live together in a single
place. In browsers, this place is an object that can be found under
the name |window|. The name is somewhat odd, |environment| or |top|
would have made more sense, but since browsers associate a JavaScript
environment with a window (or 'frame'), someone decided that |window|
was a logical name.

> show(window);
> show(window.print == print);
> show(window.window.window.window.window);

As the third line shows, the name |window| is merely a property of
this environment object, pointing at itself.

---

When much code is loaded into an environment, it will use many
top-level variable names. Once there is more code than you can really
keep track of, it becomes very easy to accidentally use a name that
was already used for something else. This will break the code that
used the original value. The proliferation of top-level variables is
called _name-space pollution_, and it can be a rather severe problem
in JavaScript -- the language will not warn you when you redefine an
existing variable.

There is no way to get rid of this problem entirely, but it can be
greatly reduced by taking care to cause as little pollution as
possible. For one thing, modules should not use top-level variables
for values that are not part of their external interface.

---

Not being able to define any internal functions and variables at all
in your modules is, of course, not very practical. Fortunately, there
is a trick to get around this. We write all the code for the module
inside a function, and then finally add the variables that are part of
the module's interface to the |window| object. Because they were
created in the same parent function, all the functions of the module
can see each other, but code outside of the module can not.

> function buildMonthNameModule() {
>   var names = ["January", "February", "March", "April",
>                "May", "June", "July", "August", "September",
>                "October", "November", "December"];
>   function getMonthName(number) {
>     return names[number];
>   }
>   function getMonthNumber(name) {
>     for (var number = 0; number < names.length; number++) {
>       if (names[number] == name)
>         return number;
>     }
>   }
>
>   window.getMonthName = getMonthName;
>   window.getMonthNumber = getMonthNumber;
> }
> buildMonthNameModule();
>
> show(getMonthName(11));

This builds a very simple module for translating between month names
and their number (as used by |Date|, where January is |0|). But note
that |buildMonthNameModule| is still a top-level variable that is not
part of the module's interface. Also, we have to repeat the names of
the interface functions three times. Ugh.

---

The first problem can be solved by making the module function
anonymous, and calling it directly. To do this, we have to add a pair
of parentheses around the function value, or JavaScript will think it
is a normal function definition, which can not be called directly.

The second problem can be solved with a helper function, |provide|,
which can be given an object containing the values that must be
exported into the |window| object.

> function provide(values) {
>   forEachIn(values, function(name, value) {
>     window[name] = value;
>   });
> }

Using this, we can write a module like this:

> (function() {
>   var names = ["Sunday", "Monday", "Tuesday", "Wednesday",
>                "Thursday", "Friday", "Saturday"];
>   provide({
>     getDayName: function(number) {
>       return names[number];
>     },
>     getDayNumber: function(name) {
>       for (var number = 0; number < names.length; number++) {
>         if (names[number] == name)
>           return number;
>       }
>     }
>   });
> })();
>
> show(getDayNumber("Wednesday"));

I do not recommend writing modules like this right from the start.
While you are still working on a piece of code, it is easier to just
use the simple approach we have used so far, and put everything at top
level. That way, you can inspect the module's internal values in your
browser, and test them out. Once a module is more or less finished, it
is not difficult to wrap it in a function.

---

There are cases where a module will export so many variables that it
is a bad idea to put them all into the top-level environment. In cases
like this, you can do what the standard |Math| object does, and
represent the module as a single object whose properties are the
functions and values it exports. For example...

> var HTML = {
>   tag: function(name, content, properties) {
>     return {name: name, properties: properties, content: content};
>   },
>   link: function(target, text) {
>     return HTML.tag("a", [text], {href: target});
>   }
>   /* ... many more HTML-producing functions ... */
> };

When you need the content of such a module so often that it becomes
cumbersome to constantly type |HTML|, you can always move it into the
top-level environment using |provide|.

> provide(HTML);
> show(link("http://download.oracle.com/docs/cd/E19957-01/816-6408-10/object.htm",
>           "This is how objects work."));

You can even combine the function and object approaches, by putting
the internal variables of the module inside a function, and having
this function return an object containing its external interface.

---

When adding methods to standard prototypes, such as those of |Array|
and |Object| a similar problem to name-space pollution occurs. If two
modules decide to add a |map| method to |Array.prototype|, you might
have a problem. If these two versions of |map| have the precise same
effect, things will continue to work, but only by sheer luck.

---

Designing an interface for a module or an object type is one of the
subtler aspects of programming. On the one hand, you do not want to
expose too many details. They will only get in the way when using the
module. On the other hand, you do not want to be *too* simple and
general, because that might make it impossible to use the module in
complex or specialised situations.

Sometimes the solution is to provide two interfaces, a detailed
'low-level' one for complicated things, and a simple 'high-level' one
for straightforward situations. The second one can usually be built
very easily using the tools provided by the first one.

In other cases, you just have to find the right idea around which to
base your interface. Compare this to the various approaches to
inheritance we saw in \\coo. By making prototypes the central concept,
rather than constructors, we managed to make some things considerably
more straightforward.

The best way to learn to the value of good interface design is,
unfortunately, to use bad interfaces. Once you get fed up with them,
you'll figure out a way to improve them, and learn a lot in the
process. Try not to assume that a lousy interface is 'just the way it
is'. Fix it, or wrap it in a new interface that is better (we will see
an example of this in \\cdom).

---

There are functions which require a lot of arguments. Sometimes this
means they are just badly designed, and can easily be remedied by
splitting them into a few more modest functions. But in other cases,
there is no way around it. Typically, some of these arguments have a
sensible 'default' value. We could, for example, write yet another
extended version of |range|.

> function range(start, end, stepSize, length) {
>   if (stepSize == undefined)
>     stepSize = 1;
>   if (end == undefined)
>     end = start + stepSize * (length - 1);
>
>   var result = [];
>   for (; start <= end; start += stepSize)
>     result.push(start);
>   return result;
> }
>
> show(range(0, undefined, 4, 5));

It can get hard to remember which argument goes where, not to mention
the annoyance of having to pass |undefined| as a second argument when
a |length| argument is used. We can make passing arguments to this
function more comprehensive by wrapping them in an object.

> function defaultTo(object, values) {
>   forEachIn(values, function(name, value) {
>     if (!object.hasOwnProperty(name))
>       object[name] = value;
>   });
> }
>
> function range(args) {
>   defaultTo(args, {start: 0, stepSize: 1});
>   if (args.end == undefined)
>     args.end = args.start + args.stepSize * (args.length - 1);
>
>   var result = [];
>   for (; args.start <= args.end; args.start += args.stepSize)
>     result.push(args.start);
>   return result;
> }
>
> show(range({stepSize: 4, length: 5}));

The |defaultTo| function is useful for adding default values to an
object. It copies the properties of its second argument into its first
argument, skipping those that already have a value.

---

A module or group of modules that can be useful in more than one
program is usually called a _library_. For many programming languages,
there is a huge set of quality libraries available. This means
programmers do not have to start from scratch all the time, which can
make them a lot more productive. For JavaScript, unfortunately, the
amount of available libraries is not very large.

But recently this seems to be improving. There are a number of good
libraries with 'basic' tools, things like |map| and |clone|. Other
languages tend to provide such obviously useful things as built-in
standard features, but with JavaScript you'll have to either build a
collection of them for yourself or use a library. Using a library is
recommended: It is less work, and the code in a library has usually
been tested more thoroughly than the things you wrote yourself.

Covering these basics, there are (among others) the 'lightweight'
libraries [prototype | http://www.prototypejs.org/], [mootools |
http://mootools.net], [jQuery | http://jquery.com], and [MochiKit |
http://mochikit.com]. There are also some larger 'frameworks'
available, which do a lot more than just provide a set of basic tools.
[YUI | http://developer.yahoo.com/yui/] (by Yahoo), and [Dojo |
http://dojotoolkit.org/] seem to be the most popular ones in that
genre. All of these can be downloaded and used free of charge. My
personal favourite is MochiKit, but this is mostly a matter of taste.
When you get serious about JavaScript programming, it is a good idea
to quickly glance through the documentation of each of these, to get a
general idea about the way they work and the things they provide.

The fact that a basic toolkit is almost indispensable for any
non-trivial JavaScript programs, combined with the fact that there are
so many different toolkits, causes a bit of a dilemma for library
writers. You either have to make your library depend on one of the
toolkits, or write the basic tools yourself and include them with the
library. The first option makes the library hard to use for people who
are using a different toolkit, and the second option adds a lot of
non-essential code to the library. This dilemma might be one of the
reasons why there are relatively few good, widely used JavaScript
libraries. It is possible that, in the future, new versions of
ECMAScript and changes in browsers will make toolkits less necessary,
and thus (partially) solve this problem.

============================
Regular Expressions / regexp
============================

At various points in the previous chapters, we had to look for
patterns in string values. In \\cdata we extracted date values from
strings by writing out the precise positions at which the numbers that
were part of the date could be found. Later, in \\cfp, we saw some
particularly ugly pieces of code for finding certain types of
characters in a string, for example the characters that had to be
escaped in HTML output.

@_regular expression_Regular expressions are a language for describing
patterns in strings. They form a small, separate language, which is
embedded inside JavaScript (and in various other programming
languages, in one way or another). It is not a very readable language
-- big regular expressions tend to be completely unreadable. But, it
is a useful tool, and can really simplify string-processing programs.

---

Just like strings get written between quotes, regular expression
patterns get written between slashes (_|/|_). This means that slashes
inside the expression have to be escaped.

> var slash = /\//;
> show("AC/DC".search(slash));

The _|search|_ method resembles |indexOf|, but it searches for a
regular expression instead of a string. Patterns specified by regular
expressions can do a few things that strings can not do. For a start,
they allow some of their elements to match more than a single
character. In \\cfp, when extracting mark-up from a document, we
needed to find the first asterisk or opening brace in a string. That
could be done like this:

> var asteriskOrBrace = /[\{\*]/;
> var story =
>   "We noticed the *giant sloth*, hanging from a giant branch.";
> show(story.search(asteriskOrBrace));

The |[| and |]| characters have a special meaning inside a regular
expression. They can enclose a set of characters, and they mean 'any
of these characters'. Most non-alphanumeric characters have some
special meaning inside a regular expression, so it is a good idea to
always escape them with a backslash## when you use them to refer to
the actual characters.

## In this case, the backslashes were not really necessary, because
the characters occur between |[| and |]|, but it is easier to just
escape them anyway, so you won't have to think about it.

---

There are a few shortcuts for sets of characters that are needed
often. The dot (|.|) can be used to mean 'any character that is not a
newline', an escaped 'd' (|\d|) means 'any digit', an escaped 'w'
(|\w|) matches any alphanumeric character (including underscores, for
some reason), and an escaped 's' (|\s|) matches any white-space (tab,
newline, space) character.

> var digitSurroundedBySpace = /\s\d\s/;
> show("1a 2 3d".search(digitSurroundedBySpace));

The escaped 'd', 'w', and 's' can be replaced by their capital letter
to mean their opposite. For example, |\S| matches any character that
is *not* white-space. When using |[| and |]|, a pattern can be
inverted by starting with a |^| character:

> var notABC = /[^ABC]/;
> show("ABCBACCBBADABC".search(notABC));

As you can see, the way regular expressions use characters to express
patterns makes them A) very short, and B) very hard to read.

***

Write a regular expression that matches a date in the format
|"XX/XX/XXXX"|, where the |X|s are digits. Test it against the string
|"born 15/11/2003 (mother Spot): White Fang"|.

///

> var datePattern = /\d\d\/\d\d\/\d\d\d\d/;
> show("born 15/11/2003 (mother Spot): White Fang".search(datePattern));

---

Sometimes you need to make sure a pattern starts at the beginning of a
string, or ends at its end. For this, the special characters |^| and
|$| can be used. The first matches the start of the string, the second
the end.

> show(/a+/.test("blah"));
> show(/^a+$/.test("blah"));

The first regular expression matches any string that contains an |a|
character, the second only those strings that consist entirely of |a|
characters.

Note that regular expressions are objects, and have methods. Their
_|test|_ method returns a boolean indicating whether the given string
matches the expression.

The code |\b| matches a 'word boundary', which can be punctuation,
white-space, or the start or end of the string.

> show(/cat/.test("concatenate"));
> show(/\bcat\b/.test("concatenate"));

---

Parts of a pattern can be allowed to be repeated a number of times.
Putting an asterisk (|*|) after an element allows it to be repeated
any number of times, including zero. A plus (|+|) does the same, but
requires the pattern to occur at least one time. A question mark (|?|)
makes an element 'optional' -- it can occur zero or one times.

> var parenthesizedText = /\(.*\)/;
> show("Its (the sloth's) claws were gigantic!".search(parenthesizedText));

When necessary, braces can be used to be more precise about the amount
of times an element may occur. A number between braces (|{4}|) gives
the exact amount of times it must occur. Two numbers with a comma
between them (|{3,10}|) indicate that the pattern must occur at least
as often as the first number, and at most as often as the second one.
Similarly, |{2,}| means two or more occurrences, while |{,4}| means
four or less.

> var datePattern = /\d{1,2}\/\d\d?\/\d{4}/;
> show("born 15/11/2003 (mother Spot): White Fang".search(datePattern));

The pieces |/\d{1,2}/| and |/\d\d?/| both express 'one or two digits'.

***

Write a pattern that matches e-mail addresses. For simplicity, assume
that the parts before and after the |@| can contain only alphanumeric
characters and the characters |.| and |-| (dot and dash), while the
last part of the address, the country code after the last dot, may
only contain alphanumeric characters, and must be two or three
characters long.

///

> var mailAddress = /\b[\w\.-]+@[\w\.-]+\.\w{2,3}\b/;
>
> show(mailAddress.test("kenny@test.net"));
> show(mailAddress.test("I mailt kenny@tets.nets, but it didn wrok!"));
> show(mailAddress.test("the_giant_sloth@gmail.com"));

The |\b|s at the start and end of the pattern make sure that the
second string does not match.

---

Part of a regular expression can be grouped together with parentheses.
This allows us to use |*| and such on more than one character. For
example:

> var cartoonCrying = /boo(hoo+)+/i;
> show("Then, he exclaimed 'Boohoooohoohooo'".search(cartoonCrying));

Where did the |i| at the end of that regular expression come from?
After the closing slash, 'options' may be added to a regular
expression. An |i|, here, means the expression is case-insensitive,
which allows the lower-case B in the pattern to match the upper-case
one in the string.

A pipe character (|||) is used to allow a pattern to make a choice
between two elements. For example:

> var holyCow = /(sacred|holy) (cow|bovine|bull|taurus)/i;
> show(holyCow.test("Sacred bovine!"));

---

Often, looking for a pattern is just a first step in extracting
something from a string. In previous chapters, this extraction was
done by calling a string's |indexOf| and |slice| methods a lot. Now
that we are aware of the existence of regular expressions, we can use
the |match| method instead. When a string is matched against a regular
expression, the result will be |null| if the match failed, or an array
of matched strings if it succeeded.

> show("No".match(/Yes/));
> show("... yes".match(/yes/));
> show("Giant Ape".match(/giant (\w+)/i));

The first element in the returned array is always the part of the
string that matched the pattern. As the last example shows, when there
are parenthesized parts in the pattern, the parts they match are also
added to the array. Often, this makes extracting pieces of string very
easy.

> var parenthesized = prompt("Tell me something", "").match(/\((.*)\)/);
> if (parenthesized != null)
>   print("You parenthesized '", parenthesized[1], "'");

***

Re-write the function |extractDate| that we wrote in \\cdata. When
given a string, this function looks for something that follows the
date format we saw earlier. If it can find such a date, it puts the
values into a |Date| object. Otherwise, it throws an exception. Make
it accept dates in which the day or month are written with only one
digit.

///

> function extractDate(string) {
>   var found = string.match(/(\d\d?)\/(\d\d?)\/(\d{4})/);
>   if (found == null)
>     throw new Error("No date found in '" + string + "'.");
>   return new Date(Number(found[3]), Number(found[2]) - 1,
>                   Number(found[1]));
> }
>
> show(extractDate("born 5/2/2007 (mother Noog): Long-ear Johnson"));

This version is slightly longer than the previous one, but it has the
advantage of actually checking what it is doing, and shouting out when
it is given nonsensical input. This was a lot harder without regular
expressions -- it would have taken a lot of calls to |indexOf| to find
out whether the numbers had one or two digits, and whether the dashes
were in the right places.

---

The _|replace|_ method of string values, which we saw in \\cfp, can be
given a regular expression as its first argument.

> print("Borobudur".replace(/[ou]/g, "a"));

Notice the |g| character after the regular expression. It stands for
'global', and means that every part of the string that matches the
pattern should be replaced. When this |g| is omitted, only the first
|"o"| would be replaced.

Sometimes it is necessary to keep parts of the replaced strings. For
example, we have a big string containing the names of people, one name
per line, in the format "Lastname, Firstname". We want to swap these
names, and remove the comma, to get a simple "Firstname Lastname"
format.

> var names = "Picasso, Pablo\nGauguin, Paul\nVan Gogh, Vincent";
> print(names.replace(/([\w ]+), ([\w ]+)/g, "$2 $1"));

The |$1| and |$2| the replacement string refer to the parenthesized
parts in the pattern. |$1| is replaced by the text that matched
against the first pair of parentheses, |$2| by the second, and so on,
up to |$9|.

If you have more than 9 parentheses parts in your pattern, this will
no longer work. But there is one more way to replace pieces of a
string, which can also be useful in some other tricky situations. When
the second argument given to the |replace| method is a function value
instead of a string, this function is called every time a match is
found, and the matched text is replaced by whatever the function
returns. The arguments given to the function are the matched elements,
similar to the values found in the arrays returned by |match|: The
first one is the whole match, and after that comes one argument for
every parenthesized part of the pattern.

> function eatOne(match, amount, unit) {
>   amount = Number(amount) - 1;
>   if (amount == 1) {
>     unit = unit.slice(0, unit.length - 1);
>   }
>   else if (amount == 0) {
>     unit = unit + "s";
>     amount = "no";
>   }
>   return amount + " " + unit;
> }
>
> var stock = "1 lemon, 2 cabbages, and 101 eggs";
> stock = stock.replace(/(\d+) (\w+)/g, eatOne);
>
> print(stock);

***

That last trick can be used to make the HTML-escaper from \\cfp more
efficient. You may remember that it looked like this: 

> function escapeHTML(text) {
>   var replacements = [["&", "&amp;"], ["\"", "&quot;"],
>                       ["<", "&lt;"], [">", "&gt;"]];
>   forEach(replacements, function(replace) {
>     text = text.replace(replace[0], replace[1]);
>   });
>   return text;
> }

Write a new function |escapeHTML|, which does the same thing, but only
calls |replace| once.

///

> function escapeHTML(text) {
>   var replacements = {"<": "&lt;", ">": "&gt;",
>                       "&": "&amp;", "\"": "&quot;"};
>   return text.replace(/[<>&"]/g, function(character) {
>     return replacements[character];
>   });
> }
>
> print(escapeHTML("The 'pre-formatted' tag is written \"<pre>\"."));

The |replacements| object is a quick way to associate each character
with its escaped version. Using it like this is safe (i.e. no
|Dictionary| object is needed), because the only properties that will
be used are those matched by the |/[<>&"]/| expression.

---

There are cases where the pattern you need to match against is not
known while you are writing the code. Say we are writing a (very
simple-minded) obscenity filter for a message board. We only want to
allow messages that do not contain obscene words. The administrator of
the board can specify a list of words that he or she considers
unacceptable.

The most efficient way to check a piece of text for a set of words is
to use a regular expression. If we have our word list as an array, we
can build the regular expression like this:

> var badWords = ["ape", "monkey", "simian", "gorilla", "evolution"];
> var pattern = new RegExp(badWords.join("|"), "i");
> function isAcceptable(text) {
>   return !pattern.test(text);
> }
>
> show(isAcceptable("Mmmm, grapes."));
> show(isAcceptable("No more of that monkeybusiness, now."));

We could add |\b| patterns around the words, so that the thing about
grapes would not be classified as unacceptable. That would also make
the second one acceptable, though, which is probably not correct.
Obscenity filters are hard to get right (and usually way too annoying
to be a good idea).

The first argument to the _|RegExp|_ constructor is a string
containing the pattern, the second argument can be used to add
case-insensitivity or globalness. When building a string to hold the
pattern, you have to be careful with backslashes. Because, normally,
backslashes are removed when a string is interpreted, any backslashes
that must end up in the regular expression itself have to be escaped:

> var digits = new RegExp("\\d+");
> show(digits.test("101"));

---

The most important thing to know about regular expressions is that
they exist, and can greatly enhance the power of your string-mangling
code. They are so cryptic that you'll probably have to look up the
details on them the first ten times you want to make use of them.
Persevere, and you will soon be off-handedly writing expressions that
look like occult gibberish

[[xkcd_regular_expressions.png]]

(Comic by [Randall Munroe | http://xkcd.com].)

=====================================
Web programming: A crash course / web
=====================================

You are probably reading this in a web browser, so you are likely to
be at least a little familiar with the World Wide Web. This
chapter contains a quick, superficial introduction to the various
elements that make the web work, and the way they relate to
JavaScript. The three after this one are more practical, and show some
of the ways JavaScript can be used to inspect and change a web-page.

---

The Internet is, basically, just a computer network spanning most of
the world. Computer networks make it possible for computers to send
each other messages. The techniques that underlie networking are an
interesting subject, but not the subject of this book. All you have to
know is that, typically, one computer, which we will call the
_server_, is waiting for other computers to start talking to it. Once
another computer, the _client_, opens communications with this server,
they will exchange whatever it is that needs to be exchanged using
some specific language, a _protocol_.

The Internet is used to carry messages for *many* different protocols.
There are protocols for chatting, protocols for file sharing,
protocols used by malicious software to control the computer of the
poor schmuck who installed it, and so on. The protocol that is of
interest to us is that used by the World Wide Web. It is called
_HTTP_, which stands for Hyper Text Transfer Protocol, and is used to
retrieve web-pages and the files associated with them.

In HTTP communication, the server is the computer on which the
web-page is stored. The client is the computer, such as yours, which
asks the server for a page, so that it can display it. Asking for a
page like this is called an '_HTTP request_'.

---

Web-pages and other files that are accessible though the Internet are
identified by _URL_s, which is an abbreviation of Universal Resource
Locators. A URL looks like this:

] http://acc6.its.brooklyn.cuny.edu/~phalsall/texts/taote-v3.html

It is composed of three parts. The start, |http://|, indicates that
this URL uses the HTTP protocol. There are some other protocols, such
as FTP (File Transfer Protocol), which also make use of URLs. The next
part, |acc6.its.brooklyn.cuny.edu|, names the server on which this
page can be found. The end of the URL,
|/~phalsal/texts/taote-v3.html|, names a specific file on this server.

Most of the time, the World Wide Web is accessed using a browser.
After typing a URL or clicking a link, the browser makes the
appropriate HTTP request to the appropriate server. If all goes well,
the server responds by sending a file back to the browser, who shows
it to the user in one way or another.

When, as in the example, the retrieved file is an _HTML_ document, it
will be displayed as a web-page. We briefly discussed HTML in \\cfp,
where we saw that it could refer to image files. In \\cmodularity, we
found that HTML pages can also contain |<script>| tags to load files
of JavaScript code. When showing an HTML document, a browser will
fetch all these extra files from their servers, so it can add them to
the document.

---

Although a URL is supposed to point at a file, it is possible for a
web-server to do something more complicated than just looking up a
file and sending it to the client. -- It can process this file in some
way first, or maybe there is no file at all, but only a program that,
given an URL, has some way of generating the relevant document for it.

Programs that transform or generate documents on a server are a
popular way to make web-pages less static. When a file is just a file,
it is always the same, but when there is a program that builds it
every time it is requested, it could be made to look different for
each person, based on things like whether this person has logged in or
specified certain preferences. This can also make managing the content
of web-pages much easier -- instead of adding a new HTML file whenever
something new is put on a website, a new document is added to some
central storage, and the program knows where to find it and how to
show it to clients.

This kind of web programming is called _server-side programming_. It
affects the document before it is sent to the user. In some cases, it
is also practical to have a program that runs *after* the page has
been sent, when the user is looking at it. This is called _client-side
programming_, because the program runs on the client computer.
Client-side web programming is what JavaScript was invented for.

---

Running programs client-side has an inherent problem. You can never
really know in advance what kinds of programs the page you are
visiting is going to run. If it can send information from your
computer to others, damage something, or infiltrate your system,
surfing the web would be a rather hazardous activity.

To solve this dilemma, browsers severely limit the things a JavaScript
program may do. It is not allowed to look at your files, or to modify
anything not related to the web-page it came with. Isolating a
programming environment like this is called _sand-boxing_. Allowing
the programs enough room to be useful, and at the same time
restricting them enough to prevent them from doing harm is not an easy
thing to do. Every few months, some JavaScript programmer comes up
with a new way to circumvent the limitations and do something harmful
or privacy-invading. The people responsible for the browsers respond
by modifying their programs to make this trick impossible, and all is
well again -- until the next problem is discovered.

---

One of the first JavaScript tricks that became widely used is the
@_|window.open|__|open|_ method of the |window| object. It takes a URL
as an argument, and will open a new window showing that URL.

> var perry = window.open("http://www.pbfcomics.com");

Unless you turned off pop-up blocking in \\cfp, there's a chance that
this new window is blocked. There is a good reason pop-up blockers
exist. Web-programmers, especially those trying to get people to pay
attention to advertisements, have abused the poor |window.open| method
so much that by now, most users hate it with a passion. It has its
place though, and in this book we will be using it to show some
example pages. As a general rule, your scripts should not open any new
windows unless the user asked for them.

Note that, because |open| (just like |setTimeout| and company) is a
method on the |window| object, the |window.| part can be left off.
When a function is called 'normally', it is called as a method on the
top-level object, which is what |window| is. Personally, I think
|open| sounds a bit generic, so I'll usually type |window.open|, which
makes it clear that it is a window that is being opened.

The value returned by |window.open| is a new window. This is the
global object for the script running in that window, and contains all
the standard things like the |Object| constructor and the |Math|
object. But if you try to look at them, most browsers will (probably)
not let you...

!> show(perry.Math);

This is part of the sand-boxing that I mentioned earlier. Pages opened
by your browser might show information that is meant only for you, for
example on sites where you logged in, and thus it would be bad if any
random script could go and read them. The exception to this rule is
pages opened on the same domain: When a script running on a page from
|eloquentjavascript.net| opens another page on that same domain, it
can do everything it wants to this page.

An opened window can be closed with its @_|window.close|__|close|_
method. If you didn't already close it yourself...

> perry.close();

Other kinds of sub-documents, such as frames
(documents-within-a-document), are also windows from the perspective
of a JavaScript program, and have their own JavaScript environment. In
fact, the environment that you have access to in the console belongs
to a small invisible frame hidden somewhere on this page -- this way,
it is slightly harder for you to accidentally mess up the whole page.

---

Every window object has a _|document|_ property, which contains an
object representing the document shown in that window. This object
contains, for example, a property @_|document.location|_|location|,
with information about the URL of the document.

> show(document.location.href);

Setting |document.location.href| to a new URL can be used to make the
browser load another document. Another application of the |document|
object is its @_|document.write|_|write| method. This method, when
given a string argument, writes some HTML to the document. When it is
used on a fully loaded document, it will replace the whole document by
the given HTML, which is usually not what you want. The idea is to
have a script call it while the document is being loaded, in which
case the written HTML will be inserted into the document at the place
of the |script| tag that triggered it. This is a simple way to add
some dynamic elements to a page. For example, here is a trivially
simple document showing the current time.

> print(timeWriter);
> var time = viewHTML(timeWriter);

> time.close();

Often, the techniques shown in \\cdom provide a cleaner and more
versatile way to modify the document, but occasionally,
|document.write| is the nicest, simplest way to do something.

---

Another popular application of JavaScript in web pages centers around
_form_s. In case you are not quite sure what the role of 'forms' is,
let me give a quick summary.

A basic HTTP request is a simple request for a file. When this file is
not really a passive file, but a server-side program, it can become
useful to include information other than a filename in the request.
For this purpose, HTTP requests are allowed to contain additional
'parameters'. Here is an example:

] http://www.google.com/search?q=aztec%20empire

After the filename (|/search|), the URL continues with a question
mark, after which the parameters follow. This request has one
parameter, called |q| (for 'query', presumably), whose value is |aztec
empire|. The |%20| part corresponds to a space. There are a number of
characters that can not occur in these values, such as spaces,
ampersands, or question marks. These are 'escaped' by replacing them
with a |%| followed by their numerical value##, which serves the same
purpose as the backslashes used in strings and regular expressions,
but is even more unreadable.

## The value a character gets is decided by the ASCII standard, which
assigns the numbers 0 to 127 to a set of letters and symbols used by
the Latin alphabet. This standard is a precursor of the Unicode
standard mentioned in \\cbasics.

JavaScript provides functions _|encodeURIComponent|_ and
_|decodeURIComponent|_ to add these codes to strings and remove them
again.

> var encoded = encodeURIComponent("aztec empire");
> show(encoded);
> show(decodeURIComponent(encoded));

When a request contains more than one parameter, they are separated by
ampersands, as in...

] http://www.google.com/search?q=aztec%20empire&lang=nl

---

A form, basically, is a way to make it easy for browser-users to
create such parameterised URLs. It contains a number of fields, such
as input boxes for text, checkboxes that can be 'checked' and
'unchecked', or thingies that allow you to choose from a given set of
values. It also usually contains a 'submit' button and, invisible to
the user, an 'action' URL to which it should be sent. When the submit
button is clicked, or enter is pressed, the information that was
entered in the fields is added to this action URL as parameters, and
the browser will request this URL.

Here is the HTML for a simple form:

] <form name="userinfo" method="get" action="info.html">
]   <p>Please give us your information, so that we can send
]   you spam.</p>
]   <p>Name: <input type="text" name="name"/></p>
]   <p>E-Mail: <input type="text" name="email"/></p>
]   <p>Sex: <select name="sex">
]             <option>Male</option>
]             <option>Female</option>
]             <option>Other</option>
]           </select></p>
]   <p><input name="send" type="submit" value="Send!"/></p>
] </form>

The name of the form can be used to access it with JavaScript, as we
shall see in a moment. The names of the fields determine the names of
the HTTP parameters that are used to store their values. Sending this
form might produce a URL like this:

] http://planetspam.com/info.html?name=Ted&email=ted@zork.com&sex=Male

There are quite a few other tags and properties that can be used in
forms, but in this book we will stick with simple ones, so that we can
concentrate on JavaScript.

---

The |method="get"| property of the example form shown above indicates
that this form should encode the values it is given as URL parameters,
as shown before. There is an alternative method for sending
parameters, which is called |post|. An HTTP request using the |post|
method contains, in addition to a URL, a block of data. A form using
the |post| method puts the values of its parameters in this data block
instead of in the URL.

When sending big chunks of data, the |get| method will result in URLs
that are a mile wide, so |post| is usually more convenient. But the
difference between the two methods is not just a question of
convenience. Traditionally, |get| requests are used for requests that
just ask the server for some document, while |post| requests are used
to take an action that changes something on the server. For example,
getting a list of recent messages on an Internet forum would be a
|get| request, while adding a new message would be a |post| request.
There is a good reason why most pages follow this distinction --
programs that automatically explore the web, such as those used by
search engines, will generally only make |get| requests. If changes to
a site can be made by |get| requests, these well-meaning 'crawlers'
could do all kinds of damage.

---

When the browser is displaying a page containing a form, JavaScript
programs can inspect and modify the values that are entered in the
form's fields. This opens up possibilities for all kinds of tricks,
such as checking values before they are sent to the server, or
automatically filling in certain fields.

The form shown above can be found in the file |example_getinfo.html|.
Open it.

> var form = window.open("example_getinfo.html");

When a URL does not contain a server name, is called a _relative URL_.
Relative URLs are interpreted by the browser to refer to files on the
same server as the current document. Unless they start with a slash,
the path (or directory) of the current document is also retained, and
the given path is appended to it.

We will be adding a validity check to the form, so that it only
submits if the name field is not left empty and the e-mail field
contains something that looks like a valid e-mail address. Because we
no longer want the form to submit immediately when the 'Send!' button
is pressed, its |type| property has been changed from |"submit"| to
|"button"|, which turns it into a regular button with no effect. --
\\Cevent will show a *much* better way of doing this, but for now, we
use the naive method.

---

@_|attach|_To be able to work with the newly opened window (if you
closed it, re-open it first), we 'attach' the console to it, like
this:

> attach(form);

After doing this, the code run from the console will be run in the
given window. To verify that we are indeed working with the correct
window, we can look at the document's |location| and |title|
properties.

> print(document.location.href);
> print(document.title);

Because we have entered a new environment, previously defined
variables, such as |form|, are no longer present.

!> show(form);

@_|detach|_To get back to our starting environment, we can use the
|detach| function (without arguments). But first, we have to add that
validation system to the form.

---

Every HTML tag shown in a document has a JavaScript object associated
with it. These objects can be used to inspect and manipulate almost
every aspect of the document. In this chapter, we will work with the
objects for forms and form fields, \\cdom talks about these objects in
more detail.

@_|document.forms|_The |document| object has a property named |forms|,
which contains links to all the forms in the document, by name. Our
form has a property |name="userinfo"|, so it can be found under the
property |userinfo|.

> var userForm = document.forms.userinfo;
> print(userForm.method);
> print(userForm.action);

In this case, the properties |method| and |action| that were given to
the HTML |form| tag are also present as properties of the JavaScript
object. This is often the case, but not always: Some HTML properties
are spelled differently in JavaScript, others are not present at all.
\\Cdom will show a way to get at all properties.

The object for the |form| tag has a property |elements|, which refers
to an object containing the fields of the form, by name.

> var nameField = userForm.elements.name;
> nameField.value = "Eugène";

Text-input objects have a |value| property, which can be used to read
and change their content. If you look at the form window after running
the above code, you'll see that the name has been filled in.

***

Being able to read the values of the form fields makes it possible to
write a function |validInfo|, which takes a form object as its
argument and returns a boolean value: |true| when the |name| field is
not empty and the |email| field contains something that looks like an
e-mail address, |false| otherwise. Write this function.

///

> function validInfo(form) {
>   return form.elements.name.value != "" &&
>     /^.+@.+\.\w{2,3}$/.test(form.elements.email.value);
> }
>
> show(validInfo(document.forms.userinfo));

You did think to use a regular expression for the e-mail check, didn't
you?

---

All we have to do now is determine what happens when people click the
'Send!' button. At the moment, it does not do anything at all. This
can be remedied by setting its |onclick| property.

> userForm.elements.send.onclick = function() {
>   alert("Click.");
> };

Just like the actions given to |setInterval| and |setTimeout| (\\coo),
the value stored in an _|onclick|_ (or similar) property can be either
a function or a string of JavaScript code. In this case, we give it a
function that opens an alert window. Try clicking it.

***

Finish the form validator by giving the button's |onclick| property a
new value -- a function that checks the form, submits when it is
valid, or pops up a warning message when it is not. It will be useful
to know that form objects have a _|submit|_ method that takes no
parameters and submits the form.

///

> userForm.elements.send.onclick = function() {
>   if (validInfo(userForm))
>     userForm.submit();
>   else
>     alert("Give us a name and a valid e-mail address!");
> };

---

Another trick related to form inputs, as well as other things that can
be 'selected', such as buttons and links, is the _|focus|_ method.
When you know for sure that a user will want to start typing in a
certain text field as soon as he enters the page, you can have your
script start by placing the cursor in it, so he won't have to click it
or select it in some other way.

> userForm.elements.name.focus();

Because the form sits in another window, it may not be obvious that
something was selected, depending on the browser you are using. Some
pages also automatically make the cursor jump to the next field when
it looks like you finished filling in one field -- for example, when
you type a zip code. This should not be overdone -- it makes the page
behave in a way the user does not expect. If he is used to pressing
tab to move the cursor manually, or mistyped the last character and
wants to remove it, such magic cursor-jumping is very annoying.

---

> detach();

Test the validator. When you enter valid information and click the
button, the form should submit. If the console was still attached to
it, this will cause it to detach itself, because the page reloads and
the JavaScript environment is replaced by a new one.

If you haven't closed the form window yet, this will close it.

> form.close();

---

The above may look easy, but let me assure you, client-side
web programming is no walk in the park. It can, at times, be a very
painful ordeal. Why? Because programs that are supposed to run on the
client computer generally have to work for all popular browsers. Each
of these browsers tends to work slightly different. To make things
worse, each of them contains a unique set of problems. Do not assume
that a program is bug-free just because it was made by a multi-billion
dollar company. So it is up to us, the web-programmer, to rigorously
test our programs, figure out what goes wrong, and find ways to work
around it.

Some of you might think "I will just report any problems/_bug_s I find
to the browser manufacturers, and they will certainly solve fix them
immediately". These people are in for a major disappointment. The most
recent version of Internet Explorer, the browser that is still used by
some seventy percent of web-surfers (and that every web-developer
likes to rag on) still contains bugs that have been known for over
five years. Serious bugs, too.

But do not let that discourage you. With the right kind of
obsessive-compulsive mindset, such problems provide wonderful
challenges. And for those of us who do not like wasting our time,
being careful and avoiding the obscure corners of the browser's
functionality will generally prevent you from running into too much
trouble.

---

Bugs aside, the by-design differences in interface between browsers
still make for an interesting challenge. The current situation looks
something like this: On the one hand, there are all the 'small'
browsers: Firefox, Safari, and Opera are the most important ones, but
there are more. These browsers all make a reasonable effort to adhere
to a set of standards that have been developed, or are being
developed, by the W3C, an organisation that tries to make the Web a
less confusing place by defining standard interfaces for things like
this. On the other hand, there is Internet Explorer, Microsoft's
browser, which rose to dominance in a time when many of these
standards did not really exist yet, and hasn't made much effort to
adjust itself to what other people are doing.

In some areas, such as the way the content of an HTML document can be
approached from JavaScript (\\cdom), the standards are based on the
method that Internet Explorer invented, and things work more or less
the same on all browsers. In other areas, such as the way events
(mouse-clicks, key-presses, and such) are handled (\\cevent), Internet
Explorer works radically different from other browsers.

For a long time, owing partially to the cluelessness of the average
JavaScript developer, and partially to the fact that browser
incompatibilities were much worse when browsers like Internet Explorer
version 4 or 5 and old versions of Netscape were still common, the
usual way to deal with such differences was to detect which browser
the user was running, and litter code with alternate solutions for
each browser -- if this is Internet Explorer, do this, if this is
Netscape, do that, and if this is other browser that we didn't think
of, just hope for the best. You can imagine how hideous, confusing,
and long such programs were.

Many sites would also just refuse to load when opened in a browser
that was 'not supported'. This caused a few of the minor browsers to
swallow their pride and pretend they were Internet Explorer, just so
they would be allowed to load such pages. The properties of the
_|navigator|_ object contain information about the browser that a page
was loaded in, but because of such lying this information is not
particularly reliable. See what yours says##:

## Some browsers seem to hide the properties of the |navigator|
object, in which case this will print nothing.

> forEachIn(navigator, function(name, value) {
>   print(name, " = ", value);
> });

A better approach is to try and 'isolate' our programs from
differences in browsers. If you need, for example, to find out more
about an event, such as the clicks we handled by setting the |onclick|
property of our send button, you have to look at the top-level object
called |event| on Internet Explorer, but you have to use the first
argument passed to the event-handling function on other browsers. To
handle this, and a number of other differences related to events, one
can write a helper function for attaching events to things, which
takes care of all the plumbing and allows the event-handling functions
themselves to be the same for all browsers. In \\cevent we will write
such a function.

(Note: The browser quirks mentioned in the following chapters refer to
the state of affairs in early 2007, and might no longer be accurate on
some points.)

---

These chapters will only give a somewhat superficial introduction to
the subject of browser interfaces. They are not the main subject of
this book, and they are complex enough to fill a thick book on their
own. When you understand the basics of these interfaces (and
understand something about HTML), it is not too hard to look for
specific information online. The interface documentation for the
[Firefox | https://developer.mozilla.org/en/Gecko_DOM_Reference]
and [Internet Explorer |
http://msdn2.microsoft.com/library/yek4tbz0.aspx] browsers are a good
place to start.

The information in the next chapters will not deal with the quirks of
'previous-generation' browsers. They deal with Internet Explorer 6,
Firefox 1.5, Opera 9, Safari 3, or any more recent versions of the
same browsers. Most of it will also probably be relevant to modern but
obscure browsers such as Konqueror, but this has not been extensively
checked. Fortunately, these previous-generation browsers have pretty
much died out, and are hardly used anymore.

There is, however, a group of web-users that will still use a browser
without JavaScript. A large part of this group consists of people
using a regular graphical browser, but with JavaScript disabled for
security reasons. Then there are people using textual browsers, or
browsers for blind people. When working on a 'serious' site, it is
often a good idea to start with a plain HTML system that works, and
then add non-essential tricks and conveniences with JavaScript.

===============================
The Document-Object Model / dom
===============================

In \\cweb we saw JavaScript objects referring to |form| and |input|
tags from the HTML document. Such objects are part of a structure
called the _Document-Object Model_ (_DOM_). Every tag of the document
is represented in this model, and can be looked up and interacted
with.

HTML documents have what is called a hierarchical structure. Each
element (or tag) except the top |<html>| tag is contained in another
element, its parent. This element can in turn contain child elements.
You can visualise this as a kind of family tree:

[[html.png]]

The document-object model is based on such a view of the document.
Note that the tree contains two types of elements: Nodes, which are
shown as blue boxes, and pieces of simple text. The pieces of text, as
we will see, work somewhat different than the other elements. For one
thing, they never have children.

Open the file |example_alchemy.html|, which contains the document
shown in the picture, and attach the console to it.

> attach(window.open("example_alchemy.html"));

@_|document.documentElement|_The object for the root of the document
tree, the |html| node, can be reached through the |documentElement|
property of the |document| object. Most of the time, we need access to
the |body| part of the document instead, which is at
_|document.body|_.

---

The links between these nodes are available as properties of the node
objects. Every DOM object has a _|parentNode|_ property, which refers
to the object in which it is contained, if any. These parents also
have links pointing back to their children, but because there can be
more than one child, these are stored in a pseudo-array called
_|childNodes|_.

> show(document.body);
> show(document.body.parentNode);
> show(document.body.childNodes.length);

For convenience, there are also links called _|firstChild|_ and
_|lastChild|_, pointing at the first and last child inside a node, or
|null| when there are no children.

> show(document.documentElement.firstChild);
> show(document.documentElement.lastChild);

Finally, there are properties called _|nextSibling|_ and
_|previousSibling|_, which point at the nodes sitting 'next' to a node
-- nodes that are children of the same parent, coming before or after
the current node. Again, when there is no such sibling, the value of
these properties is |null|.

> show(document.body.previousSibling);
> show(document.body.nextSibling);

---

To find out whether a node represents a simple piece of text or an
actual HTML node, we can look at its _|nodeType|_ property. This
contains a number, |1| for regular nodes and |3| for text nodes. There
are actually other kinds of objects with a |nodeType|, such as the
|document| object, which has |9|, but the most common use for this
property is distinguishing between text nodes and other nodes.

> function isTextNode(node) {
>   return node.nodeType == 3;
> }
>
> show(isTextNode(document.body));
> show(isTextNode(document.body.firstChild.firstChild));

Regular nodes have a property called _|nodeName|_, indicating the type
of HTML tag that they represent. Text nodes, on the other hand, have a
_|nodeValue|_, containing their text content.

> show(document.body.firstChild.nodeName);
> show(document.body.firstChild.firstChild.nodeValue);

The |nodeName|s are always capitalised, which is something you need to
take into account if you ever want to compare them to something.

> function isImage(node) {
>   return !isTextNode(node) && node.nodeName == "IMG";
> }
>
> show(isImage(document.body.lastChild));

***

Write a function |asHTML| which, when given a DOM node, produces a
string representing the HTML text for that node and its children. You
may ignore attributes, just show nodes as |<nodename>|. The
|escapeHTML| function from \\cregexp is available to properly escape
the content of text nodes.

Hint: Recursion!

///

> function asHTML(node) {
>   if (isTextNode(node))
>     return escapeHTML(node.nodeValue);
>   else if (node.childNodes.length == 0)
>     return "<" + node.nodeName + "/>";
>   else
>     return "<" + node.nodeName + ">" +
>            map(asHTML, node.childNodes).join("") +
>            "</" + node.nodeName + ">";
> }
>
> print(asHTML(document.body));

---

Nodes, in fact, already have something similar to |asHTML|. Their
_|innerHTML|_ property can be used to retrieve the HTML text *inside*
of the node, without the tags for the node itself. Some browsers also
support |outerHTML|, which does include the node itself, but not all
of them.

> print(document.body.innerHTML);

Some of these properties can also be modified. Setting the |innerHTML|
of a node or the |nodeValue| of a text-node will change its content.
Note that, in the first case, the given string is interpreted as HTML,
while in the second case it is interpreted as plain text.

> document.body.firstChild.firstChild.nodeValue =
>   "Chapter 1: The deep significance of the bottle";

Or ...

> document.body.firstChild.innerHTML =
>   "Did you know the 'blink' tag yet? <blink>Joy!</blink>";

---

We have been accessing nodes by going through a series of |firstChild|
and |lastChild| properties. This can work, but it is verbose and easy
to break -- if we add another node at the start of our document,
|document.body.firstChild| no longer refers to the |h1| element, and
code which assumes it does will go wrong. On top of that, some
browsers will add text-nodes for things like spaces and newlines
between tags, while others do not, so that the exact layout of the DOM
tree can vary.

An alternative to this is to give elements that you need to have
access to an |id| attribute. In the example page, the picture has an
id |"picture"|, and we can use this to look it up.

> var picture = document.getElementById("picture");
> show(picture.src);
> picture.src = "img/ostrich.png";

@_|document.getElementById|_When typing |getElementById|, note that
the last letter is lowercase. Also, when typing it a lot, beware of
carpal-tunnel syndrome. Because |document.getElementById| is a
ridiculously long name for a very common operation, it has become a
convention among JavaScript programmers to aggressively abbreviate it
to _|$|_. |$|, as you might remember, is considered a letter by
JavaScript, and is thus a valid variable name.

> function $(id) {
>   return document.getElementById(id);
> }
> show($("picture"));

DOM nodes also have a method _|getElementsByTagName|_ (another nice,
short name), which, when given a tag name, returns an array of all
nodes of that type contained in the node it was called on.

> show(document.body.getElementsByTagName("BLINK")[0]);

---

Another thing we can do with these DOM nodes is creating new ones
ourselves. This makes it possible to add pieces to a document at will,
which can be used to create some interesting effects. Unfortunately,
the interface for doing this is extremely clumsy. But that can be
remedied with some helper functions.

@_|document.createElement|_@_|document.createTextNode|_The |document|
object has |createElement| and |createTextNode| methods. The first is
used to create regular nodes, the second, as the name suggests,
creates text nodes.

> var secondHeader = document.createElement("H1");
> var secondTitle = document.createTextNode("Chapter 2: Deep magic");

Next, we'll want to put the title name into the |h1| element, and then
add the element to the document. The simplest way to do this is the
_|appendChild|_ method, which can be called on every (non-text) node.

> secondHeader.appendChild(secondTitle);
> document.body.appendChild(secondHeader);

Often, you will also want to give these new nodes some attributes. For
example, an |img| (image) tag is rather useless without an |src|
property telling the browser which image it should show. Most
attributes can be approached directly as properties of the DOM nodes,
but there are also methods _|setAttribute|_ and _|getAttribute|_,
which are used to access attributes in a more general way:

> var newImage = document.createElement("IMG");
> newImage.setAttribute("src", "img/Hiva Oa.png");
> document.body.appendChild(newImage);
> show(newImage.getAttribute("src"));

---

But, when we want to build more than a few simple nodes, it gets very
tiresome to create every single node with a call to
|document.createElement| or |document.createTextNode|, and then add
its attributes and child nodes one by one. Fortunately, it is not hard
to write a function to do most of the work for us. Before we do so,
there is one little detail to take care of -- the |setAttribute|
method, while working fine on most browsers, does not always work on
Internet Explorer. The names of a few HTML attributes already have a
special meaning in JavaScript, and thus the corresponding object
properties got an adjusted name. Specifically, the |class| attribute
becomes _|className|_, |for| becomes |htmlFor|, and |checked| is
renamed to |defaultChecked|. On Internet Explorer, |setAttribute| and
|getAttribute| also work with these adjusted names, instead of the
original HTML names, which can be confusing. On top of that the
_|style|_ attribute, which, along with |class|, will be discussed
later in this chapter, can not be set with |setAttribute| on that
browser.

A workaround would look something like this:

> function setNodeAttribute(node, attribute, value) {
>   if (attribute == "class")
>     node.className = value;
>   else if (attribute == "checked")
>     node.defaultChecked = value;
>   else if (attribute == "for")
>     node.htmlFor = value;
>   else if (attribute == "style")
>     node.style.cssText = value;
>   else
>     node.setAttribute(attribute, value);
> }

For every case where Internet Explorer deviates from other browsers,
it does something that works in all cases. Don't worry about the
details -- this is the kind of ugly trick that we'd rather not need,
but which non-conforming browsers force us to write. Having this, it
is possible to write a simple function for building DOM elements.

> function dom(name, attributes) {
>   var node = document.createElement(name);
>   if (attributes) {
>     forEachIn(attributes, function(name, value) {
>       setNodeAttribute(node, name, value);
>     });
>   }
>   for (var i = 2; i < arguments.length; i++) {
>     var child = arguments[i];
>     if (typeof child == "string")
>       child = document.createTextNode(child);
>     node.appendChild(child);
>   }
>   return node;
> }
>
> var newParagraph = 
>   dom("P", null, "A paragraph with a ",
>       dom("A", {href: "http://en.wikipedia.org/wiki/Alchemy"},
>           "link"),
>       " inside of it.");
> document.body.appendChild(newParagraph);

The _|dom|_ function creates a DOM node. Its first argument gives the
tag name of the node, its second argument is an object containing the
attributes of the node, or |null| when no attributes are needed. After
that, any amount of arguments may follow, and these are added to the
node as child nodes. When strings appear here, they are first put into
a text node.

---

|appendChild| is not the only way nodes can be inserted into another
node. When the new node should not appear at the end of its parent,
the _|insertBefore|_ method can be used to place it in front of
another child node. It takes the new node as a first argument, and the
existing child as second argument.

> var link = newParagraph.childNodes[1];
> newParagraph.insertBefore(dom("STRONG", null, "great "), link);

If a node that already has a |parentNode| is placed somewhere, it is
automatically removed from its current position -- nodes can not exist
in the document in more than one place.

When a node must be replaced by another one, use the _|replaceChild|_
method, which again takes the new node as first argument and the
existing one as second argument.

> newParagraph.replaceChild(document.createTextNode("lousy "),
>                           newParagraph.childNodes[1]);

And, finally, there is _|removeChild|_ to remove a child node. Note
that this is called on the *parent* of the node to be removed, giving
the child as argument.

> newParagraph.removeChild(newParagraph.childNodes[1]);

***

Write the convenient function _|removeElement|_ which removes the DOM
node it is given as an argument from its parent node.

///

> function removeElement(node) {
>   if (node.parentNode)
>     node.parentNode.removeChild(node);
> }
>
> removeElement(newParagraph);

---

When creating new nodes and moving nodes around it is necessary to be
aware of the following rule: Nodes are not allowed to be inserted into
another document from the one in which they were created. This means
that if you have extra frames or windows open, you can not take a
piece of the document from one and move it to another, and nodes
created with methods on one |document| object must stay in that
document. Some browsers, notably Firefox, do not enforce this
restriction, and thus a program which violates it will work fine in
those browsers but break on others.

---

An example of something useful that can be done with this |dom|
function is a program that takes JavaScript objects and summarises
them in a _table_. Tables, in HTML, are created with a set of tags
starting with |t|s, something like this:

] <table>
]   <tbody>
]     <tr> <th>Tree </th> <th>Flowers</th> </tr>
]     <tr> <td>Apple</td> <td>White  </td> </tr>
]     <tr> <td>Coral</td> <td>Red    </td> </tr>
]     <tr> <td>Pine </td> <td>None   </td> </tr>
]   </tbody>
] </table>

Each |tr| element is a row of the table. |th| and |td| elements are
the cells of the table, |td|s are normal data cells, |th| cells are
'header' cells, which will be displayed in a slightly more prominent
way. The |tbody| (table body) tag does not have to be included when a
table is written as HTML, but when building a table from DOM nodes it
should be added, because Internet Explorer refuses to display tables
created without a |tbody|.

***

The function |makeTable| takes two arrays as arguments. The first
contains the JavaScript objects that it should summarise, and the
second contains strings, which name the columns of the table and the
properties of the objects that should be shown in these columns. For
example, the following will produce the table above:

!> makeTable([{Tree: "Apple", Flowers: "White"},
!>            {Tree: "Coral", Flowers: "Red"},
!>            {Tree: "Pine",  Flowers: "None"}],
!>           ["Tree", "Flowers"]);

Write this function.

///

> function makeTable(data, columns) {
>   var headRow = dom("TR");
>   forEach(columns, function(name) {
>     headRow.appendChild(dom("TH", null, name));
>   });
>
>   var body = dom("TBODY", null, headRow);
>   forEach(data, function(object) {
>     var row = dom("TR");
>     forEach(columns, function(name) {
>       row.appendChild(dom("TD", null, String(object[name])));
>     });
>     body.appendChild(row);
>   });
>
>   return dom("TABLE", null, body);
> }
>
> var table = makeTable(document.body.childNodes,
>                       ["nodeType", "tagName"]);
> document.body.appendChild(table);

Do not forget to convert the values from the objects to strings before
adding them to the table -- our |dom| function only understands
strings and DOM nodes.

---

Closely tied to HTML and the document-object model is the topic of
_style-sheet_s. It is a big topic, and I will not discuss it entirely,
but some understanding of style-sheets is necessary for a lot of
interesting JavaScript techniques, so we will go over the basics.

In old-fashioned HTML, the only way to change the appearance of
elements in a document was to give them extra attributes or to wrap
them in extra tags, such as |center| to center them horizontally, or
|font| to change the font style or colour. Most of the time, this meant
that if you wanted the paragraphs or the tables in your document to
look a certain way, you had to add a bunch of attributes and tags to
*every single one of them*. This quickly adds a lot of noise to such
documents, and makes them very painful to write or change by hand.

Of course, people being the inventive monkeys they are, someone came
up with a solution. Style-sheets are a way to make statements like 'in
this document, all paragraphs use the Comic Sans font, and are purple,
and all tables have a thick green border'. You specify them once, at
the top of the document or in a separate file, and they affect the
whole document. Here, for example, is a style-sheet to make headers 22
points big and centered, and make paragraphs use the font and colour
mentioned earlier, when they are of the 'ugly' class.

] <style type="text/css">
]   h1 {
]     font-size: 22pt;
]     text-align: center;
]   }
]
]   p.ugly {
]     font-family: Comic Sans MS;
]     color: purple;
]   }
] </style>

Classes are a concept related to styles. If you have different kinds
of paragraphs, ugly ones and nice ones for example, setting the style
for all |p| elements is not what you want, so _class_es can be used to
distinguish between them. The above style will only be applied to
paragraphs like this:

] <p class="ugly">Mirror, mirror...</p>

And this is also the meaning of the _|className|_ property which was
briefly mentioned for the |setNodeAttribute| function. The _|style|_
attribute can be used to add a piece of style directly to an element.
For example, this gives our image a solid border 4 pixels ('px') wide.

> setNodeAttribute($("picture"), "style",
>                  "border-width: 4px; border-style: solid;");

---

There is much more to styles: Some styles are inherited by child nodes
from parent nodes, and interfere with each other in complex and
interesting ways, but for the purpose of DOM programming, the most
important thing to know is that each DOM node has a |style| property,
which can be used to manipulate the style of that node, and that there
are a few kinds of styles that can be used to make nodes do
extraordinary things.

This |style| property refers to an object, which has properties for
all the possible elements of the style. We can, for example, make the
picture's border green.

> $("picture").style.borderColor = "green";
> show($("picture").style.borderColor);

Note that in style-sheets, the words are separated by hyphens, as in
|border-color|, while in JavaScript, capital letters are used to mark
the different words, as in |borderColor|.

A very practical kind of style is |display: none|. This can be used to
temporarily hide a node: When _|style.display|_ is |"none"|, the element
does not appear at all to the viewer of the document, even though it
does exist. Later, |display| can be set to the empty string, and the
element will re-appear.

> $("picture").style.display = "none";

And, to get our picture back:

> $("picture").style.display = "";

---

Another set of style types that can be abused in interesting ways are
those related to positioning. In a simple HTML document, the browser
takes care of determining the screen positions of all the elements --
each element is put next to or below the elements that come before it,
and nodes (generally) do not overlap.

@_|style.position|_When its |position| style is set to |"absolute"|, a
node is taken out of the normal document 'flow'. It no longer takes up
room in the document, but sort of floats above it. The |left| and
|top| styles can then be used to influence its position. This can be
used for various purposes, from making a node obnoxiously follow the
mouse cursor to making 'windows' open on top of the rest of the
document.

> $("picture").style.position = "absolute";
> var angle = 0;
> var spin = setInterval(function() {
>   angle += 0.1;
>   $("picture").style.left = (100 + 100 * Math.cos(angle)) + "px";
>   $("picture").style.top = (100 + 100 * Math.sin(angle)) + "px";
> }, 100);

If you aren't familiar with goniometry, just believe me when I tell
you that the cosine and sine stuff is used to build coordinates lying
on the outline of a circle. Ten times per second, the angle at which
we place the picture is changed, and new coordinates are computed. It
is a common error, when setting styles like this, to forget to append
|"px"| to your value. In most cases, setting a style to a number
without a unit does not work, so you must add |"px"| for pixels, |"%"|
for percent, |"em"| for 'ems' (the width of an |M| character), or
|"pt"| for points.

(Now put the image to rest again...)

> clearInterval(spin);

The place that is treated as 0,0 for the purpose of these positions
depends on the place of the node in the document. When it is placed
inside another node that has |position: absolute| or |position:
relative|, the top left of this node is used. Otherwise, you get the
top left corner of the document.

---

@_|style.width|_@_|style.height|_One last aspect of DOM nodes that is
fun to play with is their size. There are style types called |width|
and |height|, which can be used to set the absolute size of an
element.

> $("picture").style.width = "400px";
> $("picture").style.height = "200px";

But, when you need to accurately set the size of an element, there is
an tricky problem to take into account. Some browsers, in some
circumstances, take these sizes to mean the outside size of the
object, including any border and internal padding. Other browsers, in
other circumstances, use the size of the space inside of the object
instead, and do not count the width of borders and padding. Thus, if
you set the size of an object that has a border or a padding, it will
not always appear the same size.

Fortunately, you can inspect the inner and outer size of a node,
which, when you really need to accurately size something, can be used
to compensate for browser behaviour. The _|offsetWidth|_ and
_|offsetHeight|_ properties give you the outer size of your element
(the space it takes up in the document), while the _|clientWidth|_ and
_|clientHeight|_ properties give the space inside of it, if any.

> print("Outer size: ", $("picture").offsetWidth,
>       " by ", $("picture").offsetHeight, " pixels.");
> print("Inner size: ", $("picture").clientWidth,
>       " by ", $("picture").clientHeight, " pixels.");

---

If you've followed through with all the examples in this chapter, and
maybe did a few extra things by yourself, you will have completely
mutilated the poor little document that we started with. Now let me
moralise for a moment and tell you that you do not want to do this to
real pages. The temptation to add all kinds of moving bling-bling will
at times be strong. Resist it, or your pages shall surely become
unreadable or even, if you go far enough, induce the occasional
seizure.

======================
Browser Events / event
======================

To add interesting functionality to a web-page, just being able to
inspect or modify the document is generally not enough. We also need
to be able to detect what the user is doing, and respond to it. For
this, we will use a thing called _event handler_s. Pressed keys are
events, mouse clicks are events, even mouse motion can be seen as a
series of events. In \\cweb, we added an |onclick| property to a
button, in order to do something when it was pressed. This is a simple
event handler.

The way browser events work is, fundamentally, very simple. It is
possible to register handlers for specific event types and specific
DOM nodes. Whenever an _event_ occurs, the handler for that event, if
any, is called. For some events, such as key presses, knowing just
that the event occurred is not good enough, you also want to know
which key was pressed. To store such information, every event creates
an _event object_, which the handler can look at.

It is important to realise that, even though events can fire at any
time, no two handlers ever run at the same moment. If other JavaScript
code is still running, the browser waits until it finishes before it
calls the next handler. This also holds for code that is triggered in
other ways, such as with |setTimeout|. In programmer jargon, browser
JavaScript is _single-threaded_, there are never two '_thread_s'
running at the same time. This is, in most cases, a good thing. It is
very easy to get strange results when multiple things happen at the
same time.

An event, when not handled, can 'bubble' through the DOM tree. What
this means is that if you click on, for example, a link in a
paragraph, any handlers associated with the link are called first. If
there are no such handlers, or these handlers do not indicate that
they have finished handling the event, the handlers for the paragraph,
which is the parent of the link, are tried. After that, the handlers
for |document.body| get a turn. Finally, if no JavaScript handlers
have taken care of the event, the browser handles it. When clicking a
link, this means that the link will be followed.

---

So, as you see, events are easy. The only hard thing about them is
that browsers, while all supporting more or less the same
functionality, support this functionality through different
interfaces. As usual, the most incompatible browser is Internet
Explorer, which ignores the standard that most other browsers follow.
After that, there is Opera, which does not properly support some
useful events, such as the |onunload| event which fires when leaving a
page, and sometimes gives confusing information about keyboard events.

There are four event-related actions one might want to take.

 * Registering an event handler.
 * Getting the event object.
 * Extracting information from this object.
 * Signalling that an event has been handled.

None of them work the same across all major browsers.

---

As a practice field for our event-handling, we open a document with a
button and a text field. Keep this window open (and attached) for the
rest of the chapter.

> attach(window.open("example_events.html"));

---

The first action, registering a handler, can be done by setting an
element's |onclick| (or |onkeypress|, and so on) property. This does
in fact work across browsers, but it has an important drawback -- you
can only attach one handler to an element. Most of the time, one is
enough, but there are cases, especially when a program has to be able
to work together with other programs (which might also be adding
handlers), that this is annoying.

@_|attachEvent|_In Internet Explorer, one can add a click handler to a
button like this:

!> $("button").attachEvent("onclick", function(){print("Click!");});

@_|addEventListener|_On the other browsers, it goes like this:

!> $("button").addEventListener("click", function(){print("Click!");},
!>                              false);

Note how |"on"| is left off in the second case. The third argument
to |addEventListener|, |false|, indicates that the event should
'bubble' through the DOM tree as normal. Giving |true| instead can be
used to give this handler priority over the handlers 'beneath' it, but
since Internet Explorer does not support such a thing, this is rarely
useful.

***

Write a function called |registerEventHandler| to wrap the
incompatibilities of these two models. It takes three arguments: first
a DOM node that the handler should be attached to, then the name of
the event type, such as |"click"| or |"keypress"|, and finally the
handler function.

To determine which method should be called, look for the methods
themselves -- if the DOM node has a method called |attachEvent|, you
may assume that this is the correct method. Note that this is much
preferable to directly checking whether the browser is Internet
Explorer. If a new browser arrives which uses Internet Explorer's
model, or Internet Explorer suddenly switches to the standard model,
the code will still work. Both are rather unlikely, of course, but
doing something in a smart way never hurts.

///

> function registerEventHandler(node, event, handler) {
>   if (typeof node.addEventListener == "function")
>     node.addEventListener(event, handler, false);
>   else
>     node.attachEvent("on" + event, handler);
> }
>
> registerEventHandler($("button"), "click",
>                      function(){print("Click (2)");});

Don't fret about the long, clumsy name. Later on, we will have to add
an extra wrapper to wrap this wrapper, and it will have a shorter
name.

It is also possible to do this check only once, and define
|registerEventHandler| to hold a different function depending on the
browser. This is more efficient, but a little strange.

> if (typeof document.addEventListener == "function")
>   var registerEventHandler = function(node, event, handler) {
>     node.addEventListener(event, handler, false);
>   };
> else
>   var registerEventHandler = function(node, event, handler) {
>     node.attachEvent("on" + event, handler);
>   };

---

Removing events works very much like adding them, but this time the
methods _|detachEvent|_ and _|removeEventListener|_ are used. Note
that, to remove a handler, you need to have access to the function you
attached to it.

> function unregisterEventHandler(node, event, handler) {
>   if (typeof node.removeEventListener == "function")
>     node.removeEventListener(event, handler, false);
>   else
>     node.detachEvent("on" + event, handler);
> }

---

Exceptions produced by event handlers can, because of technical
limitations, not be caught by the console. Thus, they are handled by
the browser, which might mean they get hidden in some kind of 'error
console' somewhere, or cause a message to pop up. When you write an
event handler and it does not seem to work, it might be silently
aborting because it causes some kind of error.

---

@_|event|_Most browsers pass the _event object_ as an argument to the
handler. Internet Explorer stores it in the top-level variable called
|event|. When looking at JavaScript code, you will often come across
something like |event || window.event|, which takes the local variable
|event| or, if that is undefined, the top-level variable by that same
name.

> function showEvent(event) {
>   show(event || window.event);
> }
>
> registerEventHandler($("textfield"), "keypress", showEvent);

Type a few characters in the field, look at the objects, and shut it
up again:

> unregisterEventHandler($("textfield"), "keypress", showEvent);

---

@_|onmousedown|_@_|onmouseup|_@_|onclick|_@_|ondblclick|_When the user
clicks his mouse, three events are generated. First _|mousedown|_, at
the moment the mouse button is pressed. Then, _|mouseup|_, at the
moment it is released. And finally, _|click|_, to indicate something
was clicked. When this happens two times in quick succession, a
_|dblclick|_ (double-click) event is also generated. Note that it is
possible for the |mousedown| and |mouseup| events to happen some time
apart -- when the mouse button is held for a while.

When you attach an event handler to, for example, a button, the fact
that it has been clicked is often all you need to know. When the
handler, on the other hand, is attached to a node that has children,
clicks from the children will 'bubble' up to it, and you will want to
find out which child has been clicked. For this purpose, event objects
have a property called _|target|_... or |srcElement|, depending on the
browser.

@_|scrollTop|_@_|scrollLeft|_Another interesting piece of information
are the precise coordinates at which the click occurred. Event objects
related to the mouse contain _|clientX|_ and _|clientY|_ properties,
which give the |x| and |y| coordinates of the mouse, in pixels, on the
screen. Documents can scroll, though, so often these coordinates do
not tell us much about the part of the document that the mouse is
over. Some browsers provide _|pageX|_ and _|pageY|_ properties for
this purpose, but others (guess which) do not. Fortunately, the
information about the amount of pixels the document has been scrolled
can be found in |document.body.scrollLeft| and
|document.body.scrollTop|.

This handler, attached to the whole document, intercepts all mouse
clicks, and prints some information about them.

> function reportClick(event) {
>   event = event || window.event;
>   var target = event.target || event.srcElement;
>   var pageX = event.pageX, pageY = event.pageY;
>   if (pageX == undefined) {
>     pageX = event.clientX + document.body.scrollLeft;
>     pageY = event.clientY + document.body.scrollTop;
>   }
>
>   print("Mouse clicked at ", pageX, ", ", pageY,
>         ". Inside element:");
>   show(target);
> }
> registerEventHandler(document, "click", reportClick);

And get rid of it again:

> unregisterEventHandler(document, "click", reportClick);

Obviously, writing all these checks and workarounds is not something
you want to do in every single event handler. In a moment, after we
have gotten acquainted with a few more incompatibilities, we will
write a function to 'normalise' event objects to work the same across
browsers.

It is also sometimes possible to find out which mouse button was
pressed, using the _|which|_ and _|button|_ properties of event
objects. Unfortunately, this is very unreliable -- some browsers
pretend mouses have only one button, others report right-clicks as
clicks during which the control key was held down, and so on.

---

@_|onmousemove|_@_|onmouseover|_@_|onmouseout|_Apart from clicks, we
might also be interested in the movement of the mouse. The
_|mousemove|_ event of a DOM node is fired whenever the mouse moves
while it is over that element. There are also _|mouseover|_ and
_|mouseout|_, which are fired only when the mouse enters or leaves a
node. For events of this last type, the |target| (or |srcElement|)
property points at the node that the event is fired for, while the
_|relatedTarget|_ (or |toElement|, or |fromElement|) property gives
the node that the mouse came from (for |mouseover|) or left to (for
|mouseout|).

|mouseover| and |mouseout| can be tricky when they are registered on
an element that has child nodes. Events fired for the child nodes will
bubble up to the parent element, so you will also see a |mouseover|
event when the mouse enters one of the child nodes. The |target| and
|relatedTarget| properties can be used to detect (and ignore) such
events.

---

@_|onkeydown|_@_|onkeyup|_@_|onkeypress|_For every key that the user
presses, three events are generated: _|keydown|_, _|keyup|_, and
_|keypress|_. In general, you should use the first two in cases where
you really want to know which key was pressed, for example when you
want to do something when the arrow keys are pressed. |keypress|, on
the other hand, is to be used when you are interested in the character
that is being typed. The reason for this is that there is often no
character information in |keyup| and |keydown| events, and Internet
Explorer does not generate a |keypress| event at all for special keys
such as the arrow keys.

Finding out which key was pressed can be quite a challenge by itself.
For |keydown| and |keyup| events, the event object will have a
_|keyCode|_ property, which contains a number. Most of the time, these
codes can be used to identify keys in a reasonably browser-independant
way. Finding out which code corresponds to which key can be done by
simple experiments...

> function printKeyCode(event) {
>   event = event || window.event;
>   print("Key ", event.keyCode, " was pressed.");
> }
>
> registerEventHandler($("textfield"), "keydown", printKeyCode);

> unregisterEventHandler($("textfield"), "keydown", printKeyCode);

In most browsers, a single key code corresponds to a single *physical*
key on your keyboard. The Opera browser, however, will generate
different key codes for some keys depending on whether shift is
pressed or not. Even worse, some of these shift-is-pressed codes are
the same codes that are also used for other keys -- shift-9, which on
most keyboards is used to type a parenthesis, gets the same code as
the down arrow, and as such is hard to distinguish from it. When this
threatens to sabotage your programs, you can usually resolve it by
ignoring key events that have shift pressed.

To find out whether the shift, control, or alt key was held during a
key or mouse event, you can look at the _|shiftKey|_, _|ctrlKey|_, and
_|altKey|_ properties of the event object.

For |keypress| events, you will want to know which character was
typed. The event object will have a _|charCode|_ property, which, if
you are lucky, contains the _Unicode_ number corresponding to the
character that was typed, which can be converted to a 1-character
string by using _|String.fromCharCode|_. Unfortunately, some browsers
do not define this property, or define it as |0|, and store the
character code in the _|keyCode|_ property instead.

> function printCharacter(event) {
>   event = event || window.event;
>   var charCode = event.charCode;
>   if (charCode == undefined || charCode === 0)
>     charCode = event.keyCode;
>   print("Character '", String.fromCharCode(charCode), "'");
> }
>
> registerEventHandler($("textfield"), "keypress", printCharacter);

> unregisterEventHandler($("textfield"), "keypress", printCharacter);

---

An event handler can 'stop' the event it is handling. There are two
different ways to do this. You can prevent the event from bubbling up
to parent nodes and the handlers defined on those, and you can prevent
the browser from taking the standard action associated with such an
event. It should be noted that browsers do not always follow this --
preventing the default behaviour for the pressing of certain 'hotkeys'
will, on many browsers, not actually keep the browser from executing
the normal effect of these keys.

On most browsers, stopping event bubbling is done with the
_|stopPropagation|_ method of the event object, and preventing default
behaviour is done with the _|preventDefault|_ method. For Internet
Explorer, this is done by setting the _|cancelBubble|_ property of
this object to |true|, and the _|returnValue|_ property to |false|,
respectively.

And that was the last of the long list of incompatibilities that we
will discuss in this chapter. Which means that we can finally write
the event normaliser function and move on to more interesting things.

> function normaliseEvent(event) {
>   if (!event.stopPropagation) {
>     event.stopPropagation = function() {this.cancelBubble = true;};
>     event.preventDefault = function() {this.returnValue = false;};
>   }
>   if (!event.stop) {
>     event.stop = function() {
>       this.stopPropagation();
>       this.preventDefault();
>     };
>   }
>
>   if (event.srcElement && !event.target)
>     event.target = event.srcElement;
>   if ((event.toElement || event.fromElement) && !event.relatedTarget)
>     event.relatedTarget = event.toElement || event.fromElement;
>   if (event.clientX != undefined && event.pageX == undefined) {
>     event.pageX = event.clientX + document.body.scrollLeft;
>     event.pageY = event.clientY + document.body.scrollTop;
>   }
>   if (event.type == "keypress") {
>     if (event.charCode === 0 || event.charCode == undefined)
>       event.character = String.fromCharCode(event.keyCode);
>     else
>       event.character = String.fromCharCode(event.charCode);
>   }
>
>   return event;
> }

A _|stop|_ method is added, which cancels both the bubbling and
the default action of the event. Some browsers already provide this,
in which case we leave it as it is.

Next we can write convenient wrappers for |registerEventHandler| and
|unregisterEventHandler|:

> function addHandler(node, type, handler) {
>   function wrapHandler(event) {
>     handler(normaliseEvent(event || window.event));
>   }
>   registerEventHandler(node, type, wrapHandler);
>   return {node: node, type: type, handler: wrapHandler};
> }
>
> function removeHandler(object) {
>   unregisterEventHandler(object.node, object.type, object.handler);
> }
>
> var blockQ = addHandler($("textfield"), "keypress", function(event) {
>   if (event.character.toLowerCase() == "q")
>     event.stop();
> });

The new |addHandler| function wraps the handler function it is given
in a new function, so it can take care of normalising the event
objects. It returns an object that can be given to |removeHandler|
when we want to remove this specific handler. Try typing a '|q|' in
the text field.

> removeHandler(blockQ);

---

Armed with |addHandler| and the |dom| function from the last chapter,
we are ready for more challenging feats of document-manipulation. As
an exercise, we will implement the game known as _Sokoban_. This is
something of a classic, but you may not have seen it before. The rules
are this: There is a grid, made up of walls, empty space, and one or
more 'exits'. On this grid, there are a number of crates or stones,
and a little dude that the player controls. This dude can be moved
horizontally and vertically into empty squares, and can push the
boulders around, provided that there is empty space behind them. The
goal of the game is to move a given number of boulders into the exits.

Just like the terraria from \\coo, a Sokoban level can be represented
as text. The variable |sokobanLevels|, in the |example_events.html|
window, contains an array of level objects. Each level has a property
|field|, containing a textual representation of the level, and a
property |boulders|, indicating the amount of boulders that must be
expelled to finish the level.

> show(sokobanLevels.length);
> show(sokobanLevels[1].boulders);
> forEach(sokobanLevels[1].field, print);

In such a level, the |#| characters are walls, spaces are empty
squares, |0| characters are used for for boulders, an |@| for the
starting location of the player, and a |*| for the exit.

---

But, when playing the game, we do not want to be looking at this
textual representation. Instead, we will put a _table_ into the
document. I made small _style-sheet_ ([sokoban.css | css/sokoban.css],
if you are curious what it looks like) to give the cells of this table
a fixed square size, and added it to the example document. Each of the
cells in this table will get a background image, representing the type
of the square (empty, wall, or exit). To show the location of the
player and the boulders, images are added to these table cells, and
moved to different cells as appropriate.

It would be possible to use this table as the main representation of
our data -- when we want to look whether there is a wall in a given
square, we just inspect the background of the appropriate table cell,
and to find the player, we just search for the image node with the
correct |src| property. In some cases, this approach is practical, but
for this program I chose to keep a separate data structure for the
grid, because it makes things much more straightforward.

This data structure is a two-dimensional grid of objects, representing
the squares of the playing field. Each of the objects must store the
type of background it has and whether there is a boulder or player
present in that cell. It should also contain a reference to the table
cell that is used to display it in the document, to make it easy to
move images in and out of this table cell.

That gives us two kinds of objects -- one to hold the grid of the
playing field, and one to represent the individual cells in this grid.
If we want the game to also do things like moving the next level at
the appropriate moment, and being able to reset the current level when
you mess up, we will also need a 'controller' object, which creates or
removes the field objects at the appropriate moment. For convenience,
we will be using the prototype approach outlined at the end of \\coo,
so object types are just prototypes, and the |create| method, rather
than the |new| operator, is used to make new objects.

---

Let us start with the objects representing the squares of the game's
field. They are responsible for setting the background of their cells
correctly, and adding images as appropriate. The |img/sokoban/|
directory contains a set of images, based on another ancient game,
which will be used to visualise the game. For a start, the |Square|
prototype could look like this.

> var Square = {
>   construct: function(character, tableCell) {
>     this.background = "empty";
>     if (character == "#")
>       this.background = "wall";
>     else if (character == "*")
>       this.background = "exit";
> 
>     this.tableCell = tableCell;
>     this.tableCell.className = this.background;
> 
>     this.content = null;
>     if (character == "0")
>       this.content = "boulder";
>     else if (character == "@")
>       this.content = "player";
>
>     if (this.content != null) {
>       var image = dom("IMG", {src: "img/sokoban/" +
>                                    this.content + ".gif"});
>       this.tableCell.appendChild(image);
>     }
>   },
> 
>   hasPlayer: function() {
>     return this.content == "player";
>   },
>   hasBoulder: function() {
>     return this.content == "boulder";
>   },
>   isEmpty: function() {
>     return this.content == null && this.background == "empty";
>   },
>   isExit: function() {
>     return this.background == "exit";
>   }
> };
>
> var testSquare = Square.create("@", dom("TD"));
> show(testSquare.hasPlayer());

The |character| argument to the constructor will be used to transform
characters from the level blueprints into actual |Square| objects. To
set the background of the cells, style-sheet classes are used (defined
in [sokoban.css | css/sokoban.css]), which are assigned to the |td|
elements' |className| property.

The methods like |hasPlayer| and |isEmpty| are a way to 'isolate' the
code that uses objects of this type from the internals of the objects.
They are not strictly necessary in this case, but they will make the
other code look better.

***

Add methods |moveContent| and |clearContent| to the |Square|
prototype. The first one takes another |Square| object as an argument,
and moves the content of the |this| square into the argument by
updating the |content| properties and moving the image node associated
with this content. This will be used to move boulders and players
around the grid. It may assume the square is not currently empty.
|clearContent| removes the content from the square without moving it
anywhere. Note that the |content| property for empty squares contains
|null|.

The |removeElement| function we defined in \\cdom is available in this
chapter too, for your node-removing convenience. You may assume that
the images are the only child nodes of the table cells, and can thus
be reached through, for example, |this.tableCell.lastChild|.

///

> Square.moveContent = function(target) {
>   target.content = this.content;
>   this.content = null;
>   target.tableCell.appendChild(this.tableCell.lastChild);
> };
> Square.clearContent = function() {
>   this.content = null;
>   removeElement(this.tableCell.lastChild);
> };

---

The next object type will be called |SokobanField|. Its constructor is
given an object from the |sokobanLevels| array, and is responsible for
building both a table of DOM nodes and a grid of |Square| objects.
This object will also take care of the details of moving the player
and boulders around, through a |move| method that is given an argument
indicating which way the player wants to move.

To identify the individual squares, and to indicate directions, we
will again use the |Point| object type from \\coo, which, as you might
remember, has an |add| method.

The base of the field prototype looks like this:

> var SokobanField = {
>   construct: function(level) {
>     var tbody = dom("TBODY");
>     this.squares = [];
>     this.bouldersToGo = level.boulders;
> 
>     for (var y = 0; y < level.field.length; y++) {
>       var line = level.field[y];
>       var tableRow = dom("TR");
>       var squareRow = [];
>       for (var x = 0; x < line.length; x++) {
>         var tableCell = dom("TD");
>         tableRow.appendChild(tableCell);
>         var square = Square.create(line.charAt(x), tableCell);
>         squareRow.push(square);
>         if (square.hasPlayer())
>           this.playerPos = new Point(x, y);
>       }
>       tbody.appendChild(tableRow);
>       this.squares.push(squareRow);
>     }
> 
>     this.table = dom("TABLE", {"class": "sokoban"}, tbody);
>     this.score = dom("DIV", null, "...");
>     this.updateScore();
>   },
> 
>   getSquare: function(position) {
>     return this.squares[position.y][position.x];
>   },
>   updateScore: function() {
>     this.score.firstChild.nodeValue = this.bouldersToGo + 
>                                       " boulders to go.";
>   },
>   won: function() {
>     return this.bouldersToGo <= 0;
>   }
> };
>
> var testField = SokobanField.create(sokobanLevels[0]);
> show(testField.getSquare(new Point(10, 2)).content);

The constructor goes over the lines and characters in the level, and
stores the |Square| objects in the |squares| property. When it
encounters the square with the player, it saves this position as
|playerPos|, so that we can easily find the square with the player
later on. |getSquare| is used to find a |Square| object corresponding
to a certain |x,y| position on the field. Note that it doesn't take
the edges of the field into account -- to avoid writing some boring
code, we assume that the field is properly walled off, making it
impossible to walk out of it.

The word |"class"| in the |dom| call that makes the |table| node is
quoted as a string. This is necessary because _|class|_ is a 'reserved
word' in JavaScript, and may not be used as a variable or property
name.

The amount of boulders that have to be cleared to win the level (this
may be less than the total amount of boulders on the level) is stored
in |bouldersToGo|. Whenever a boulder is brought to the exit, we can
subtract 1 from this, and see whether the game is won yet. To show the
player how he is doing, we will have to show this amount somehow. For
this purpose, a |div| element with text is used. |div| nodes are
containers without inherent markup. The score text can be updated with
the |updateScore| method. The |won| method will be used by the
controller object to determine when the game is over, so the player
can move on to the next level.

---

If we want to actually see the playing field and the score, we will
have to insert them into the document somehow. That is what the
|place| method is for. We'll also add a |remove| method to make it
easy to remove a field when we are done with it.

> SokobanField.place = function(where) {
>   where.appendChild(this.score);
>   where.appendChild(this.table);
> };
> SokobanField.remove = function() {
>   removeElement(this.score);
>   removeElement(this.table);
> };
>
> testField.place(document.body);

If all went well, you should see a Sokoban field now.

***

But this field doesn't do very much yet. Add a method called |move|.
It takes a |Point| object specifying the move as argument (for example
|-1,0| to move left), and takes care of moving the game elements in
the correct way.

The correct way is this: The |playerPos| property can be used to
determine where the player is trying to move. If there is a boulder
here, look at the square behind this boulder. When there is an exit
there, remove the boulder and update the score. When there is empty
space there, move the boulder into it. Next, try to move the player.
If the square he is trying to move into is not empty, ignore the move.

///

> SokobanField.move = function(direction) {
>   var playerSquare = this.getSquare(this.playerPos);
>   var targetPos = this.playerPos.add(direction);
>   var targetSquare = this.getSquare(targetPos);
>
>   // Possibly pushing a boulder
>   if (targetSquare.hasBoulder()) {
>     var pushTarget = this.getSquare(targetPos.add(direction));
>     if (pushTarget.isEmpty()) {
>       targetSquare.moveContent(pushTarget);
>     }
>     else if (pushTarget.isExit()) {
>       targetSquare.moveContent(pushTarget);
>       pushTarget.clearContent();
>       this.bouldersToGo--;
>       this.updateScore();
>     }
>   }
>   // Moving the player
>   if (targetSquare.isEmpty()) {
>     playerSquare.moveContent(targetSquare);
>     this.playerPos = targetPos;
>   }
> };

By taking care of boulders first, the move code can work the same way
when the player is moving normally and when he is pushing a boulder.
Note how the square behind the boulder is found by adding the
|direction| to the |playerPos| twice. Test it by moving left two
squares:

> testField.move(new Point(-1, 0));
> testField.move(new Point(-1, 0));

If that worked, we moved a boulder into a place from which we can't
get it out anymore, so we'd better throw this field away.

> testField.remove();

---

All the 'game logic' has been taken care of now, and we just need a
controller to make it playable. The controller will be an object type
called |SokobanGame|, which is responsible for the following things:

 * Preparing a place where the game field can be placed.
 * Building and removing |SokobanField| objects.
 * Capturing key events and calling the |move| method on current field with the correct argument.
 * Keeping track of the current level number and moving to the next level when a level is won.
 * Adding buttons to reset the current level or the whole game (back to level 0).

We start again with an unfinished prototype.

> var SokobanGame = {
>   construct: function(place) {
>     this.level = null;
>     this.field = null;
> 
>     var newGame = dom("BUTTON", null, "New game");
>     addHandler(newGame, "click", method(this, "newGame"));
>     var reset = dom("BUTTON", null, "Reset level");
>     addHandler(reset, "click", method(this, "reset"));
>     this.container = dom("DIV", null,
>                          dom("H1", null, "Sokoban"),
>                          dom("DIV", null, newGame, " ", reset));
>     place.appendChild(this.container);
> 
>     addHandler(document, "keydown", method(this, "keyDown"));
>     this.newGame();
>   },
> 
>   newGame: function() {
>     this.level = 0;
>     this.reset();
>   },
>   reset: function() {
>     if (this.field)
>       this.field.remove();
>     this.field = SokobanField.create(sokobanLevels[this.level]);
>     this.field.place(this.container);
>   },
>
>   keyDown: function(event) {
>     // To be filled in
>   }
> };

The constructor builds a |div| element to hold the field, along with
two buttons and a title. Note how |method| is used to attach methods
on the |this| object to events.

We can put a Sokoban game into our document like this:

> var sokoban = SokobanGame.create(document.body);

***

All that is left to do now is filling in the key event handler.
Replace the |keyDown| method of the prototype with one that detects
presses of the arrow keys and, when it finds them, moves the player in
the correct direction. The following |Dictionary| will probably come
in handy:

> var arrowKeyCodes = new Dictionary({
>   37: new Point(-1, 0), // left
>   38: new Point(0, -1), // up
>   39: new Point(1, 0),  // right
>   40: new Point(0, 1)   // down
> });

After an arrow key has been handled, check |this.field.won()| to find
out if that was the winning move. If the player won, use |alert| to
show a message, and go to the next level. If there is no next level
(check |sokobanLevels.length|), restart the game instead.

It is probably wise to stop the events for key presses after handling
them, otherwise pressing arrow-up and arrow-down will scroll your
window, which is rather annoying.

///

> SokobanGame.keyDown = function(event) {
>   if (arrowKeyCodes.contains(event.keyCode)) {
>     event.stop();
>     this.field.move(arrowKeyCodes.lookup(event.keyCode));
>     if (this.field.won()) {
>       if (this.level < sokobanLevels.length - 1) {
>         alert("Excellent! Going to the next level.");
>         this.level++;
>         this.reset();
>       }
>       else {
>         alert("You win! Game over.");
>         this.newGame();
>       }
>     }
>   }
> };

It has to be noted that capturing keys like this -- adding a handler
to the |document| and stopping the events that you are looking for --
is not very nice when there are other elements in the document. For
example, try moving the cursor around in the text field at the top of
the document. -- It won't work, you'll only move the little man in the
Sokoban game. If a game like this were to be used in a real site, it
is probably best to put it in a frame or window of its own, so that it
only grabs events aimed at its own window.

***

When brought to the exit, the boulders vanish rather abrubtly. By
modifying the |Square.clearContent| method, try to show a 'falling'
animation for boulders that are about to be removed. Make them grow
smaller for a moment before, and then disappear. You can use
|style.width = "50%"|, and similarly for |style.height|, to make an
image appear, for example, half as big as it usually is.

///

We can use |setInterval| to handle the timing of the animation. Note
that the method makes sure to clear the interval after it is done. If
you don't do that, it will continue wasting your computer's time until
the page is closed.

> Square.clearContent = function() {
>   self.content = null;
>   var image = this.tableCell.lastChild;
>   var size = 100;
>
>   var animate = setInterval(function() {
>     size -= 10;
>     image.style.width = size + "%";
>     image.style.height = size + "%";
>
>     if (size < 60) {
>       clearInterval(animate);
>       removeElement(image);
>     }
>   }, 70);
> };

Now, if you have a few hours to waste, try finishing all levels.

---

@_|onfocus|_@_|onblur|_Other event types that can be useful are
_|focus|_ and _|blur|_, which are fired on elements that can be
'focused', such as form inputs. |focus|, obviously, happens when you
put the focus on the element, for example by clicking on it. |blur| is
JavaScript-speak for 'unfocus', and is fired when the focus leaves the
element.

> addHandler($("textfield"), "focus", function(event) {
>   event.target.style.backgroundColor = "yellow";
> });
> addHandler($("textfield"), "blur", function(event) {
>   event.target.style.backgroundColor = "";
> });

@_|onchange|_Another event related to form inputs is _|change|_. This
is fired when the content of the input has changed... except that for
some inputs, such as text inputs, it does not fire until the element
is unfocused.

> addHandler($("textfield"), "change", function(event) {
>   print("Content of text field changed to '",
>         event.target.value, "'.");
> });

You can type all you want, the event will only fire when you click
outside of the input, press tab, or unfocus it in some other way.

@_|submit|_Forms also have a _|submit|_ event, which is fired when
they submit. It can be stopped to prevent the submit from taking
place. This gives us a *much* better way to do the form validation we
saw in the previous chapter. You just register a |submit| handler,
which stops the event when the content of the form is not valid. That
way, when the user does not have JavaScript enabled, the form will
still work, it just won't have instant validation.

@_|onload|_@_|unload|_Window objects have a _|load|_ event that fires
when the document is fully loaded, which can be useful if your script
needs to do some kind of initialisation that has to wait until the
whole document is present. For example, the scripts on the pages for
this book go over the current chapter to hide solutions to exercises.
You can't do that when the exercises are not loaded yet. There is also
an _|unload|_ event, firing when the user leaves the document, but
this is not properly supported by all browsers.

@_|onresize|_Most of the time it is best to leave the laying out of a
document to the browser, but there are effects that can only be
produced by having a piece of JavaScript set the exact sizes of some
nodes in a document. When you do this, make sure you also listen for
_|resize|_ events on the window, and re-calculate the sizes of your
element every time the window is resized.

---

Finally, I have to tell you something about event handlers that you
would rather not know. The Internet Explorer browser (which means, at
the time of writing, the browser used by a majority of web-surfers)
has a bug that causes values to not be cleaned up as normal: Even when
they are no longer used, they stay in the machine's memory. This is
known as a _memory leak_, and, once enough memory has been leaked,
will seriously slow down a computer.

When does this leaking occur? Due to a deficiency in Internet
Explorer's _garbage collector_, the system whose purpose it is to
reclaim unused values, when you have a DOM node that, through one of
its properties or in a more indirect way, refers to a normal
JavaScript object, and this object, in turn, refers back to that DOM
node, both objects will not be collected. This has something to do
with the fact that DOM nodes and other JavaScript objects are
collected by different systems -- the system that cleans up DOM nodes
will take care to leave any nodes that are still referenced by
JavaScript objects, and vice versa for the system that collects normal
JavaScript values.

As the above description shows, the problem is not specifically
related to event handlers. This code, for example, creates a bit of
un-collectable memory:

!> var jsObject = {link: document.body};
!> document.body.linkBack = jsObject;

Even after such an Internet Explorer browser goes to a different page,
it will still hold on to the |document.body| shown here. The reason
this bug is often associated with event handlers is that it is
extremely easy to make such circular links when registering a handler.
The DOM node keeps references to its handlers, and the handler, most
of the time, has a reference to the DOM node. Even when this reference
is not intentionally made, JavaScript's scoping rules tend to add it
implicitly. Consider this function:

!> function addAlerter(element) {
!>   addHandler(element, "click", function() {
!>     alert("Alert! ALERT!");
!>   });
!> }

The anonymous function that is created by the |addAlerter| function
can 'see' the |element| variable. It doesn't use it, but that does not
matter -- just because it can see it, it will have a reference to it.
By registering this function as an event handler on that same
|element| object, we have created a circle.

There are three ways to deal with this problem. The first approach, a
very popular one, is to ignore it. Most scripts will only leak a
little bit, so it takes a long time and a lot of pages before the
problems become noticeable. And, when the problems are so subtle,
who's going to hold *you* responsible? Programmers given to this
approach will often searingly denounce Microsoft for their shoddy
programming, and state that the problem is not their fault, so *they*
shouldn't be fixing it.

Such reasoning is not entirely without merit, of course. But when half
your users are having problems with the web-pages you make, it is hard
to deny that there is a practical problem. Which is why people working
on 'serious' sites usually make an attempt not to leak any memory.
Which brings us to the second approach: Painstakingly making sure that
no circular references between DOM objects and regular objects are
created. This means, for example, rewriting the above handler like
this:

> function addAlerter(element) {
>   addHandler(element, "click", function() {
>     alert("Alert! ALERT!");
>   });
>   element = null;
> }

Now the |element| variable no longer points at the DOM node, and the
handler will not leak. This approach is viable, but requires the
programmer to *really* pay attention.

The third solution, finally, is to not worry too much about creating
leaky structures, but to make sure to clean them up when you are done
with them. This means unregistering any event handlers when they are
no longer needed, and registering an |onunload| event to unregister
the handlers that are needed until the page is unloaded. It is
possible to extend an event-registering system, like our |addHandler|
function, to automatically do this. When taking this approach, you
must keep in mind that event handlers are not the only possible source
of memory leaks -- adding properties to DOM node objects can cause
similar problems.

===================
HTTP requests / xhr
===================

As mentioned in \\cweb, communication on the World Wide Web happens
over the _HTTP_ protocol. A simple @_HTTP request_request might look
like this:

] GET /files/fruit.txt HTTP/1.1
] Host: eloquentjavascript.net
] User-Agent: The Imaginary Browser

Which asks for the file |files/fruit.txt| from the server at
|eloquentjavascript.net|. In addition, it specifies that this request
uses version 1.1 of the HTTP protocol -- version 1.0 is also still in
use, and works slightly differently. The |Host| and |User-Agent| lines
follow a pattern: They start with a word that identifies the
information they contain, followed by a colon and the actual
information. These are called '_header_s'. The |User-Agent| header
tells the server which browser (or other kind of program) is being
used to make the request. Other kinds of headers are often sent along,
for example to state the types of documents that the client can
understand, or the language that it prefers.

When given the above request, the server might send the following
_response_:

] HTTP/1.1 200 OK
] Last-Modified: Mon, 23 Jul 2007 08:41:56 GMT
] Content-Length: 24
] Content-Type: text/plain
]
] apples, oranges, bananas

The first line indicates again the version of the HTTP protocol,
followed by the status of the request. In this case the status code is
|200|, meaning 'OK, nothing out of the ordinary happened, I am sending
you the file'. This is followed by a few headers, indicating (in this
case) the last time the file was modified, its length, and its type
(plain text). After the headers you get a blank line, followed by the
file itself.

Apart from requests starting with |GET|, which indicates the client
just wants to fetch a document, the word |POST| can also be used to
indicate some information will be sent along with the request, which
the server is expected to process in some way.##

## These are not the only types of requests. There is also |HEAD|, to
request just the headers for a document, not its content, |PUT|, to
add a document to a server, and |DELETE|, to delete a document. These
are not used by browsers, and often not supported by web-servers, but
-- if you add server-side programs to support them -- they can be
useful.

---

When you click a link, submit a form, or in some other way encourage
your browser to go to a new page, it will do an HTTP request and
immediately unload the old page to show the newly loaded document. In
typical situations, this is just what you want -- it is how the web
traditionally works. Sometimes, however, a JavaScript program wants to
communicate with the server without re-loading the page. The 'Load'
button in the console, for example, can load files without leaving the
page.

To be able to do things like that, the JavaScript program must make
the HTTP request itself. Contemporary browsers provide an interface
for this. As with opening new windows, this interface is subject to
some restrictions. To prevent a script from doing anything scary, it
is only allowed to make HTTP requests to the domain that the current
page came from.

---

@_|XMLHttpRequest|_An object used to make an HTTP request can, on most
browsers, be created by doing |new XMLHttpRequest()|. Older versions
of Internet Explorer, which originally invented these objects, require
you to do |new ActiveXObject("Msxml2.XMLHTTP")| or, on even older
versions, |new ActiveXObject("Microsoft.XMLHTTP")|. _|ActiveXObject|_
is Internet Explorer's interface to various kinds of browser add-ons.
We are already used to writing incompatibility-wrappers by now, so let
us do so again:

> function makeHttpObject() {
>   try {return new XMLHttpRequest();}
>   catch (error) {}
>   try {return new ActiveXObject("Msxml2.XMLHTTP");}
>   catch (error) {}
>   try {return new ActiveXObject("Microsoft.XMLHTTP");}
>   catch (error) {}
>
>   throw new Error("Could not create HTTP request object.");
> }
>
> show(typeof(makeHttpObject()));

The wrapper tries to create the object in all three ways, using |try|
and |catch| to detect which ones fail. If none of the ways work, which
might be the case on older browsers or browsers with strict security
settings, it raises and error.

Now why is this object called an *XML* HTTP request? This is a bit of
a misleading name. _XML_ is a way to store textual data. It uses tags
and attributes like HTML, but is more structured and flexible -- to
store your own kinds of data, you may define your own types of XML
tags. These HTTP request objects have some built-in functionality for
dealing with retrieved XML documents, which is why they have XML in
their name. They can also handle other types of documents, though, and
in my experience they are used just as often for non-XML requests.

---

Now that we have our HTTP object, we can use it to make a request
similar the example shown above.

> var request = makeHttpObject();
> request.open("GET", "files/fruit.txt", false);
> request.send(null);
> print(request.responseText);

The _|open|_ method is used to configure a request. In this case we
choose to make a |GET| request for our |fruit.txt| file. The _URL_
given here is relative, it does not contain the |http://| part or a
server name, which means it will look for the file on the server that
the current document came from. The third parameter, |false|, will be
discussed in a moment. After |open| has been called, the actual
request can be made with the _|send|_ method. When the request is a
|POST| request, the data to be sent to the server (as a string) can be
passed to this method. For |GET| requests, one should just pass
|null|.

After the request has been made, the _|responseText|_ property of the
request object contains the content of the retrieved document. The
headers that the server sent back can be inspected with the
_|getResponseHeader|_ and _|getAllResponseHeaders|_ functions. The
first looks up a specific header, the second gives us a string
containing all the headers. These can occasionally be useful to get
some extra information about the document.

> print(request.getAllResponseHeaders());
> show(request.getResponseHeader("Date"));

If, for some reason, you want to add headers to the request that is
sent to the server, you can do so with the _|setRequestHeader|_
method. This takes two strings as arguments, the name and the value of
the header.

The response code, which was |200| in the example, can be found under
the _|status|_ property. When something went wrong, this cryptic code
will indicate it. For example, |404| means the file you asked for did
not exist. The _|statusText|_ contains a slightly less cryptic
description of the status.

> show(request.status);
> show(request.statusText);

When you want to check whether a request succeeded, comparing the
|status| to |200| is usually enough. In theory, the server might in
some situations return the code |304| to indicate that the older
version of the document, which the browser has stored in its
'_cache_', is still up to date. But it seems that browsers shield you
from this by setting the |status| to |200| even when it is |304|.
Also, if you are doing a request over a non-HTTP protocol##, such as
FTP, the |status| will not be usable because the protocol does not
use HTTP status codes.

## Not only the 'XML' part of the |XMLHttpRequest| name is misleading
-- the object can also be used for request over protocols other than
HTTP, so |Request| is the only meaningful part we have left.

---

When a request is done as in the example above, the call to the |send|
method does not return until the request is finished. This is
convenient, because it means the |responseText| is available after the
call to |send|, and we can start using it immediately. There is a
problem, though. When the server is slow, or the file is big, doing a
request might take quite a while. As long as this is happening, the
program is waiting, which causes the whole browser to wait. Until the
program finishes, the user can not do anything, not even scroll the
page. Pages that run on a local network, which is fast and reliable,
might get away with doing requests like this. Pages on the big great
unreliable Internet, on the other hand, should not.

When the third argument to |open| is |true|, the request is set to be
'_asynchronous_'. This means that |send| will return right away, while
the request happens in the background.

> request.open("GET", "files/fruit.xml", true);
> request.send(null);
> show(request.responseText);

But wait a moment, and...

> print(request.responseText);

'Waiting a moment' could be implemented with |setTimeout| or something
like that, but there is a better way. A request object has a
_|readyState|_ property, indicating the state it is in. This will
become |4| when the document has been fully loaded, and have a smaller
value before that##. To react to changes in this status, you can set
the _|onreadystatechange|_ property of the object to a function. This
function will be called every time the state changes.

## |0| ('uninitialized') is the state of the object before |open| is
called on it. Calling |open| moves it to |1| ('open'). Calling |send|
makes it proceed to |2| ('sent'). When the server responds, it goes to
|3| ('receiving'). Finally, |4| means 'loaded'.

> request.open("GET", "files/fruit.xml", true);
> request.send(null);
> request.onreadystatechange = function() {
>   if (request.readyState == 4)
>     show(request.responseText.length);
> };

---

When the file retrieved by the request object is an XML document, the
request's _|responseXML|_ property will hold a representation of this
document. This representation works like the DOM objects discussed in
\\cdom, except that it doesn't have HTML-specific functionality, such
as |style| or |innerHTML|. |responseXML| gives us a document object,
whose |documentElement| property refers to the outer tag of the XML
document.

> var catalog = request.responseXML.documentElement;
> show(catalog.childNodes.length);

Such XML documents can be used to exchange structured information with
the server. Their form -- tags contained inside other tags -- is often
very suitable to store things that would be tricky to represent as
simple flat text. The DOM interface is rather clumsy for extracting
information though, and XML documents are notoriously wordy: The
|fruit.xml| document looks like a lot, but all it says is 'apples are
red, oranges are orange, and bananas are yellow'.

---

@_|JSON|_As an alternative to XML, JavaScript programmers have come up
with something called [JSON | http://www.json.org]. This uses the
basic notation of JavaScript values to represent 'hierarchical'
information in a more minimalist way. A JSON document is a file
containing a single JavaScript object or array, which in turn contains
any number of other objects, arrays, strings, numbers, booleans, or
|null| values. For an example, look at |fruit.json|:

> request.open("GET", "files/fruit.json", true);
> request.send(null);
> request.onreadystatechange = function() {
>   if (request.readyState == 4)
>     print(request.responseText);
> };

Such a piece of text can be converted to a normal JavaScript value by
using the _|eval|_ function. Parentheses should be added around it
before calling |eval|, because otherwise JavaScript might interpret an
object (enclosed by braces) as a block of code, and produce an error.

> function evalJSON(json) {
>   return eval("(" + json + ")");
> }
> var fruit = evalJSON(request.responseText);
> show(fruit);

When running |eval| on a piece of text, you have to keep in mind that
this means you let the piece of text run whichever code it wants.
Since JavaScript only allows us to make requests to our own domain,
you will usually know exactly what kind of text you are getting, and
this is not a problem. In other situations, it might be unsafe.

***

Write a function called |serializeJSON| which, when given a JavaScript
value, produces a string with the value's JSON representation. Simple
values like numbers and booleans can be simply given to the |String|
function to convert them to a string. Objects and arrays can be
handled by recursion.

Recognizing arrays can be tricky, since its type is |"object"|. You
can use |instanceof Array|, but that only works for arrays that were
created in your own window -- others will use the |Array| prototype
from other windows, and |instanceof| will return |false|. A cheap
trick is to convert the |constructor| property to a string, and see
whether that contains |"function Array"|.

When converting a string, you have to take care to escape special
characters inside it. If you use double-quotes around the string, the
characters to escape are |\"|, |\\|, |\f|, |\b|, |\n|, |\t|, |\r|, and
|\v|##.

## We already saw |\n|, which is a newline. |\t| is a tab character,
|\r| a 'carriage return', which some systems use before or instead of
a newline to indicate the end of a line. |\b| (backspace), |\v|
(vertical tab), and |\f| (form feed) are useful when working with old
printers, but less so when dealing with Internet browsers.

///

> function serializeJSON(value) {
>   function isArray(value) {
>     return /^\s*function Array/.test(String(value.constructor));
>   }
>
>   function serializeArray(value) {
>     return "[" + map(serializeJSON, value).join(", ") + "]";
>   }
>   function serializeObject(value) {
>     var properties = [];
>     forEachIn(value, function(name, value) {
>       properties.push(serializeString(name) + ": " +
>                       serializeJSON(value));
>     });
>     return "{" + properties.join(", ") + "}";
>   }
>   function serializeString(value) {
>     var special =
>       {"\"": "\\\"", "\\": "\\\\", "\f": "\\f", "\b": "\\b",
>        "\n": "\\n", "\t": "\\t", "\r": "\\r", "\v": "\\v"};
>     var escaped = value.replace(/[\"\\\f\b\n\t\r\v]/g,
>                                 function(c) {return special[c];});
>     return "\"" + escaped + "\"";
>   }
>
>   var type = typeof value;
>   if (type == "object" && isArray(value))
>     return serializeArray(value);
>   else if (type == "object")
>     return serializeObject(value);
>   else if (type == "string")
>     return serializeString(value);
>   else
>     return String(value);
> }
>
> print(serializeJSON(fruit));

The trick used in |serializeString| is similar to what we saw in the
|escapeHTML| function in \\cregexp. It uses an object to look up the
correct replacements for each of the characters. Some of them, such as
|"\\\\"|, look quite weird because of the need to put two backslashes
for every backslash in the resulting string.

Also note that the names of properties are quoted as strings. For some
of them, this is not necessary, but for property names with spaces and
other strange things in them it is, so the code just takes the easy
way out and quotes everything.

---

When making lots of requests, we do, of course, not want to repeat the
whole |open|, |send|, |onreadystatechange| ritual every time. A very
simple wrapper could look like this:

> function simpleHttpRequest(url, success, failure) {
>   var request = makeHttpObject();
>   request.open("GET", url, true);
>   request.send(null);
>   request.onreadystatechange = function() {
>     if (request.readyState == 4) {
>       if (request.status == 200)
>         success(request.responseText);
>       else if (failure)
>         failure(request.status, request.statusText);
>     }
>   };
> }
>
> simpleHttpRequest("files/fruit.txt", print);

The function retrieves the url it is given, and calls the function it
is given as a second argument with the content. When a third argument
is given, this is used to indicate failure -- a non-|200| status code.

To be able to do more complex requests, the function could be made to
accept extra parameters to specify the method (|GET| or |POST|), an
optional string to post as data, a way to add extra headers, and so
on. When you have so many arguments, you'd probably want to pass them
as an arguments-object as seen in \\cmodularity.

---

Some websites make use of intensive communication between the programs
running on the client and the programs running on the server. For such
systems, it can be practical to think of some HTTP requests as calls
to functions that run on the server. The client makes request to URLs
that identify the functions, giving the arguments as URL parameters or
|POST| data. The server then calls the function, and puts the result
into JSON or XML document that it sends back. If you write a few
convenient support functions, this can make calling server-side
functions almost as easy as calling client-side ones... except, of
course, that you do not get their results instantly.

+++++++++++++++++++++++++++++++++++++++++++
More (obscure) control structures / control
+++++++++++++++++++++++++++++++++++++++++++

In \\cbasics, a number of control statements were introduced, such as
|while|, |for|, and |break|. To keep things simple, I left out some
others, which, in my experience, are a lot less useful. This appendix
briefly describes these missing control statements.

---

First, there is _|do|_. |do| works like |while|, but instead of
executing the loop body zero or more times, it executes it one or more
times. A |do| loop looks like this:

> do {
>   var answer = prompt("Say 'moo'.", "");
>   print("You said '", answer, "'.");
> } while (answer != "moo");

To emphasise the fact that the condition is only checked *after* the
loop has run once, it is written at the end of the loop's body.

---

Next, there is _|continue|_. This one is closely related to |break|,
and can be used in the same places. While |break| jumps *out* of a
loop and causes the program to proceed after the loop, |continue|
jumps to the next iteration of the loop.

> for (var i = 0; i < 10; i++) {
>   if (i % 3 != 0)
>     continue;
>   print(i, " is divisible by three.");
> }

A similar effect can usually be produced using just |if|, but there
are cases where |continue| looks nicer.

---

When there is a loop sitting inside another loop, a |break| or
|continue| statement will affect only the inner loop. Sometimes you
want to jump out of the *outer* loop. To be able to refer to a
specific loop, loop statements can be _label_led. A label is a name
(any valid variable name will do), followed by a colon (|:|).

> outer: for (var sideA = 1; sideA < 10; sideA++) {
>   inner: for (var sideB = 1; sideB < 10; sideB++) {
>     var hypotenuse = Math.sqrt(sideA * sideA + sideB * sideB);
>     if (hypotenuse % 1 == 0) {
>       print("A right triangle with straight sides of length ",
>             sideA, " and ", sideB, " has a hypotenuse of ",
>             hypotenuse, ".");
>       break outer;
>     }
>   }
> }

---

Next, there is a construct called _|switch|_ which can be used to
choose which code to execute based on some value. This is a very
useful thing to do, but the syntax JavaScript uses for this (which it
took from the C programming language) is so clumsy and ugly that I
usually prefer to use a chain of |if| statements instead.

> function weatherAdvice(weather) {
>   switch(weather) {
>     case "rainy":
>       print("Remember to bring an umbrella.");
>       break;
>     case "sunny":
>       print("Dress lightly.");
>     case "cloudy":
>       print("Go outside.");
>       break;
>     default:
>       print("Unknown weather type: ", weather);
>       break;
>   }
> }
>
> weatherAdvice("sunny");

Inside the block opened by |switch|, you can write a number of |case|
labels. The program will jump to the label that corresponds to the
value that |switch| was given (comparing the values with an equivalent
of |===|, so without automatic type conversion), or to |default| if no
matching value is found. Then it start executing statements there, and
*continues* past other labels, until it reaches a |break| statement.
In some cases, such as the |"sunny"| case in the example, this can be
used to share some code between cases (it recommends going outside for
both sunny and cloudy weather). Most of the time, this just adds a lot
of ugly |break| statements, or causes problems when you forget to add
one.

Like loops, |switch| statements can be given a label.

---

Finally, there is a keyword named _|with|_. I've never actually *used*
this in a real program, but I have seen other people use it, so it is
useful to know what it is. Code using |with| looks like this:

> var scope = "outside";
> var object = {name: "Ignatius", scope: "inside"};
> with(object) {
>   print("Name == ", name, ", scope == ", scope);
>   name = "Raoul";
>   var newVariable = 49;
> }
> show(object.name);
> show(newVariable);

Inside the block, the properties of the object given to |with| act as
variables. Newly introduced variables are *not* added as properties to
this object though. I assume the idea behind this construct was that
it could be useful in methods that make lots of use of the properties
of their object. You could start such a method with |with(this)
{...}|, and not have to write |this| all the time after that.

+++++++++++++++++++++++++
Binary Heaps / binaryheap
+++++++++++++++++++++++++

In \\csearch, the _binary heap_ was introduced as a method to store a
collection of objects in such a way that the smallest element can be
quickly found. As promised, this appendix will explain the details
behind this data structure.

Consider again the problem we needed to solve. The A* algorithm
created large amounts of small objects, and had to keep these in an
'open list'. It was also constantly removing the smallest element from
this list. The simplest approach would be to just keep all the objects
in an array, and search for the smallest one when we need it. But,
unless we have a *lot* of time, this will not do. Finding the smallest
element in an unsorted array requires going over the whole array, and
checking each element.

The next solution would be, of course, to sort our array. JavaScript
arrays have a wonderful _|sort|_ method, which can be used to do the
heavy work. Unfortunately, re-sorting a whole array every time an
element is removed is more work than searching for a minimum value in
an unsorted array. Some tricks can be used, such as, instead of
re-sorting the whole array, just making sure new values are inserted
in the right place so that the array, which was sorted before, stays
sorted. This is coming closer to the approach a binary heap uses
already, but inserting a value in the middle of an array requires
moving all the elements after it one place up, which is still just too
slow.

Another approach is to not use an array at all, but to store the
values in a set of interconnected objects. A simple form of this is to
have every object hold one value and two (or less) links to other
objects. There is one root object, holding the smallest value, which
is used to access all the other objects. Links always point to objects
holding greater values, so the whole structure looks something like
this:

[[tree.png]]

Such structures are usually called _tree_s, because of the way they
branch. Now, when you need the smallest element, you just take off the
top element and rearrange the tree so that one of the top element's
children -- the one with the lowest value -- becomes the new top. When
inserting new elements, you 'descend' the tree until you find an
element less than the new element, and insert it there. This takes a
lot less searching than a sorted array does, but it has the
disadvantage of creating a lot of objects, which also slows things
down.

---

A binary heap, then, does make use of a sorted array, but it is only
partially sorted, much like the tree above. Instead of objects, the
positions in the array are used to form a tree, as this picture tries
to show:

[[heap.png]]

Array element |1| is the root of the tree, array element |2| and |3|
are its children, and in general array element |X| has children |X *
2| and |X * 2 + 1|. You can see why this structure is called a 'heap'.
Note that this array starts at |1|, while JavaScript arrays start at
|0|. The heap will always keep the smallest element in position |1|,
and make sure that for every element in the array at position |X|, the
element at |X / 2| (round down) is smaller.

Finding the smallest element is now a matter of taking the element at
position |1|. But when this element is removed, the heap must make
sure that there are no holes left in the array. To do this, it takes
the last element in the array and moves it to the start, and then
compares it to its child elements at position |2| and |3|. It is
likely to be greater, so it is exchanged with one of them, and the
process of comparing it with its children is repeated for the new
position, and so on, until it comes to a position where its children
are greater, or a position where it has no children.

] [2, 3, 5, 4, 8, 7, 6]
] Take out 2, move 6 to the front.
] [6, 3, 5, 4, 8, 7]
] 6 is greater than its first child 3, so swap them.
] [3, 6, 5, 4, 8, 7]
] Now 6 has children 4 and 8 (position 4 and 5). It is greater than
] 4, so we swap again.
] [3, 4, 5, 6, 8, 7]
] 6 is in position 4, and has no more children. The heap is in order
] again.

Similarly, when an element has to be added to the heap, it is put at
the end of the array and allowed to 'bubble' up by repeatedly
exchanging it with its parent, until we find a parent that is less
than the new node.

] [3, 4, 5, 6, 8, 7]
] Element 2 gets added again, it starts at the back.
] [3, 4, 5, 6, 8, 7, 2]
] 2 is in position 7, its parent is at 3, which is a 5. 5 is greater
] than 2, so we swap.
] [3, 4, 2, 6, 8, 7, 5]
] The parent of position 3 is position 1. Again, we swap.
] [2, 4, 3, 6, 8, 7, 5]
] The element can not go further than position 1, so we are done.

Note how adding or inserting an element does not require it to be
compared with every element in the array. In fact, because the jumps
between parents and children get bigger as the array gets bigger, this
advantage is especially large when we have a lot of elements##.

## The amount of comparisons and swaps that are needed -- in the worst
case -- can be approached by taking the logarithm (base 2) of the
amount of elements in the heap.

---

Here is the full code of a binary heap implementation. Two things to
note are that, instead of directly comparing the elements put into the
heap, a function (|scoreFunction|) is first applied to them, so that
it becomes possible to store objects that can not be directly
compared.

Also, because JavaScript arrays start at |0|, and the parent/child
calculations use a system that starts at |1|, there are a few strange
calculations to compensate.

> function BinaryHeap(scoreFunction){
>   this.content = [];
>   this.scoreFunction = scoreFunction;
> }
> 
> BinaryHeap.prototype = {
>   push: function(element) {
>     // Add the new element to the end of the array.
>     this.content.push(element);
>     // Allow it to bubble up.
>     this.bubbleUp(this.content.length - 1);
>   },
>
>   pop: function() {
>     // Store the first element so we can return it later.
>     var result = this.content[0];
>     // Get the element at the end of the array.
>     var end = this.content.pop();
>     // If there are any elements left, put the end element at the
>     // start, and let it sink down.
>     if (this.content.length > 0) {
>       this.content[0] = end;
>       this.sinkDown(0);
>     }
>     return result;
>   },
>
>   remove: function(node) {
>     var len = this.content.length;
>     // To remove a value, we must search through the array to find
>     // it.
>     for (var i = 0; i < len; i++) {
>       if (this.content[i] == node) {
>         // When it is found, the process seen in 'pop' is repeated
>         // to fill up the hole.
>         var end = this.content.pop();
>         if (i != len - 1) {
>           this.content[i] = end;
>           if (this.scoreFunction(end) < this.scoreFunction(node))
>             this.bubbleUp(i);
>           else
>             this.sinkDown(i);
>         }
>         return;
>       }
>     }
>     throw new Error("Node not found.");
>   },
>
>   size: function() {
>     return this.content.length;
>   },
>
>   bubbleUp: function(n) {
>     // Fetch the element that has to be moved.
>     var element = this.content[n];
>     // When at 0, an element can not go up any further.
>     while (n > 0) {
>       // Compute the parent element's index, and fetch it.
>       var parentN = Math.floor((n + 1) / 2) - 1,
>           parent = this.content[parentN];
>       // Swap the elements if the parent is greater.
>       if (this.scoreFunction(element) < this.scoreFunction(parent)) {
>         this.content[parentN] = element;
>         this.content[n] = parent;
>         // Update 'n' to continue at the new position.
>         n = parentN;
>       }
>       // Found a parent that is less, no need to move it further.
>       else {
>         break;
>       }
>     }
>   },
>
>   sinkDown: function(n) {
>     // Look up the target element and its score.
>     var length = this.content.length,
>         element = this.content[n],
>         elemScore = this.scoreFunction(element);
>
>     while(true) {
>       // Compute the indices of the child elements.
>       var child2N = (n + 1) * 2, child1N = child2N - 1;
>       // This is used to store the new position of the element,
>.      // if any.
>       var swap = null;
>       // If the first child exists (is inside the array)...
>       if (child1N < length) {
>         // Look it up and compute its score.
>         var child1 = this.content[child1N],
>             child1Score = this.scoreFunction(child1);
>         // If the score is less than our element's, we need to swap.
>         if (child1Score < elemScore)
>           swap = child1N;
>       }
>       // Do the same checks for the other child.
>       if (child2N < length) {
>         var child2 = this.content[child2N],
>             child2Score = this.scoreFunction(child2);
>         if (child2Score < (swap == null ? elemScore : child1Score))
>           swap = child2N;
>       }
>
>       // If the element needs to be moved, swap it, and continue.
>       if (swap != null) {
>         this.content[n] = this.content[swap];
>         this.content[swap] = element;
>         n = swap;
>       }
>       // Otherwise, we are done.
>       else {
>         break;
>       }
>     }
>   }
> };

And a simple test...

> var heap = new BinaryHeap(function(x){return x;});
> forEach([10, 3, 4, 8, 2, 9, 7, 1, 2, 6, 5],
>         method(heap, "push"));
>
> heap.remove(2);
> while (heap.size() > 0)
>   print(heap.pop());
